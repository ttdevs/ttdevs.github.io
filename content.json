{"meta":{"title":"ttdevs","subtitle":"你之所以觉得时间一年比一年过得快，是因为时间对你一年比一年重要","description":"ttdevs's blog","author":"ttdevs","url":"https://ttdevs.github.io"},"pages":[{"title":"About","date":"2017-04-17T02:39:44.000Z","updated":"2017-04-17T03:37:50.000Z","comments":true,"path":"about/index.html","permalink":"https://ttdevs.github.io/about/index.html","excerpt":"","text":"ttdevs Github: ttdevs 简书: ttdevs 图虫: ttdevs"},{"title":"categories","date":"2017-04-17T09:09:44.000Z","updated":"2017-04-17T09:15:21.000Z","comments":false,"path":"categories/index.html","permalink":"https://ttdevs.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-17T09:08:36.000Z","updated":"2017-04-17T09:09:26.000Z","comments":false,"path":"tags/index.html","permalink":"https://ttdevs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"「Android-Bluetooth」0x01操作","slug":"[Android-Bluetooth]0x02操作","date":"2017-05-20T16:00:00.000Z","updated":"2017-05-21T11:07:57.000Z","comments":true,"path":"2017/05/21/[Android-Bluetooth]0x02操作/","link":"","permalink":"https://ttdevs.github.io/2017/05/21/[Android-Bluetooth]0x02操作/","excerpt":"","text":"0x00 蓝牙（Bluetooth）这个小硬件已经是Android机器的标配了，由于平时不怎么用，因此到现在都没有去研究过。现在有一个简单的小需求：通过蓝牙连接一个串口设备读取其上面的数据，即从已配对的设备列表中选择我们的串口蓝牙设备（从），连接，然后读取数据。遂写此文。 0x01 简单使用蓝牙设备的详细使用，可以参考Android关于蓝牙的官方文档。如果你和我一样，之前没有研究过蓝牙，估计看看完后也会有一堆问题存在：什么主设备、从设备、UUID是干嘛的，如何免密钥配对等等。不着急，我们慢慢来。 上面已经说到，我们的设备已经提前配对完成（怎么配对：网络设置中中找到蓝牙，然后搜索，找到你的设备，然后配对。这个时候可能会提示输入密码，默认密码比0000，1234等）。我们只需要连接即可。下面简述操作步骤： 添加蓝牙权限 12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; 判断是否支持蓝牙 123456789101112131415private void initBluetooth() &#123; mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (null == mBluetoothAdapter) &#123; tvContent.setText(\"BluetoothAdapter is null\"); return; &#125; if (!mBluetoothAdapter.isEnabled()) &#123; tvContent.setText(\"BluetoothAdapter is disable, please open it\"); Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, REQUEST_ENABLE_BT); &#125; tvContent.setText(\"Bluetooth init success\");&#125; 首先是判断是否有蓝牙适配器，如果没有，`BluetoothAdapter.getDefaultAdapter()` 返回 `null`。然后判断蓝牙设备是否启用 `mBluetoothAdapter.isEnabled()` ，如果未启用，则发送一个 `Intent` 来让用户启用蓝牙，这个 `Intent` 是系统的，我们在 `onActivityResult` 中处理用户操作结果，如果用户顺利开启蓝牙，则会返回 `RESULT_OK`。 获取设备列表 12345678Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();if (null != pairedDevices &amp;&amp; pairedDevices.size() &gt; 0) &#123; for (BluetoothDevice device : pairedDevices) &#123; ...... String msg = String.format(\"%s %s\\n\", device.getName(), device.getAddress()); ...... &#125;&#125; 这个时候我们可以拿到 `BluetoothDevice` ，这个对象中保存了已配对蓝牙设备的信息，比如名称，MAC地址，状态，UUID等信息（但这些信息不一定都都），我们需要保存下来，在接下来连接的时候会使用。 连接设备 有了 BluetoothDevice 信息，我们就可以连接这个已经配对的蓝牙设备了。 12345678910111213 public static final UUID DEFAULT_UUID = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\"); try &#123; if(null == mSocket)&#123; mSocket = mDevice.createRfcommSocketToServiceRecord(DEFAULT_UUID); &#125; mSocket.connect(); // 阻塞的 mIn = mSocket.getInputStream();&#125; catch (IOException e) &#123; e.printStackTrace(); return false;&#125; 连接成功后，我们会得到一个 `BluetoothSocket` 对象，然后调用其阻塞的 `connect()` 方法，等待两台设备连接成功（所以这个时候必须在另外一个线程中进行）。当两台设备连接成功之后会继续向下执行。 读取数据 连接成功之后，我们可以通过 mSocket.getInputStream() 获得一个输入流，结下来的操作就是流的操作了，这个和普通 socket 中输入输出流的操作一样了。 1234567891011 try &#123; mBytes = mIn.read(readBuffer); System.arraycopy(readBuffer, 0, tempBuffer, mCount, mBytes); mCount += mBytes; if (mCount &gt;= SIZE) &#123; parseData(tempBuffer); mCount = 0; &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 0x02 总结Android蓝牙（主从）的操作： 检查是否支持，是否启用（包括是否可见等） 扫描设备 配对 连接 数据交换 等等 这里只讲了检查部分操作，涉及的扫描与配对可能是更复杂一些的，在接下来讲述。 最后，项目代码可参考这里github/ttdevs/air。 0x03 Java线程的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Created by ttdevs * 2017-01-22 (android) * https://github.com/ttdevs */public abstract class BaseWorkerThread extends Thread &#123; private boolean isRunning = true; @Override public void run() &#123; super.run(); isRunning = workerBefore(); while (isRunning) &#123; workerCycle(); &#125; workerAfter(); &#125; /** * 提前执行 true: 继续 false: 结束 * * @return */ public boolean workerBefore() &#123; return true; &#125; /** * 工作方法，被循环调用 * * @return true: 继续 false: 结束 */ public abstract void workerCycle(); /** * 结束执行 */ public void workerAfter() &#123; &#125; /** * 开始线程 */ public void startThread() &#123; isRunning = true; try &#123; start(); &#125; catch (Exception e) &#123; e.printStackTrace(); isRunning = false; &#125; &#125; /** * 结束线程 */ public void stopThread() &#123; isRunning = false; &#125;&#125; 0x04 参考 https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"https://ttdevs.github.io/tags/Bluetooth/"}]},{"title":"「Android-Bluetooth」0x02操作","slug":"[Android-Bluetooth]0x02操作.md.bak","date":"2017-05-18T16:00:00.000Z","updated":"2017-05-19T11:07:57.000Z","comments":true,"path":"2017/05/19/[Android-Bluetooth]0x02操作.md.bak/","link":"","permalink":"https://ttdevs.github.io/2017/05/19/[Android-Bluetooth]0x02操作.md.bak/","excerpt":"","text":"0x00 低功耗蓝牙（BLE）上一篇简单介绍了下传统蓝牙的使用，当你沿着上一篇的思路去连接某些蓝牙（设备）的时候，你会发现总是不成功。没错，我们还有另外一种蓝牙没有讲：低功耗蓝牙(BLE: Bluetooth Low Energy)。 这并不是一种新的东西，它只是蓝牙协议的一个新的版本。之前提到的是蓝牙2.0/2.1，这里的低功耗蓝牙BLE主要是蓝牙4.0/4.1/4.2。在我们的日常生活中这种蓝牙越来越常见，比如：各种手环，各种体脂秤，各种便携蓝牙设备等。 更多关于蓝牙的介绍可以参考这里 0x01 蓝牙协议栈和学习 TCP/IP 一样，如果了解协议栈对我们掌握蓝牙会有很大的帮助。 物理 (PHY) 层 通过蓝牙通信信道控制 2.4Ghz 射频的传输/接收。BR/EDR 提供的信道较多但带宽较窄，而 LE 使用的信道较少但带宽较宽。 链路层 定义数据包结构/信道、发现/连接程序以及发送/接收数据。 直接测试模式 允许测试人员向 PHY 层发出指令以传输或接收给定数据包序列，通过 HCI 或 2 线 UART 接口提交命令。 主机控制器接口 (HCI) 蓝牙控制器子系统（底部三层）和蓝牙主机之间的可选标准接口。 逻辑链路控制和适配协议 (L2CAP) 层 基于数据包的协议，可将数据包传输至 HCI 或直接传输到无主机系统中的链路管理器。支持更高级别的协议多路复用、数据包分割和重组，以及将服务质量信息传输到更高层。 属性协议 (ATT) 在建立连接之后定义数据交换客户端/服务器协议。使用通用属性配置文件 (GATT) 将属性分类为有意义的服务。ATT 主要用于 LE 部署，偶尔也会用于 BR/EDR 部署。 安全管理器 定义管理蓝牙设备之间配对完整性、身份验证以及加密的协议和操作，提供安全功能工具箱，其他组件可利用该工具箱支持不同应用所需的各种安全级别。 通用属性配置文件 (GATT) 使用属性协议，GATT 对封装设备组件性能的服务进行分组，并描述基于 GATT 功能的用例、角色和一般性能。其服务框架定义服务规程和格式及其特性，其中包括发现、读取、写入、通知以及指示特性以及配置特性广播。GATT 仅用于蓝牙 LE 部署。 详细了解 GATT 信息。 通用访问配置文件(GAP) 可与蓝牙 LE 部署中的 GATT 配合使用，以定义与发现蓝牙设备和共享信息相关的规程和角色，以及连接蓝牙设备的链路管理内容。 以上信息来自这里 0x02 Android系统中的BLEAndroid系统中对于低功耗蓝牙我们需要关心以下几点： Android 4.3（18）开始支持BLE Android 5.0（21）之前手机只可以作为中心设备（Central mode）使用，5.0之后可以作为外设（Peripheral mode）使用 除了以上信息，我们在对协议中的几个概念做个介绍，这涉及到之后的开发： Attribute Protocol (ATT) 属性协议，对应 BluetoothGattService Generic Attribute Profile (GATT) 通用属性配置文件，对应Android中的 BluetoothGatt Characteristic BluetoothGattCharacteristic Descriptor BluetoothGattDescriptor Service BluetoothGattService 0x03 Android系统中的BLE操作流程和之前的普通蓝牙相同，我们需要先检测设备的蓝牙是否可用，然后扫描周围的蓝牙设备，然后连接。这里可以看到，BLE的操作并不需要配对。如需要在设备必须支持低功耗蓝牙，则还需要加上这句： &lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt; 蓝牙扫描 1234567891011121314151617181920212223242526272829private boolean mScanning;private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); &#125; else &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125;&#125;// Device scan callback.private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; String format = \"Name:%s, Mac:%s, Type:%s\"; String msg = String.format(format, device.getName(), device.getAddress(), device.getType()); print(msg); &#125;&#125;; 扫描完成之后，我们会拿到蓝牙的设备信息，然后就可以进行连接了。 连接蓝牙 12345678910111213141516171819202122232425262728293031@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; if (null != intent) &#123; mMAC = intent.getStringExtra(KEY_MAC); &#125; if (TextUtils.isEmpty(mMAC)) &#123; mMAC = MAC_BIKE; &#125; mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = mBluetoothManager.getAdapter(); if (null == mBluetoothAdapter) &#123; stopSelf(); return START_NOT_STICKY; &#125; BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mMAC); if (null == device) &#123; stopSelf(); return START_NOT_STICKY; &#125; closeConnect(); mBluetoothGatt = device.connectGatt(this, false, mCallBack); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; //5.0设置的传输最大空间 mBluetoothGatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH); mBluetoothGatt.requestMtu(84); &#125; print(\"Gatt connect\"); return START_STICKY;&#125; 连接蓝牙 在连接的CallBack中如果我们检测到连接成功，才可以请求蓝牙提供的服务，这里先检测连接的状态： 123456789101112131415161718192021222324252627 private final BluetoothGattCallback mCallBack = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); print(String.format(\"status:%d, newState:%d\", status, newState)); if (status != BluetoothGatt.GATT_SUCCESS) &#123; closeConnect(); &#125; switch (newState) &#123; case BluetoothProfile.STATE_CONNECTED: print(\"连接GATT服务成功，开始发现服务...\"); gatt.discoverServices(); break; case BluetoothProfile.STATE_DISCONNECTED: print(\"断开GATT服务，Bye\"); closeConnect(); break; default: break; &#125; &#125; ...&#125;; 发现服务 12345678910111213141516171819202122232425262728293031private final BluetoothGattCallback mCallBack = new BluetoothGattCallback() &#123; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); print(\"发现服务：\" + status); if (BluetoothGatt.GATT_SUCCESS == status) &#123; List&lt;BluetoothGattService&gt; gattServices = gatt.getServices(); if (null == gattServices || gattServices.size() == 0) &#123; return; &#125; for (BluetoothGattService gattService : gattServices) &#123; String serviceUUID = gattService.getUuid().toString(); print(\"UUID GATT:\" + serviceUUID); List&lt;BluetoothGattCharacteristic&gt; characteristics = gattService.getCharacteristics(); for (BluetoothGattCharacteristic characteristic : characteristics) &#123; String uuid = characteristic.getUuid().toString(); print(\"UUID Cha:\" + uuid); print(\"UUID Status:\" + getProperties(characteristic)); if (UUID_RECEIVE.toString().equalsIgnoreCase(uuid)) &#123; mBluetoothGatt.setCharacteristicNotification(characteristic, true); print(\"开始监听：\" + uuid); &#125; &#125; &#125; &#125; &#125; ...&#125; 使用服务 … 0x04 还需要了解的一些细节 UUID 判断服务的属性 0x05 可能会遇到的坑手上的两台魅族设备，连接一个客户提供的蓝牙模块，死活连不上，其他手机连接正常。这两部设备连接淘宝上买的一个蓝牙模块正常。 0xFF 参考 https://developer.android.com/guide/topics/connectivity/bluetooth-le.html https://www.bluetooth.com/zh-cn/specifications/bluetooth-core-specification https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99#.E8.97.8D.E7.89.994.0 https://race604.com/android-ble-in-action/ http://blog.csdn.net/qinxiandiqi/article/details/40741269 http://www.jianshu.com/p/8690dbafe849 https://www.bluetooth.com/zh-cn/specifications/adopted-specifications https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=286439","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"https://ttdevs.github.io/tags/Bluetooth/"}]},{"title":"「Flask」0x03树莓派上使用Nginx和uWSGI部署Flask应用","slug":"[Flask]0x03树莓派上使用Nginx和uWSGI部署Flask应用","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Flask]0x03树莓派上使用Nginx和uWSGI部署Flask应用/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Flask]0x03树莓派上使用Nginx和uWSGI部署Flask应用/","excerpt":"","text":"0x00 部署：uWSGI 和 Nginx 介绍Deploy Flask Application with Nginx and uWSGI 考虑到部署的问题，相信您已经完成了自己Flask应用的开发工作，或者跟我一样，一个demo 应用已经完成。好奇自己的应用如何发布出去。接下来，通过介绍一些常用的工具来完成我们应用的部署。先简单介绍下我的环境： 一台内网中的树莓派 一个花生棒(98RMB买的硬件) 使用花生棒做了内网的端口映射，对外暴露80端口提供http服务，至于为什么这么做，请参考这里。 好了，接下来进入正题。 uWSGI作为Web服务器使用，nginx做反向代理。 uWSGIuWSGI做Web服务器 《Flask Web开发：基于Python的Web应用开发实战》有下面两段描述： 其一： Flask自带的开发Web服务器不够强健、安全和高效，无法在生产环境中使用。 其二： Flask自带的开发Web服务器表现很差，因为它不是为生产环境设计的服务器。有两个可以在生产环境中使用、性能良好且支持Flask程序的服务器，分别是Gunicorn(http://gunicorn.org/) 和 uWSGI(http://uwsgi-docs.readthedocs.org/en/latest/) 。 先介绍一下WSGI（from：维基百科）： Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。以前，如何选择合适的Web应用程序框架成为困扰Python初学者的一个问题，这是因为，一般而言，Web应用框架的选择将限制可用的Web服务器的选择，反之亦然。那时的Python应用程序通常是为CGI，FastCGI，mod_python中的一个而设计，甚至是为特定Web服务器的自定义的API接口而设计的。WSGI[1] （有时发音作’wiz-gee’）是作为Web服务器与Web应用程序或应用框架之间的一种低级别的接口，以提升可移植Web应用开发的共同点。WSGI是基于现存的CGI标准而设计的。 因此我们需要为我们的Flask应用配置一个 Web服务器 。《Flask Web开发》中介绍的部署到Heroku选择的是Gunicorn。Gunicorn 和 uWSGI 的比较网上很多，主要的问题可能就是谁的坑多坑少。经过比对，这里我选择uWSGI。 uWSGI 不仅仅是一个协议，同时也是一个应用服务器，可以服务于uWSGI、FastCGI和HTTP协议。uWSGI官方文档可参考这里 。 支持WSGI的Web应用框架很多，比如： Django Flask web.py web2py Werkzeug Tornado and so on Nginxnginx做反向代理 Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。 Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（&lt;=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。 在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。 Nginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中，是可以支持二万至四万个平行链接。 以上来信息自维基百科。 反向代理： 使用代理服务器可以将请求转发给内部的Web服务器，使用这种加速模式显然可以提升静态网页的访问速度。因此也可以考虑使用这种技术，让代理服务器将请求 均匀转发给多台内部Web服务器之一上，从而达到负载均衡的目的。这种代理方式与普通的代理方式有所不同，标准代理方式是客户使用代理访问多个外部Web 服务器，而这种代理方式是多个客户使用它访问内部Web服务器，因此也被称为反向代理模式。 参考：http://www.bing.com/knows/反向代理负载均衡 虽然你可能不知道Nginx是做什么的，但是你应该听过，再或者你至少听过Apache，他们都是HTTP服务器。恕我能力有限，目前为止并不能很好的解释为什么非得用Nginx，能告诉大家的是：Nginx帮我们处理很多静态资源，同时将动态请求转发给不同的Web服务器（负载均衡）。此处留坑，等以后补上。 接下来通过最简单的配置，将我们的Flask应用部署到我们的树莓派上，达到对部署的流程有个总体把握的目的。如果你需要更多的配置，可以参考各自部分的官方文档。 0x01 uWSGI 安装 先从安装说起：pip install uwsgi 配置 在我们项目的根目录下，创建 uwsgi.ini 文件， 内容如下： 12345678910[uwsgi]socket = 127.0.0.1:5000processes = 4threads = 2plugins = python3master = truevenv = venvpythonpath = .module = managecallable = application 配置参数说明： socket：应用程序所在地址，IP加端口号，当然，也可以有其他的形式 processes：开启的进程数量 threads：每个进程的线程数 plugins：加载的插件 module：加载指定的python WSGI模块 callable：在收到请求时，uWSGI加载的模块中哪个变量将被调用，默认是名字为“application”的变量。 顺便贴一下我的Flask项目文件：manage.py 123456789#!/usr/bin/env python3# coding:utf-8from flask.ext.script import Managerconfig = 'development'application = create_app(config)manager = Manager(application)...if __name__ == '__main__': manager.run() 操作 启动：uwsgi uwsig.ini。如果启动成功，会看到类似下面的log： 123456789101112131415161718192021222324252627282930313233343536(venv)pi@raspberrypi:~/raspi $ uwsgi uwsgi.ini[uWSGI] getting INI configuration from uwsgi.iniopen(&quot;./python3_plugin.so&quot;): No such file or directory [core/utils.c line 3684]!!! UNABLE to load uWSGI plugin: ./python3_plugin.so: cannot open shared object file: No such file or directory !!!*** Starting uWSGI 2.0.13.1 (32bit) on [Sun Jul 3 22:35:08 2016] ***compiled with version: 4.9.2 on 27 May 2016 15:15:57os: Linux-4.1.19-v7+ #858 树莓派 Tue Mar 15 15:56:00 GMT 2016nodename: raspberrypimachine: armv7lclock source: unixdetected number of CPU cores: 4current working directory: /home/pi/raspidetected binary path: /home/pi/raspi/venv/bin/uwsgi!!! no internal routing support, rebuild with pcre support !!!your processes number limit is 6831your memory page size is 4096 bytesdetected max file descriptor number: 65536lock engine: pthread robust mutexesthunder lock: disabled (you can enable it with --thunder-lock)uwsgi socket 0 bound to TCP address 127.0.0.1:5000 fd 3Python version: 3.4.2 (default, Oct 19 2014, 14:03:53) [GCC 4.9.1]Set PythonHome to venvPython main interpreter initialized at 0xbaf828python threads support enabledyour server socket listen backlog is limited to 100 connectionsyour mercy for graceful operations on workers is 60 secondsmapped 358400 bytes (350 KB) for 8 cores*** Operational MODE: preforking+threaded ***added ./ to pythonpath.WSGI app 0 (mountpoint=&apos;&apos;) ready in 5 seconds on interpreter 0xbaf828 pid: 3418 (default app)*** uWSGI is running in multiple interpreter mode ***spawned uWSGI master process (pid: 3418)spawned uWSGI worker 1 (pid: 3428, cores: 2)spawned uWSGI worker 2 (pid: 3429, cores: 2)spawned uWSGI worker 3 (pid: 3431, cores: 2)spawned uWSGI worker 4 (pid: 3432, cores: 2) - 停止 - 如果还在同一个shell中，我们可以直接按 `Ctrl + C` - 如果不在同一个shell中，可以这样结束掉 `killall -9 uwsgi` 启动成功之后就可以访问我们的Web应用了，默认地址是：http://127.0.0.1:5000 （这个地址和端口号是在我们的Flask应用中配配置的，这里不做介绍）。如果出现 `invalid request block size: 21573 (max 4096)...skip`这个错误，请将配置中的 `socket` 改为 `http`，具体可以参考[这里](http://stackoverflow.com/questions/15878176/uwsgi-invalid-request-block-size)。 0x02 Nginx 安装 sudo apt-get install ngnix 操作 启动 sudo /etc/init.d/nginx start sudo service nginx start 停止 sudo /etc/init.d/nginx stop sudo service nginx stop 重启 sudo /etc/init.d/nginx restart sudo service nginx restart 如果没问题，这个时候我们就可以打开浏览器访问：127.0.0.1，应该会看到一个静态页面。 配置 nginx 的配置文件时位于 /etc/nginx/sites-available 目录下的 default 文件，我们复制一份做修改，这里同样给一份最简单的配置： 12345678910111213server &#123; listen 80; server_name ttdevs.vicp.net; # access_log logs/access.log compression; #默认请求 location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:5000; &#125;&#125; 配置好这些之后重启我们的nginx服务：`sudo service nginx restart`。即可访问我们的web应用了。 0x03 总结如果中间没有出错，你的Flask应用已经部署成功。到此，我们来梳理下这个流程。首先，我们安装Nginx，他直接处理用户发送的HTTP请求（HTTP服务器），并将请求按照我们的配置（nginx中的配置）交给uWSGI服务器（Web服务器），最后uWSGI将请求交给我们的Flask应用，由Flask应用进行逻辑处理，处理完之后再将结果返回给用户。这些，就是我对这个流程的理解，相信中间肯定有错误或者不到位的地方，在对这些知识有更进一步理解的时候我会返回及时更新。同时也欢迎各位指正～～ 0xFF 参考 http://docs.jinkan.org/docs/flask/deploying/uwsgi.html http://www.cnblogs.com/zhouej/archive/2012/03/25/2379646.html http://www.cnblogs.com/Ray-liang/p/4173923.html https://github.com/nginx/nginx/blob/master/conf/uwsgi_params http://docs.jinkan.org/docs/flask/deploying/wsgi-standalone.html#deploying-proxy-setups","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://ttdevs.github.io/tags/Flask/"}]},{"title":"「Android-SQLite」0x01创建自己的数据库","slug":"[Android-SQLite]0x01创建自己的数据库","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android-SQLite]0x01创建自己的数据库/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android-SQLite]0x01创建自己的数据库/","excerpt":"","text":"0x01 创建自己的数据库大多数情况，我们还是需要自己去维护一个数据库，常见的包括数据库的创建，升级，销毁等操作。 android提供了SQLiteOpenHelper抽象类，我们创建SQLiteOpenHelper的实现类，重写他的onCreate(), onUpgrade() 或者 onOpen()方法，对数据库进行管理。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class DataBaseOpenHelper extends SQLiteOpenHelper &#123; private static final String DATABASE_NAME = \"ChinaCity.db\"; private static final int DATABASE_VERSION = 1; // Version must be &gt;= 1 public DataBaseOpenHelper(Context context) &#123; super(context, DATABASE_NAME, null, DATABASE_VERSION); System.out.println(\"DataBaseOpenHelper\"); &#125; public DataBaseOpenHelper(Context context, int version) &#123; super(context, DATABASE_NAME, null, version); System.out.println(\"DataBaseOpenHelper version\"); &#125; @Override public void onOpen(SQLiteDatabase db) &#123; if (!db.isReadOnly()) &#123; db.execSQL(\"PRAGMA foreign_keys = ON;\"); // Enable foreign key constraints &#125; // create table test(id integer references students(id),score integer check (score&lt;=100 and score&lt;=0),primary key(id,score)) super.onOpen(db); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; CityData.createTable(db); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; CityData.dropTable(db); CityData.createTable(db); &#125; public static class CityData implements BaseColumns &#123; public static final String TYPE_TEXT = \" text \"; public static final String TYPE_INTEGER = \" integer \"; public static final String COMMA_SEP = \",\"; // *******************************china_city_code*********************************** public static final String TABLE_NAME_CITY = \"china_city_code\"; public static final String COLUMN_NAME_PROVINCE = \"province\"; public static final String COLUMN_NAME_CITY = \"city\"; public static final String COLUMN_NAME_COUNTY = \"county\"; public static final String COLUMN_NAME_CODE = \"code\"; public static final String SQL_CREATE_CITY = \"CREATE TABLE IF NOT EXISTS \" + TABLE_NAME_CITY + \" (\" + _ID + TYPE_INTEGER + \" PRIMARY KEY AUTOINCREMENT, \" + COLUMN_NAME_PROVINCE + TYPE_TEXT + COMMA_SEP + COLUMN_NAME_CITY + TYPE_TEXT + COMMA_SEP + COLUMN_NAME_COUNTY + TYPE_TEXT + COMMA_SEP + COLUMN_NAME_CODE + TYPE_INTEGER + \" )\"; public static final String SQL_CREATE_CITY_INDEX = \"CREATE UNIQUE INDEX IF NOT EXISTS \" + COLUMN_NAME_CODE + \" ON \" + TABLE_NAME_CITY + \"(\" + COLUMN_NAME_CODE + \")\"; public static final String SQL_DELETE_CITY = \"DROP TABLE IF EXISTS \" + TABLE_NAME_CITY; // *******************************china_provinces_code******************************* public static final String TABLE_NAME_PROVINCE = \"china_provinces_code\"; public static final String COLUMN_NAME_ID = \"id\"; public static final String COLUMN_NAME_NAME = \"name\"; public static final String SQL_CREATE_PROVINCE = \"CREATE TABLE IF NOT EXISTS \" + TABLE_NAME_PROVINCE + \" (\" + _ID + TYPE_INTEGER + \" PRIMARY KEY AUTOINCREMENT, \" + COLUMN_NAME_ID + TYPE_INTEGER + COMMA_SEP + COLUMN_NAME_NAME + TYPE_TEXT + \" )\"; public static final String SQL_DELETE_PROVINCE = \"DROP TABLE IF EXISTS \" + TABLE_NAME_PROVINCE; public static void createTable(SQLiteDatabase db) &#123; db.execSQL(SQL_CREATE_PROVINCE); db.execSQL(SQL_CREATE_CITY); db.execSQL(SQL_CREATE_CITY_INDEX); &#125; public static void dropTable(SQLiteDatabase db) &#123; db.execSQL(SQL_DELETE_PROVINCE); db.execSQL(SQL_DELETE_CITY); &#125; &#125;&#125; 构造函数中我们需要传入四个参数，第一个参数为上下文，第二个为数据库名称，第三个参数一般为null，第四个为数据库的版本。onCreate()方法中主要执行数据库的创建操作。onUpgrade()方法主要在数据库升级时调用，源码 android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(boolean writable) 中这样描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private SQLiteDatabase getDatabaseLocked(boolean writable) &#123; if (mDatabase != null) &#123; if (!mDatabase.isOpen()) &#123; // Darn! The user closed the database by calling mDatabase.close(). mDatabase = null; &#125; else if (!writable || !mDatabase.isReadOnly()) &#123; // The database is already open for business. return mDatabase; &#125; &#125; if (mIsInitializing) &#123; throw new IllegalStateException(\"getDatabase called recursively\"); &#125; SQLiteDatabase db = mDatabase; try &#123; mIsInitializing = true; if (db != null) &#123; if (writable &amp;&amp; db.isReadOnly()) &#123; db.reopenReadWrite(); &#125; &#125; else if (mName == null) &#123; db = SQLiteDatabase.create(null); &#125; else &#123; try &#123; if (DEBUG_STRICT_READONLY &amp;&amp; !writable) &#123; final String path = mContext.getDatabasePath(mName).getPath(); db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY, mErrorHandler); &#125; else &#123; db = mContext.openOrCreateDatabase(mName, mEnableWriteAheadLogging ? Context.MODE_ENABLE_WRITE_AHEAD_LOGGING : 0, mFactory, mErrorHandler); &#125; &#125; catch (SQLiteException ex) &#123; if (writable) &#123; throw ex; &#125; Log.e(TAG, \"Couldn't open \" + mName + \" for writing (will try read-only):\", ex); final String path = mContext.getDatabasePath(mName).getPath(); db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY, mErrorHandler); &#125; &#125; onConfigure(db); final int version = db.getVersion(); if (version != mNewVersion) &#123; if (db.isReadOnly()) &#123; throw new SQLiteException(\"Can't upgrade read-only database from version \" + db.getVersion() + \" to \" + mNewVersion + \": \" + mName); &#125; db.beginTransaction(); try &#123; if (version == 0) &#123; onCreate(db); &#125; else &#123; if (version &gt; mNewVersion) &#123; onDowngrade(db, version, mNewVersion); &#125; else &#123; onUpgrade(db, version, mNewVersion); &#125; &#125; db.setVersion(mNewVersion); db.setTransactionSuccessful(); &#125; finally &#123; db.endTransaction(); &#125; &#125; onOpen(db); if (db.isReadOnly()) &#123; Log.w(TAG, \"Opened \" + mName + \" in read-only mode\"); &#125; mDatabase = db; return db; &#125; finally &#123; mIsInitializing = false; if (db != null &amp;&amp; db != mDatabase) &#123; db.close(); &#125; &#125;&#125; 当当前版本小于新版本时，会调用onUpgrade()方法。所以上面SQLiteOpenHelper的实现思路为：构造方法中初始化一下数据库的必要参数，如数据库版本，数据库名等；在onCreate()方法中创建数据库的表；当我们需要对数据库进行升级的时候，修改数据库的版本号，这样就可以触发onUpgrade()方法，这里我们做最简单的处理：drop掉所有表然后重新创建。当然我们还可以在onOpen()方法中做一下数据库的设置操作，如设置外键生效。这样我们的数据库管理类就实现了。 0x02 拿到数据库对象有了数据库管理类，对数据库进行操作我们最好封装一个操作类，在这个类中对数据库中的表进行操作。下面的代码也是网上比较常见的（对于数据库对象，也有处理成单例）。先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DataBaseManager &#123; private DataBaseOpenHelper dbHelper; private SQLiteDatabase db; public DataBaseManager(Context context) throws SQLException &#123; this.dbHelper = new DataBaseOpenHelper(context); this.db = dbHelper.getWritableDatabase(); &#125; public CopyOfDataBaseManager(Context context, int version) throws SQLException &#123; this.dbHelper = new DataBaseOpenHelper(context, version); this.db = dbHelper.getWritableDatabase(); &#125; public void closeDataBase() &#123; if (db != null &amp;&amp; db.isOpen()) &#123; db.close(); &#125; &#125; public boolean isInitData(String tableName) &#123; int count = 0; String sql = \"select count(*) from \" + tableName; Cursor cursor = db.rawQuery(sql, null); if (cursor.moveToFirst()) &#123; count = cursor.getInt(0); &#125; return count &gt; 0; &#125; public void clearTable(String tableName) &#123; String sql = \"delete from \" + tableName + \";\"; sql += \"update sqlite_sequence set seq = 0 where name = \" + tableName + \";\"; db.execSQL(sql); &#125; public void insertProvinceData(int id, String name) &#123; String sql = \"insert into \" + CityData.TABLE_NAME_PROVINCE + \" (\" + CityData.COLUMN_NAME_ID + \",\" + CityData.COLUMN_NAME_NAME + \") VALUES(\" + id + \",'\" + name + \"');\"; db.execSQL(sql); System.out.println(sql); &#125; // TODO其他一下对表进行的操作&#125; 首先我们创建一个DataBaseOpenHelper的实例，然后通过它拿到SQLiteDatabase对象，这样我们就可以对数据库进行操作了。DataBaseOpenHelper有两种get方法：getWritableDatabase() 和 getReadableDatabase()，大家都应该知道着两种方法的含义，getReadableDatabase() 拿到的数据库对象不可以进行插入修改等写操作。在这两种方法的说明在我们可能需要注意几点： 当我们没有申请数据库操作的权限或者磁盘已满，会报错 数据库的更新可能需要很长时间，因此我们不能在主线程中调用 当我们不再对数据库进行操作时，别忘记关闭数据库 接下来就是数据库的常用操作了","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"},{"name":"SQLite","slug":"SQLite","permalink":"https://ttdevs.github.io/tags/SQLite/"}]},{"title":"「Android-SQLite」0x02从加载本地数据库开始","slug":"[Android-SQLite]0x02从加载本地数据库开始","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android-SQLite]0x02从加载本地数据库开始/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android-SQLite]0x02从加载本地数据库开始/","excerpt":"","text":"0x00 引言 好久以前就写了，但是一直拖拖拉拉的，在草稿箱里放了两个星期还没写完，想想这样托下去又要废掉了，还是分开来吧，写多少是多少。 Android的SQLite数据库简单使用一段时间了，现在想抽些时间总结下，不然总感觉很乱。 0x01 SQLiteExpert先说一个工具，SQLite Expert，一款SQLite数据库管理工具，下载地址： http://www.sqliteexpert.com/，Personal Edition是免费的，日常使用基本足够，需要专业版的可以自行网上找寻。当然，其他免费的工具还有很多，如：SQLite Database Browser、 SQLiteManager 等。 0x02 加载本地数据库假设我们SDCard的根目录上已经存在一个数据库，名称为：ChinaCity.db。这时候我们可以这样操作： 1234567891011121314151617181920212223public void readDataBaseFromSDCard() &#123; String dbPath = Environment.getExternalStorageDirectory() + \"/ChinaCity.db\"; File dbFile = new File(dbPath); if (!dbFile.exists()) &#123; Toast.makeText(getApplicationContext(), \"请先点击拷贝到SDCard\", Toast.LENGTH_LONG).show(); return; &#125; openOrCreateDatabase(dbPath, SQLiteDatabase.CREATE_IF_NECESSARY, null); SQLiteDatabase db = SQLiteDatabase.openDatabase(dbPath, null, SQLiteDatabase.OPEN_READWRITE); // db = openOrCreateDatabase(dbPath, SQLiteDatabase.OPEN_READWRITE, null); StringBuffer sb = new StringBuffer(); Cursor cursor = db.rawQuery(\"select * from china_provinces_code\", null); while (cursor.moveToNext()) &#123; int id = cursor.getInt(cursor.getColumnIndex(\"_id\")); String name = cursor.getString(cursor.getColumnIndex(\"name\")); sb.append(id + \":\" + name + \" \\n\"); &#125; System.out.println(sb.toString());&#125; 先用SQLiteDatabase的一个静态方法openDatabase打开一个数据库，第一个参数为数据库文件路径，第二个参数一般为null，第三个参数为打开数据库的方式，由于只需要读取数据，所以我们选择 SQLiteDatabase.OPEN_READONLY，此种方式的好处是数据库存在的话就不会出错；另外一种为 SQLiteDatabase.OPEN_READWRITE，以读写的方式打开。执行上面代码，我们会看与上图信息相同的： 开发的时候，我们可能会需要一些初始化数据，比如城市代码信息，这样我们就可以事先创建好一个数据库，写入初始数据，将其放入自己的apk中一起分发。这个时候我们就可以直接从资源文件中读取这个数据库文件写入到应用的数据库目录或者SDCard中，然后就可以对其操作，拷贝可以这样操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 拷贝资源中数据库 * * @param where 1SDCARD,2LOCAL */public void copyDataBase(int where) &#123; // 每个应用都有一个数据库目录，他位于 /data/data/packagename/databases/目录下 String packageName = \"com.ttdevs.citydata\"; // xml中配置的 String dbName = \"ChinaCity.db\"; String dbPath = null; if (where == 1) &#123; // sdcard dbPath = Environment.getExternalStorageDirectory() + File.separator + dbName; &#125; else &#123; // local, TODO Environment.getDataDirectory() dbPath = \"/data/data/\" + packageName + \"/databases/\" + dbName; &#125; if (where == 2) &#123; new File(\"/data/data/\" + packageName + \"/databases/\").mkdirs(); &#125; if (where == 1 &amp;&amp; !Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123; return; // 未挂载外部存储，拷贝到内部不用判断 &#125; File dbFile = new File(dbPath); if (dbFile.exists()) &#123; dbFile.delete(); &#125; try &#123; dbFile.createNewFile(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); return; &#125; try &#123; InputStream is = getResources().getAssets().open(dbName); OutputStream os = new FileOutputStream(dbPath); byte[] buffer = new byte[1024]; int length = 0; while ((length = is.read(buffer)) &gt; 0) &#123; os.write(buffer, 0, length); &#125; os.flush(); os.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Toast.makeText(getApplicationContext(), \"拷贝成功\", Toast.LENGTH_LONG).show();&#125; 代码不是很严谨，凑活着看哈。经过以上步骤，我们就可以开始使用数据库，数据库的常用操作，在接下来的介绍中继续。 0x03 下载ChinaCity.db数据库： 下载","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"},{"name":"SQLite","slug":"SQLite","permalink":"https://ttdevs.github.io/tags/SQLite/"}]},{"title":"「Android」0x02本地数据安全尝试Conceal","slug":"[Android]0x02本地数据安全尝试Conceal","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]0x02本地数据安全尝试Conceal/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]0x02本地数据安全尝试Conceal/","excerpt":"","text":"0x00上一篇我们提到使用SQLCipher对本地的数据进行加密。在保证数据安全的同时，我们又引入了一些新的问题，比如安装包体积的增加，数据存储过程中耗时增加，数据加密的粒度不可控等等。如果你接受不了这些问题，那我们还需寻找其他的加密方法。这里给大家推荐Conceal 0x01Conceal是Facebook的一个开源项目，它可以高效的对大文件进行加密（当然对小数据加密也不是问题），同时对设备的性能和系统版本要求比较低。更具体的信息可参考这里。 Conceal doesn’t implement any crypto, but instead, it uses specific cryptographics algorithms from OpenSSL. Conceal attempts to manage memory efficiently between the native and Java heap. Conceal also uses fast modes like AES-GCM and HMAC-SHA1 by default.OpenSSL is a very large library, and would increase the size of apps. Conceal ships with only a select number of encryption algorithms from OpenSSL which make it much smaller (85KB). 0x02引用compile &#39;com.facebook.conceal:conceal:1.0.1@aar&#39; 关键代码我们可以用其加密常见的数据类型，比如字符串，图片等。 字符串 1234// 加密byte[] cipherText = mCrypto.encrypt(plainText, mEntity);// 解密byte[] plainText = mCrypto.decrypt(cipherText, mEntity); 大文件 123456OutputStream out = mCrypto.getCipherOutputStream(fileOS, mEntity);int read = 0;byte[] buffer = new byte[1024];while ((read = sourceFile.read(buffer)) != -1) &#123; out.write(buffer, 0, read);&#125; 初始化 12345678public static final String ENTITY = \"ttdevs\";public static void init(Context context) &#123; if (null == mCrypto) &#123; mCrypto = new Crypto(new SharedPrefsBackedKeyChain(context), new SystemNativeCryptoLibrary()); mEntity = new Entity(ENTITY); &#125;&#125; 以上三部分是我们使用Conceal的关键代码。首先，我们需要构造一个Crypto对象，这个对象需要传入两个参数，第一个是KeyChain，第二个是NativeCryptoLibrary。NativeCryptoLibrary我们使用系统默认的。KeyChain顾名思义，就是我们的加密key。例子中我们使用了SharedPrefsBackedKeyChain，通过查看源码，我们发现，它是将加密的key保存到SharedPreferences中的一个KeyChain的实现。 测试接下来我们来看看Conceal的表现如何。我写了一个简单的测试代码，由于比较长，就不贴了，具体可以参考这里，主要有三个部分： 测试字符串加解密 测试加密数据的数据库读写 测试本地文件加解密 界面如下： 字符串加解密 字符串的读写如上图，加解密字符串Hello world!耗时都在3ms左右，这个时间应该是我们可以接受的。 PS:强势插入一个2B问题 细心的你可能会想如果我们不用数据库，只是加密几个简单的数据，能不能将密文直接写入SharedPreferences中呢？告诉你我也是这么想的，而且去测试了，但是死活不成功，不成功，不成功……我的思路是这样的：由于加密、加密结果、解密 三个操作参数都是byte，而SharedPreferences接受的参数是String类型，因此我们需要进行转换，new String(bytes, &quot;utf-8&quot;) 和 string.getBytes(&quot;utf-8&quot;) ， 当你这么做的时候，你会发现解密死活不成功。经历过无数个不眠之夜后，终于恍然大悟，原来这么转换是错误的！原因很简单，一个utf-8编码汉字是2bytes，如果我们的加密结果不足2byte，我们强转时不足部分就会被补齐，当再转换回来的时候就和原来的不一一样了。最后怎么解决呢？也很简单，用Base64对byte数组进行编码，具体怎么做可以参考Conceal源码中的SharedPrefsBackedKeyChain。 数据库读写 这个时间就不做过多解读，数据库操作时间加加解密时间。 1234561456500607857: Begin transaction 1456500607861: Insert: Hello world! 1456500607865: Read: name:Hello world! token:Hello world! 1456500607868: Read: name:Hello world! token:Hello world! 1456500607871: Read: name:Hello world! token:Hello world! 1456500607885: End transaction 文件加解密 这个比较重要，如果我们有大文件加密的需求（比如前段时间微信的红包图片），对性能和效率要求就比较高了。 某一次加密数据： 12345678Encrpyt 1.png 1014KB 163msEncrpyt 2.jpg 2078KB 336msEncrpyt 3.jpg 3043KB 477msEncrpyt 4.JPG 3811KB 560msEncrpyt 5.JPG 4772KB 699msEncrpyt 10.apk 10268KB 1281msEncrpyt 10.gif 10421KB 671msEncrpyt 21.apk 20962KB 1323ms 某一次解密数据： 12345678Decrpyt encrypt_1.png 1014KB 108msDecrpyt encrypt_2.jpg 2078KB 177msDecrpyt encrypt_3.jpg 3043KB 221msDecrpyt encrypt_4.JPG 3811KB 270msDecrpyt encrypt_5.JPG 4772KB 340msDecrpyt encrypt_10.apk 10268KB 732msDecrpyt encrypt_10.gif 10421KB 764msDecrpyt encrypt_21.apk 20962KB 1468ms 从上面的数据我们可以看到，加密多张大图并没有导致内存的增加，只是CPU使用率有所变化。加密1MB图片耗时160ms，加密20MB文件耗时1300ms多。解密数据的性能消耗类似。 0x03分析了解了Conceal的基本情况，我们来对比下上面提到的使用SQLCipher遇到的问题。首先，Conceal只有85KB，这个大小是我们完全可以接受的，然后就是加密粒度，无论是数据库还是文件，我们都可以只真对需要的那部分加密，最后即使你选择将文件存入数据库，它的时间也只有正常数据库操作时间加Conceal的加解密时间。综上所述，Conceal应该是一个不错的选择。 总结我们再来想想这两篇文章中提到的加密方法：无论你选择哪一种，由于他们都采用了对称加密算法，虽然数据部分加密了，但是我们却需要维护一个秘钥，这个秘钥放在那里？SharedPreferences？数据库？本地文件？貌似进入了一个死循环，问题又回到了起点。分析了这么多，如果没有办法解决秘钥的问题，也都是白搭。怎么办？下一篇在进一步分析。敬请期待。 PS: 所有测试机器 魅族 MX4PRO 性能均衡模式","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」0x01本地数据安全尝试SQLCipher","slug":"[Android]0x01本地数据安全尝试SQLCipher","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]0x01本地数据安全尝试SQLCipher/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]0x01本地数据安全尝试SQLCipher/","excerpt":"","text":"0x00先纪念下，从今天开始，又开始写博客啦啦啦啦。话说基本上一年多没好好写博客了。回想起来，和之前写博客时相比，还是差距好大。好吧，废话不说了，进入正题。 首先，开篇打算跟大家分享下你遇到的或者将来可能遇到的问题：本地数据的安全问题。多数情况，我们可能没有去考虑app的本地数据安全问题，一来公司没这样的要求，二来我们可能也没有非常需要保密的数据。那现在思考一下为将来做储备。 面试的时候，可能常常会被问到这样一个问题：Android的数据存储有哪几种方式？ 对于这个问题，Android的官方文档 有回答： Shared Preferences Internal Storage External Storage SQLite Databases Network Connection 这几种方式就不用多说了。第一种以key-value的方式存储在我们的设备内部；第二种第三种简单理解为文件存储；第四种本地数据库存储（这四种都属本地存储）。最后一种方式（暂且算是一种方式吧）不在我们考虑范围之内。现在假设一个最坏的环境：设备已经root，任何本地数据都可以被直接或者间接拿到。这时候我们自然想到的就是对我们的数据进行加密。 0x01以上是开场，下面进入第一部分：本地数据库加密。先回顾下本地数据库，root以后，我们可以在下面的位置找到它：/data/data/you.package/databases，例如我们demo的数据库： 1234567891011121314151617root@t03g:/data/data/com.ttdevs.demo/databases # lsnormal_user.dbnormal_user.db-journaluser.dbroot@t03g:/data/data/com.ttdevs.demo/databases #``` 知道了它的位置，接下来我们就可以直接将这些数据库文件拷贝出来，然后使用SQLite浏览器浏览。我们选用网上一个开源的方案：[SQLCipher][2]（[GitHub地址][3]）。SQLCipher是在SQLite的基础上封装了加密功能，使用上和直接使用SQLite基本相同。## 0x02首先，按照说明，我们引入SQLCipher：``` gradlecompile &apos;net.zetetic:android-database-sqlcipher:3.3.1-2@aar&apos; 接下来就是编写我们的数据库代码了。先创建一个DatabaseHelper： 123456789101112131415161718192021222324252627282930313233343536import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteOpenHelper;public class DatabaseOpenHelper extends SQLiteOpenHelper &#123; private static final String DATABASE_NAME = \"user.db\"; private static final int DATABASE_VERSION = 1; public static final String TABLE = \"user_info\"; public static final String NAME = \"name\"; public static final String AGE = \"age\"; public static final String ICON = \"icon\"; public static final String TOKEN = \"token\"; public DatabaseOpenHelper(Context context) &#123; super(context, DATABASE_NAME, null, DATABASE_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; String sql = \"create table \" + TABLE + \" (_id integer primary key autoincrement, \" + NAME + \" text, \" + AGE + \" integer, \" + ICON + \" blob, \" + TOKEN + \" text not null);\"; Log.d(\"EventsData\", \"onCreate: \" + sql); db.execSQL(sql); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; if (oldVersion &lt; newVersion) &#123; // TODO &#125; &#125;&#125; 注意，此处的SQLiteOpenHelper和SQLiteDatabase都来自net.sqlcipher.database包。 为了便于对比，我又写了一个相同逻辑使用android.database.sqlite.SQLiteOpenHelper的Helper作对比。接下来使用编写数据库操作逻辑。使用中SQLiteCipher区别是打开数据库的时候需要传入用于加密的KEY。下面是测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SqlcipherActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"&gt;&gt;&gt;&gt;&gt;\"; private static final String CIPHER_KEY = \"123abc_!@#$%^&amp;*\"; private DatabaseOpenHelper mOpenHelper; private NormalDatabaseOpenHelper mNormalHelper;... private void writeData(boolean isCipher) &#123; if (isCipher) &#123; log(\"Cipher:101:\" + System.currentTimeMillis()); SQLiteDatabase db = mOpenHelper.getWritableDatabase(PASSWORD_KEY); log(\"Cipher:102:\" + System.currentTimeMillis()); String name = \"Cipher\" + (++mIndex); ContentValues values = new ContentValues(); values.put(DatabaseOpenHelper.NAME, name); values.put(DatabaseOpenHelper.AGE, mIndex); values.put(DatabaseOpenHelper.TOKEN, PASSWORD_KEY); values.put(DatabaseOpenHelper.ICON, name.getBytes()); log(\"Cipher:11:\" + System.currentTimeMillis()); try &#123; db.beginTransaction(); db.insert(DatabaseOpenHelper.TABLE, null, values); db.setTransactionSuccessful(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; db.endTransaction(); &#125; log(\"Cipher:12:\" + System.currentTimeMillis()); db.close(); &#125; else &#123; ... &#125; &#125; private void readData(boolean isCipher) &#123; if (isCipher) &#123; SQLiteDatabase db = mOpenHelper.getReadableDatabase(PASSWORD_KEY); Cursor cursor = db.query(DatabaseOpenHelper.TABLE, null, null, null, null, null, null); while (cursor.moveToNext()) &#123; String name = cursor.getString(cursor.getColumnIndex(DatabaseOpenHelper.NAME)); int age = cursor.getInt(cursor.getColumnIndex(DatabaseOpenHelper.AGE)); String token = cursor.getString(cursor.getColumnIndex(DatabaseOpenHelper.TOKEN)); String result = String.format(\"Cipher&gt;&gt;&gt;&gt; name:%s, age:%d, token:%s\", name, age, token); log(result); &#125; db.close(); &#125; else &#123; android.database.sqlite.SQLiteDatabase ndb = mNormalHelper.getReadableDatabase(); android.database.Cursor cursor = ndb.query(NormalDatabaseOpenHelper.TABLE, null, null, null, null, null, null); while (cursor.moveToNext()) &#123; String name = cursor.getString(cursor.getColumnIndex(DatabaseOpenHelper.NAME)); int age = cursor.getInt(cursor.getColumnIndex(DatabaseOpenHelper.AGE)); String token = cursor.getString(cursor.getColumnIndex(DatabaseOpenHelper.TOKEN)); String result = String.format(\"Normal&gt;&gt;&gt;&gt; name:%s, age:%d, token:%s\", name, age, token); log(result); &#125; ndb.close(); &#125; &#125; ...&#125; 好了，跑一下我们的测试代码，得到下面的结果： 1234567891011121302-19 13:49:41.596 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: &gt;&gt;&gt;&gt;&gt; Cipher &gt;&gt;&gt;&gt;&gt;02-19 13:49:41.596 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Cipher:101:145586098159702-19 13:49:41.971 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Cipher:102:145586098197402-19 13:49:41.971 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Cipher:11:145586098197402-19 13:49:41.981 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Cipher:12:145586098198302-19 13:49:42.201 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Cipher&gt;&gt;&gt;&gt; name:Cipher1, age:1, token:123abc_!@#$%^&amp;*02-19 13:49:42.201 24884-24884/com.ttdevs.demo I/Choreographer: Skipped 35 frames! The application may be doing too much work on its main thread.02-19 13:49:49.471 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: &gt;&gt;&gt;&gt;&gt; Noremal &gt;&gt;&gt;&gt;&gt;02-19 13:49:49.476 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Normal:101:145586098947702-19 13:49:49.521 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Normal:102:145586098952502-19 13:49:49.521 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Normal:11:145586098952502-19 13:49:49.531 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Normal:12:145586098953502-19 13:49:49.541 24884-24884/com.ttdevs.demo E/&gt;&gt;&gt;&gt;&gt;: Normal&gt;&gt;&gt;&gt; name:Normal2, age:2, token:123abc_!@#$%^&amp;* 通过简单的对比，我们发现，SQLCipher在打开写数据库的时候花费了375ms，时间大概是SQLite 45ms的8~9倍，所以我们在log中看到丢帧的提示。这就提示我们，简单的数据库操作，使用SQLite我们也可能需要考虑将其放在新的线程中。当然，这个测试对比不够完善，比如大文件写入，大量数据插入，事务等等，因此还需要更多、更详细的测试来检测SQLCipher的性能等，这里就暂不讨论了。 跑完上面的代码，我们来看看我们本地数据库中都创建了哪些东西： 12345root@t03g:/data/data/com.ttdevs.demo/databases # lsnormal_user.dbnormal_user.db-journaluser.dbroot@t03g:/data/data/com.ttdevs.demo/databases # 我们把这两个db文件拷贝到我们的电脑，看看里面有哪些东西。这里推荐一个工具：sqlitebrowser。打开他们的网站你会发现它有两个版本的：Standard和SQLCipher的。是的，你没看错，就是针对SQLCipher的。如果你使用Standard版本，你会发现无法打开我们加密后的user.db（当然你也可是试试其他方法）。使用SQLCipher版的，打开之前会要求输入我们加密的KEY，就是我们上面的123abc_!@#$%^&amp;*。这时候我们就可以看到原始的数据了，如下图： 0x03到这里，我们基本上已经见到了SQLCipher的使用。还没有结束，再来看一个问题：在创建项目开始，我尝试跑了下项目，apk的大小是1.4MB，在Gradle中引入SQLCipher之后，体积一下子飙到了8.7MB。呵呵呵~~ 这个体积的增加还是值得我们慎重的思考一下下的。 0x04说了这么多，我们可以得到这样一个结论，使用SQLiteCipher可以对我们客户端的本地数据库进行加密，但是我们需要自己存一个加密KEY，如果我们能保存好这个KEY，那我们的数据基本是安全的。但是同时，我们可能需要考虑数据库加密过程中引入的新的问题，比如：apk体积的暴增，加密对性能的影响，加密KEY的保存等等。这些问题考虑好之后，我们就可以决定是否引入SQLCipher。 如果你对引入SQLiteCiper引起的新问题心存芥蒂，那接下来给大家推荐下一种方法。敬请期待：Android本地数据安全尝试(中) PS：Github Demo","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」0x03本地数据安全尝试JNI","slug":"[Android]0x03本地数据安全尝试JNI","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]0x03本地数据安全尝试JNI/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]0x03本地数据安全尝试JNI/","excerpt":"","text":"前两篇，我们谈到了使用SQLCipher和Conceal对本地数据进行加密。由于都两种方法都采用了对称加密，因此我们需要自己管理加密的秘钥。这时你会发现，虽然对我们的数据进行了加密，但是我们却引入了新的问题。我们的加密方法很容易通过反编译apk获取到，那么，我们就需要安全的维护这个秘钥了。但遗憾的是，本地数据存储方式我们都已经讲述，并没有一种一劳永逸的安全保存方法，那么，我们的秘钥存在哪里合适呢？这个时候你可能会想到本地不行那我们存到服务器上吧，通过https进行传输。这样当然可以，通过一定的算法为每个人配置一个秘钥，需要的时候请求网络获取，然后对本地数据进行解密。但是这样也存在一个问题：本地保存的数据如果不联网就无法打开。那么，还有更好的方案吗？今天给大家介绍JNI。 0x01NDK，JNI对于刚接触android开发的攻城狮来说是有较大的门槛的，但是为了实现我们更安全的保存数据，他可能是不错的选择。反编译过别人家app的你可能都遇到过这样的情况：一个个没无法查看代码逻辑的so文件。这些文件我们可以使用java代码调用，实现一些我们不知道内部逻辑但是会给我们一个结果功能。那么，我们把密码放到这些so中就可以更进一步提高我们本地数据的安全级别。 下面通过一个加单的demo来看看JNI的实现。 首先创建一个工具类： 123456789public class CipherUtil &#123; static &#123; System.loadLibrary(\"Cipher\"); &#125; public static native String getCipherKey();&#125; 在这个类文件上点击右键，使用我们之前配置的javah工具生成头文件。之后我们会在和java目录同级的jni文件下看到一个.h文件，如下： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_ttdevs_ndk_CipherUtil */#ifndef _Included_com_ttdevs_ndk_CipherUtil#define _Included_com_ttdevs_ndk_CipherUtil#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: com_ttdevs_ndk_CipherUtil * Method: getCipherKey * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_ttdevs_ndk_CipherUtil_getCipherKey (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 然后在h文件的同级新建一个C++文件（右键&gt;New&gt;C/C++ Source file）,内容如下： 12345678910111213141516#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"QiniuConfig.h\"#include &lt;android/log.h&gt;#define LOG_TAG \"System.out\"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#include \"com_ttdevs_ndk_CipherUtil.h\"JNIEXPORT jstring JNICALL Java_com_ttdevs_ndk_CipherUtil_getCipherKey(JNIEnv *env, jclass)&#123; return (*env).NewStringUTF(\"Hello World! getCipherKey\");&#125; 我们还需要创建两个文件，一个叫Android.mk，另一个叫Application.mk，他们都在jni目录下。 Android.mk: 1234567891011# http://developer.android.com/intl/zh-tw/ndk/guides/android_mk.htmlLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := CipherLOCAL_SRC_FILES := Cipher.cppLOCAL_LDLIBS += -lloginclude $(BUILD_SHARED_LIBRARY) Application.mk 12345678# http://developer.android.com/intl/zh-tw/ndk/guides/application_mk.html# APP_STL := stlport_staticAPP_STL := gnustl_staticAPP_CPPFLAGS := -frtti -std=c++11APP_CFLAGS += -Wno-error=format-securityAPP_ABI := all 还没有完，我们还需要修改当前Project或者Module的gradle.build文件: 123456789101112131415161718192021android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig &#123; minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; ndk &#123; moduleName &quot;ndkutil&quot; &#125; &#125; sourceSets.main &#123; jni.srcDirs = [] jniLibs.srcDir &quot;libs&quot; &#125;...&#125; 完成这些，我们就可以进行编译了。在当前Project（Module）上点击右键，使用之前配置的ndk-build工具进行编译，如果没有问题，我们会在libs目录下看到生产的so文件。好了，最后我们可以编写测试代码了：在java直接调用刚才创建的CipherUtil即可： 1Log.d(\"&gt;&gt;&gt;&gt;&gt;\", CipherUtil.getCipherKey()); 运行上面代码，我们可以在log中看到输出的字符串： 1Hello World! getCipherKey 0x02上述demo中，我们只是简单的返回一个字符串，要实现更安全，我们可以将此方法写的更复杂，比如获取app的签名，获取设备的硬件信息进行复杂的组合，以保障最终生成的秘钥的唯一性和安全性（更难伪造），这里有一个demo可以参考。 写到这里，可能又有人会问到：其实so文件也不是很全，可以通过对汇编的分析得到里面的代码逻辑。当然，高手是可以做到对so文件进行分析的，但是so还是可以阻隔大部分的反编译人员。如果我们能把getCipherKey实现的更好，也会增加破解的成本。另外，so还有一个被盗用的问题，就是别人直接调用我们的so，这个问题也可以通过一定的代码逻辑来避免。之后会继续讲解。 最后再说一点，对于秘钥，我们最终还会被载入我们的内存，如果直接dump我们的内存，会是一个人什么样的结果呢？","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」Android Studio 1.x NDK环境搭建","slug":"[Android]Android Studio 1.x NDK环境搭建","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]Android Studio 1.x NDK环境搭建/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]Android Studio 1.x NDK环境搭建/","excerpt":"","text":"下载NDK下载NDK Download mac: android-ndk-r10e-linux-x86.bin 安装1234➜ ndk lsandroid-ndk-r10e-darwin-x86_64.bin➜ ndk chmod a+x android-ndk-r10e-darwin-x86_64.bin➜ ndk ./android-ndk-r10e-darwin-x86_64.bin 配置环境gradle.properties在末尾添加一行： android.useDeprecatedNdk=true 添加build工具AS &gt; Preferences &gt; Tools &gt; External Tools add javah Name: javah Group: default(External Tools) Description: generate C header Options: select all Show in: select all Tools Settings: Program: $JDKPath$/bin/javah Parameters: -v -d $ModuleFileDir$/src/main/jni -jni $FileClass$ Parameters: -bootclasspath $ModuleSdkPath$/platforms/android-23/android.jar -v -d $ModuleFileDir$/src/main/jni -jni $FileClass$ (if you need android object) Working directory: $SourcepathEntry$ (PS: Right click on the class) 123456789101112131415➜ ~ javah用法: javah [options] &lt;classes&gt;其中, [options] 包括: -o &lt;file&gt; 输出文件 (只能使用 -d 或 -o 之一) -d &lt;dir&gt; 输出目录 -v -verbose 启用详细输出 -h --help -? 输出此消息 -version 输出版本信息 -jni 生成 JNI 样式的标头文件 (默认值) -force 始终写入输出文件 -classpath &lt;path&gt; 从中加载类的路径 -bootclasspath &lt;path&gt; 从中加载引导类的路径&lt;classes&gt; 是使用其全限定名称指定的(例如, java.lang.Object)。 add ndkBuild Name: ndkBuild Group: default(External Tools) Description: ndk build Options: select all Show in: select all Tools Settings: Program: /Users/ttdevs/android/android-ndk-r10e/ndk-build Parameters: NDK_LIBS_OUT=$ModuleFileDir$/libs Working directory: $ModuleFileDir$/src/main (PS: Right click on the module name) 编写代码新建一个Module：ndkutil修改ndkutil的build.gradle123456789101112131415161718android &#123; ... defaultConfig &#123; ... ndk &#123; moduleName \"ndkutil\"// abiFilters \"armeabi-v7a\", \"x86\"// stl \"gnustl_static\"// cFlags \"-std=c++11 -Wall\"// ldLibs \"log\", \"jnigraphics\", \"EGL\", \"GLESv3\" &#125; &#125; sourceSets.main &#123; jni.srcDirs = [] jniLibs.srcDir \"libs\" &#125;&#125; 创建工具类CipherUtil1234567package com.ttdevs.ndk;public class CipherUtil &#123; static &#123; System.loadLibrary(\"Cipher\"); &#125; public static native String getCipherKey();&#125; 生成头文件com_ttdevs_ndk_CipherUtil.h在刚才创建的CipherUtil.java上点击右键 &gt; External Tools &gt; javah此时会在main目录下生成: jni/com_ttdevs_ndk_CipherUtil.h 编写代码都是在ndkutil/src/main/jni目录下 创建C源码:Cipher.cpp 12345#include \"com_ttdevs_ndk_CipherUtil.h\"JNIEXPORT jstring JNICALL Java_com_ttdevs_ndk_CipherUtil_getCipherKey(JNIEnv *env, jclass)&#123; return (*env).NewStringUTF(\"Hello World!\");&#125; 创建Android.mk 12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := CipherLOCAL_SRC_FILES := Cipher.cppinclude $(BUILD_SHARED_LIBRARY) 创建Application.mk 12APP_MODULE := CipherAPP_ABI := all 编译生成so文件在module（ndkutil）上点击右键 &gt; External Tools &gt; ndkBuild ，可以看到如下log： 123456789101112131415161718192021222324/Users/ttdevs/android/android-ndk-r10d/ndk-build NDK_LIBS_OUT=/Users/ttdevs/android/workspace/Demo/ndkutil/libs[arm64-v8a] Compile++ : Cipher &lt;= Cipher.cpp[arm64-v8a] SharedLibrary : libCipher.so[arm64-v8a] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/arm64-v8a/libCipher.so[x86_64] Compile++ : Cipher &lt;= Cipher.cpp[x86_64] SharedLibrary : libCipher.so[x86_64] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/x86_64/libCipher.so[mips64] Compile++ : Cipher &lt;= Cipher.cpp[mips64] SharedLibrary : libCipher.so[mips64] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/mips64/libCipher.so[armeabi-v7a] Compile++ thumb: Cipher &lt;= Cipher.cpp[armeabi-v7a] SharedLibrary : libCipher.so[armeabi-v7a] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/armeabi-v7a/libCipher.so[armeabi] Compile++ thumb: Cipher &lt;= Cipher.cpp[armeabi] SharedLibrary : libCipher.so[armeabi] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/armeabi/libCipher.so[x86] Compile++ : Cipher &lt;= Cipher.cpp[x86] SharedLibrary : libCipher.so[x86] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/x86/libCipher.so[mips] Compile++ : Cipher &lt;= Cipher.cpp[mips] SharedLibrary : libCipher.so[mips] Install : libCipher.so =&gt; /Users/ttdevs/android/workspace/Demo/ndkutil/libs/mips/libCipher.soProcess finished with exit code 0 此时我们可以发现在ndkutil/libs/目录下生成的so文件。 测试代码1String cipher = CipherUtil.getCipherKey(); 项目结构","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」Android Studio 2.0 NDK开发环境搭建","slug":"[Android]Android Studio 2.0 NDK开发环境搭建","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]Android Studio 2.0 NDK开发环境搭建/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]Android Studio 2.0 NDK开发环境搭建/","excerpt":"","text":"0x00 前情回顾前不久写了一篇环境搭建，虽然可以跑一个demo，但是如果你跟着做的话就会发现，仅仅是可以跑一个Demo，真做起来很是蛋疼。编写源码，生成so，跑App，改一点代码，再生成so，跑app。而且编写代码没有提示，不能格式化，各种不能，就是最基本的文本开发。经过一段时间折腾和Android Studio 2.0的 release，发现有更完美的方式，而且不用编写Android.mk和Application.mk。看在我刚开始学的份上，容我再来写一遍。看完这篇，你会发现JNI的开发也是如此的so easy。 0x01 环境搭建所需环境： Android Studio 2.0 Gradle 2.10（最低要求） NDK：ndk-r11c（目前最新版：2016-04-16） LLDB：2.1（目前最新版：2016-04-16） 下面开始正式操作： 安装Android Studio 2.0 这个就不细说了。 配置Gradle 最低要求Gradle版本为2.10，目前最新版本为2.12。修改方法： 项目根目录/gradle/wrapper/gradle-wrapper.properties 将最下面的一行改成你要的版本，如： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip 安装NDK 安装NDK有两种方式，一种是直接下载最新的NDK安装文件进行安装，另一种是通过SDK安装： NDK安装文件 下载参考这里。根据你的操作系统下载不同版本。 通过SDK安装 Android Studio &gt; Preferences &gt; Appearance &amp; Behavior &gt; Syetem Settings &gt; Android SDK &gt; SDK Tools 在这个Tab中找到 Android NDK，选中安装即可。安装之后我们可以在 Android SDK 的目录下看到一个 ndk-bundle 目录，这个就是我们的NDK目录。 LLDB 和 GDB 类似，LLDB 是一款调试器，可以调试我们的JNI代码。同上打开SDK设置界面： Android Studio &gt; Preferences &gt; Appearance &amp; Behavior &gt; Syetem Settings &gt; Android SDK &gt; SDK Tools 在这个Tab中找到 LLDB，选中安装即可。安装之后我们可以在 Android SDK 的目录下看到一个 lldb 目录，这个就是我们的 LLDB 目录。LLDB的更多信息可参考这里。 通过上面的配置，接下来就可以开始我们的JNI的开发了。 可能你会问之前我有介绍过一篇开发环境的搭建，这个有什么不同呢？如果你使用之前的方法，你需要配置 Android.mk、Application.mk，无代码自动完成，不能代码个时候，运行调试麻烦，等等。这些问题在这里都不存在了，让我们把更多的精力放到代码编写中。 0x02 测试Demo新建java代码： 123456public class CipherUtils &#123; static &#123; System.loadLibrary(\"CipherUtils\"); &#125; public static native int add(int x, int y);&#125; 生成对应的C++代码： 令人兴奋的是，Android Studio可以帮我们自动生成 C 代码。点击 add 方法，Option ＋ Return 即可生成一个 CipherUtils.c文件，由于我打算使用C++，因此将扩展名改为 cpp ，同时添加头文件，最终如下： 123456789101112#include &lt;jni.h&gt;#include &lt;string&gt;using namespace std;#include \"utils/log.h\"JNIEXPORT jint JNICALL Java_com_ttdevs_jniutils_CipherUtils_add(JNIEnv *env, jclass type, jint x, jint y) &#123; std::string input_str(\"Test add two number!\"); LOGE(\"%s\", input_str.c_str()); return x + y;&#125; PS：如果报错，可是将错误的 cpp文件拷贝出来再考吧回去。 build.gradle 配置 12345678910111213141516171819202122android &#123; ...... defaultConfig &#123; ...... ndk &#123; moduleName \"CipherUtils\" stl \"gnustl_static\" // stlport_static abiFilters \"armeabi\", \"armeabi-v7a\" ldLibs \"log\", \"android\" &#125; &#125; sourceSets.main &#123; // 如果不写(jni.srcDirs = ['src/main/jni/']) // Android展示模式没有jni目录 // this file has been added after the last project sync with gradle // 必须有值,如: 'src/main/jni/' jni.srcDirs = ['src/main/jni/'] // jniLibs.srcDir \"libs\" &#125; ......&#125; 直接点击运行按钮，即可跑我们的测试程序了。就这么简单。 0x03 JNI层的Debug这个同样简单。首先需要在外面的build.gradle中配置一下： 123456789android &#123; ...... buildTypes &#123; debug &#123; jniDebuggable = true &#125; ...... &#125;&#125; 在 C/C++ 源文件上添加断点，点击debug，就可以像debug我们的java代码一样调试我们的原生代码了。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」Android你可能要用到的自定义View分享","slug":"[Android]Android你可能要用到的自定义View分享","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]Android你可能要用到的自定义View分享/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]Android你可能要用到的自定义View分享/","excerpt":"","text":"0x00 main进步、创新都是在不断变化的需求中诞生的。 －－ By ttdevs 这不，新的需求又来了。废话不多说，先上设计稿： 简单分析上图包括三部分：最上面的类Progressbar，中间两个指示盘和最下面的指示盘。第一个类Progressbar我们项目之前有实现过，但是和这个需求有一些差异，因此决定重新实现一遍。另外两个圆形指示盘本想通过在一张背景图片上放一张指针图，控制指针图的旋转来实现，但是考虑到这样不够灵活，因此也决定自己来画。So，我们接下来实现这三个View。 正式开始之前，先看看我们最终效果图（当然，指针是可以动的）： 0x01 分析 LineIndicator （第一个，类Progressbar） 主要包括三部分：左侧的提示和内容，右侧的提示和内容，中间的类Progressbar。两侧的文字比较容易处理，掌握了文字的基本绘制，画起来是很容易的。中间的类Progressbar由于打算自己画，所以不会直接贴个Progressbar在上面。我的思路是画一条长的直线作为背景，中间的指示也是直线，比背景直线粗，直线的Paint设置 StrokeCap 为 Paint.Cap.ROUND 即 paint.setStrokeCap(Paint.Cap.ROUND);，这样就可以有两头半圆的效果；中间的指示数字直接画在粗的指示直线上面即可。这里可能遇到的问题有下面两个： StrokeCap 设置 为 Paint.Cap.ROUND时的位置关系 StrokeCap 设置 为 Paint.Cap.ROUND，直线两侧的半圆是不算在直线的长度里的。简单来说，如果view的长度和我画的直线长度一致，那么这个直线就是矩形而不是期待的两侧都是半圆的椭圆。 当进度为0或者为100％时的展示 如果我们背景直线和指示直线起点终点位置一致，那么最终效果就是当进度为0或者100%的时候，指示直线是显示不全的，因此我们需要对这两个位置进行矫正。我的矫正方法比较简单，在0～x和y～100%进度的时候分别显示x和y（本以为自己的思路很屌，后来发现别人也是这么干的）。 CircleIndicator （中间的多种颜色环） 这个View我将其分解为四部分，从上层到下层：中间指针，刻度环，显示的内容，圆环背景和外层指示文字。每一部分再做分解： 中间指针 这个又分解为六个部分：最下层大圆，两个圆形半圆，两个三角形和上层小圆。 刻度环 由于是圆环，所以必须画弧线了。但是这个弧线又有点特殊，两侧带圆角，中间圆环直角，这个没想到啥好办法，用了很一般的思路：先用 Paint.Cap.ROUND 画两侧的弧，然后 Paint.Style.STROKE 画中间的部分。 显示的内容 这个就比较简单了，主要在于计算文字的显示位置。 圆环背景和外层文字 最简单的一个圆，加一个以圆为路径画的文字。 最后我们画的顺序正好与上面所述顺序相反。 ProgressIndicator （最下面的两种颜色环） 这个相较 CircleIndicator 就简单了一些。在画圆环的时候，我们只需要先画一个灰色背景，然后再画一个绿色圆弧即可。 0x02 实现View的绘制我们应该都比较熟悉，主要有下面三个过程： onMeasure（测量）、onLayout（布局）、onDraw（绘制）。针对上述三个View：LineIndicator，我们根据实际的内容来计算View的高度，宽度用户设定；CircleIndicator和ProgressIndicator的宽度用户设定，高度自定计算与宽度相同。onLayout我们不需要。最后的根据实际的展示内容来绘制。 另外，由于CircleIndicator和ProgressIndicator和相似度高，很多代码可以拿来重用，因此，我写了一个基类来完成公共的部分，特殊部分每个 子类自己完成。最后再子类地onDraw方法中按照顺序调用即可。 由于主要是计算各种坐标位置，代码还是不少的，这里就不贴代码。最后的实现请移步我的 github。三个View的代码已经整理完LineIndicator，其它的两个还需要点时间（2016-06-19）。 0x03 知识点 自定义View的思路 创建类，继承自View或者ViewGroup或者其它ViewGroup 定义View的可配置参数，如果你需要的话 实现View的具体逻辑 这个太粗略了，各位可以参考具体源码。 文字位置的计算 如果你没有自己画过文字，那你肯定不可能一下子明白文字的画法，或多或少的出现偏移。这里直接给大家推荐一篇讲的非常详细的文章：http://blog.csdn.net/aigestudio/article/details/41447349 位置、半径、弧长等的计算 这里会涉及到简单的三角函数和圆的周长弧度的计算，可能要说的就是三角函数的参数是弧度制度。 ObjectAnimator 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 设置内容的颜色值（非resource的id） * * @param contentColor 内容的颜色值 * @param unitColor 单位的颜色值 */public void setContentColor(int contentColor, int unitColor) &#123; mContentColor = contentColor; mUnitColor = unitColor;&#125;/** * 设置进度 * * @param indicator 进度值 */public void setIndicator(float indicator) &#123; if (indicator &lt;= mStartIndicator) &#123; mIndicator = mStartIndicator; &#125; else if (indicator &gt; mEndIndicator) &#123; mIndicator = mEndIndicator; &#125; else &#123; mIndicator = indicator; &#125; postInvalidate();&#125;/** * 获取进度 * * @return 当前进度值 */public float getIndicator() &#123; return mStartIndicator;&#125;public void animateIndicator(float indicator) &#123; Interpolator interpolator = new AnticipateOvershootInterpolator(1.8f); ObjectAnimator animation = ObjectAnimator.ofFloat(this, \"indicator\", indicator); animation.setDuration(2000); animation.setInterpolator(interpolator); animation.start();&#125; 处理屏幕的旋转 由于时间比较紧，这个我还没做。主要在View的以下两个方法中实现： 123456789@Overrideprotected Parcelable onSaveInstanceState() &#123; return super.onSaveInstanceState();&#125;@Overrideprotected void onRestoreInstanceState(Parcelable state) &#123; super.onRestoreInstanceState(state);&#125; 最后欢迎各位吐槽并提供更好的建议～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」DataBinding给Button设置背景无效","slug":"[Android]DataBinding给Button设置背景无效","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]DataBinding给Button设置背景无效/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]DataBinding给Button设置背景无效/","excerpt":"","text":"0x00 问题通过Data Binding给Button设置背景无效。具体表现为给Button设置不同的背景图片，但是无论怎样背景只会显示不同的颜色，而不是显示期望的图片。 0x01 分析由于对Data Binding不是很熟悉，所以很奇怪为什么。不管怎样先打印下这个资源的值，发现在布局文件中打印资源值是有的。根据经验，设置不同的背景图片，背景会显示不同的颜色，那这个值可能被解析成了颜色值。 0x02 解决在网上搜了一下（容我忘记了具体网址），需要通过不同的方式来设置背景：之前的： 12345678910&lt;Button android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:gravity=\"center\" android:onClick=\"@&#123;(view) -&gt; handler.onStartClick(view)&#125;\" android:text=\"@string/button_start\" android:textColor=\"@color/blueColor\" android:textSize=\"@dimen/global_font_large\" android:background=\"@&#123;handler.startButtonBg&#125;\" tools:background=\"@drawable/btn_main_circle_start\" /&gt; 修改之后： 12345678910&lt;Button android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:gravity=\"center\" android:onClick=\"@&#123;(view) -&gt; handler.onStartClick(view)&#125;\" android:text=\"@string/button_start\" android:textColor=\"@color/blueColor\" android:textSize=\"@dimen/global_font_large\" app:backgroundResource=\"@&#123;handler.startButtonBg&#125;\" tools:background=\"@drawable/btn_main_circle_start\" /&gt; 也就是将之前的 android:background 换成 app:backgroundResource 0x03 总结没啥总结的，Data Binding 还有很多等待探究。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」Android闹钟遇到的那些坑","slug":"[Android]Android闹钟遇到的那些坑","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]Android闹钟遇到的那些坑/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]Android闹钟遇到的那些坑/","excerpt":"","text":"0x00 做过闹钟的话你才会理解的坑第一次做闹钟程序是在2012年，那时候android最新版本是2.2，2.3发布在即，做了一个整点提醒的小工具，记得很清楚，主要的问题是锁屏之后闹钟不能准时被唤醒，总会晚那么几秒钟，后来没办法把闹钟提前设置几秒钟。不过那时候环境还好，没有遇到攻克不了的问题，重启也可以唤起闹钟的。 但是随着android版本的进化，开发者节操的丢失，问题就越来越难做了。闹钟明明设置了却不能到来；不再设置的时间到来，晚了好久才到；重启之后闹钟就没了等等。当然，还有好多好多，总之很多东西不按照自己期待的来。 项目上线，踩过之后挑一些做总结。 由于时间关系，项目比较赶，所以没有去考虑闹钟无法及时触发的问题，假设了一个最理想的环境。（更多的信息可以参考下面的文章） 0x01 闹钟的创建这里涉及到不同版本设置闹钟的方法，下面的参考文章中已经提到： 123456789private void startAlarm(Calendar calendar, PendingIntent pendingIntent) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; // mManager.setWindow(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), 1000* 5, mFirstPIntent); mManager.setExact(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), pendingIntent); // mManager.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), mSecondPIntent); &#125; else &#123; mManager.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), pendingIntent); &#125;&#125; 0x02 闹钟的取消有的时候可能需要去取消一个闹钟。我们可以通过两种方式来取消： 通过 PendingIntent.cancel(); 来取消 12345678910/** * Cancel a currently active PendingIntent. Only the original application * owning a PendingIntent can cancel it. */public void cancel() &#123; try &#123; ActivityManagerNative.getDefault().cancelIntentSender(mTarget); &#125; catch (RemoteException e) &#123; &#125;&#125; 这种方式只有能拿到 `PendingIntent` 才可以。 通过 AlarmManager.cancel(PendingIntent); 来取消 12345678910111213141516/** * Remove any alarms with a matching &#123;@link Intent&#125;. * Any alarm, of any type, whose Intent matches this one (as defined by * &#123;@link Intent#filterEquals&#125;), will be canceled. * * @param operation IntentSender which matches a previously added * IntentSender. * * @see #set */public void cancel(PendingIntent operation) &#123; try &#123; mService.remove(operation); &#125; catch (RemoteException ex) &#123; &#125;&#125; 0x03 闹钟的查看又个adb命令可以用来查看当前系统中存在的闹钟： adb shell dumpsys alarm 不是在所有的设备上都好使，比如在我的魅族设备上可以正常使用，而在另一台 OPPO R7C上就不可以。 0xFF 参考 http://www.jianshu.com/p/1f919c6eeff6","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」LayoutInflate遇到的坑","slug":"[Android]LayoutInflate遇到的坑","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]LayoutInflate遇到的坑/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]LayoutInflate遇到的坑/","excerpt":"","text":"0x01 问题123456789101112131415161718192021222324252627private void initVoiceItem() &#123; viewMusicList.removeAllViews(); int localResource = SysPreferences.getAlarmVoiceResource(); LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; VOICE_KEY.length; i++) &#123; View view = inflater.inflate(R.layout.item_voice_name, viewMusicList); // TODO: 2017/2/10 view.setOnClickListener(mClickListener); ... &#125;&#125;private final View.OnClickListener mClickListener = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int size = viewMusicList.getChildCount(); for (int i = 0; i &lt; size; i++) &#123; View view = viewMusicList.getChildAt(i); ... if (v == view) &#123; &#123;...1...&#125; &#125; else &#123; &#123;...2...&#125; &#125; &#125; &#125;&#125;; 有上面一串代码，你能发现有什么问题吗？ 嗯嗯，是这样的：只会执行代码块{1}，并没有像我们期待的那样点击的时候执行到代码块{2}中去。没有细究，通过下面的代码直接跨过去： 123456789101112private void initVoiceItem() &#123; viewMusicList.removeAllViews(); int localResource = SysPreferences.getAlarmVoiceResource(); LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; VOICE_KEY.length; i++) &#123; View view = inflater.inflate(R.layout.item_voice_name, null); // TODO: 2017/2/10 view.setOnClickListener(mClickListener); ... viewMusicList.addView(view); &#125;&#125; 虽然不知道什么原因，但是找到解决办法，不过还是挺惭愧的······ 0x02 分析很多人可能跟我一样，开始学的时候，记住该怎么写，这个方法是干嘛的。但是很难避免会记错某个方法，就像我们会写错某个字一样，当别人纠正的时候才知道，这个字自己已经写错十几活着几十年了。来看一下 View.inflate() 这个方法： 1234567891011121314/*** Inflate a new view hierarchy from the specified xml resource. Throws* &#123;@link InflateException&#125; if there is an error.* * @param resource ID for an XML layout resource to load (e.g.,* &lt;code&gt;R.layout.main_page&lt;/code&gt;)* @param root Optional view to be the parent of the generated hierarchy.* @return The root View of the inflated hierarchy. If root was supplied,* this is the root View; otherwise it is the root of the inflated* XML file.*/public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125; 如果我们传入了 root View，那么返回的就是root View， 如果不传，则返回根据布局文件生成的 View。而根据我上面的代码，显然被我错误的理解，无论传不传 root View，返回的都是根据布局文件生成的 View，而我就这么相安无事的用了好几年······ 0x03 你以为这就这样结束了如果你执行我的错误代码，你会看到下面这个图： 这个这个图有两个信息： 后面几个Item显示的名称是错误的 点击某个Item，其他几个Item的checkbox也被选择 我们按照错误的代码执行的逻辑进行分析。首先： 1234for (int i = 0; i &lt; VOICE_KEY.length; i++) &#123; View view = inflater.inflate(R.layout.item_voice_name, viewMusicList); ...&#125; 这段代码会循环多次，将inflate后的布局添加到viewMusicList，这样viewMusicList下面就有多个 item_voice_name 因此最终给我们展现的结果就是看到有多个Item。 对于第一个问题，我们需要从 view.findViewById() 说起，从View中你会发现这两段代码： 1234567891011121314151617181920212223242526/*** Look for a child view with the given id. If this view has the given* id, return this view.** @param id The id to search for.* @return The view that has the given id in the hierarchy or null*/@Nullablepublic final View findViewById(@IdRes int id) &#123; if (id &lt; 0) &#123; return null; &#125; return findViewTraversal(id);&#125;/*** &#123;@hide&#125;* @param id the id of the view to be found* @return the view of the specified id, null if cannot be found*/protected View findViewTraversal(@IdRes int id) &#123; if (id == mID) &#123; return this; &#125; return null;&#125; 是不是太简单，根本没找到我们期待的逻辑——ViewGroup中怎么处理，细心的你会发现ViewGroup重写了 findViewTraversal() 方法： 1234567891011121314151617181920212223@Overrideprotected View findViewTraversal(@IdRes int id) &#123; if (id == mID) &#123; return this; &#125; final View[] where = mChildren; final int len = mChildrenCount; for (int i = 0; i &lt; len; i++) &#123; View v = where[i]; if ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0) &#123; v = v.findViewById(id); if (v != null) &#123; return v; &#125; &#125; &#125; return null;&#125; 从这段代码可以看出，在ViewGroup中根据ID查找，找到就返回，而找到的永远是最前面的View。这就解释了为什么第一个Item和其他的不同了。 （对于点击某个Item，其他Item也出现波纹效果，猜测可能是因为波纹效果是根据ID来实现的。TODO ） 0x04 总结上面遇到的View inflate是我个人遇到的问题，主要是因为对基础知识掌握有问题。另外在使用inflate的时候，可能还会遇到LayoutParam设置无效的问题，这个可以通过套一个View的方式解决，仅此记录。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」MediaPlayer单曲循环不卡顿","slug":"[Android]MediaPlayer单曲循环不卡顿","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]MediaPlayer单曲循环不卡顿/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]MediaPlayer单曲循环不卡顿/","excerpt":"","text":"0x00 需求单曲循环播放歌曲，要求过度连贯，听不出来卡顿感觉。 0x01 解决思路 MediaPlayer 对于常见的音乐播放，我们第一时间想到的应该就是它，它有一个方法 MediaPlayer.setLooping(true); 就是用来进行单曲循环的。但是很遗憾，如果你简单的这么做，上面的目的是达不到的，会出现上一遍结束出现一个明显的停止才开始播放下一次的现象。 不过最后就是用的这个组件，不过不是简单的设置 setLooping(true)。 SoundPool 一段时间内可能会播放很多音乐的时候，我们首先应该选择这个。 第三方组件 如果没有特殊的需求，这个不是首选，特别是当引入的组件特别重的时候。 因为之前踩过坑：iOS上直接播放mp3文件，单曲循环的时候播放的间隙特别长，卡顿的感觉无法接受，解决方法是将mp3转换成m4a，基本上听不出中间的过度间隙。首先尝试了使用 MediaPlayer 来播放，在我的机器（MX4 Pro）上播放还勉强能接受，间隙不是非常明显，换到配置差一点的机器上就不能忍了。然后尝试了 SoudPool ，无论是预加载一次循环播放，还是预加载两次循环播放，中间的卡顿感觉和用 MediaPlayer.setLooping(true); 一样一样的。再然后，尝试macOS 下编译 vlc for android ，我失败了╮(╯▽╰)╭）问题总要解决的，再找其他办法。 0x02 死循环找了很多资料，最后使用一个循环播放的方法解决了这个问题： 创建第一个播放器，播放； 同时创建第二个播放器，准备； 第一个播放器播放完毕立马启动第二个； 然后创建第三个播放器，准备； 如此往复，直到用户停止… 由于对 MediaPlayer 没有过深入的研究和使用，这个思路来一时半会自己还是想不出来的（总是会想只要创建一个播放器就够了）。这么做下来真的循环播放就没有间隙感了…… 由于 mPlayer.setLooping(true); 是native方法，所以没有去跟具体的实现逻辑。猜测可能是重新加载或者其他原因导致单曲循环中间间隙较大（原谅我的懒，没有去拿大文件尝试）。而使用上面的方式，当播放时间大于预加载时间的时候，第一个播放器播放的时候有第二个播放器有充足的机会去完成加载然后等待播放（播放时间小于加载时间的可能性不是很大）。 12345678910111213141516171819202122232425262728private MediaPlayer mPlayer, mNextPlayer;private int mPlayResId = R.raw.water;public void testLoopPlayer() &#123; mPlayer = MediaPlayer.create(this, mPlayResId); mPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mediaPlayer) &#123; mPlayer.start(); &#125; &#125;); createNextMediaPlayer();&#125;private void createNextMediaPlayer() &#123; mNextPlayer = MediaPlayer.create(this, mPlayResId); mPlayer.setNextMediaPlayer(mNextPlayer); mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; mp.release(); mPlayer = mNextPlayer; createNextMediaPlayer(); &#125; &#125;);&#125; 0x03 总结这更像一个开脑洞的问题。 0x04 参考 http://stackoverflow.com/questions/26274182/not-able-to-achieve-gapless-audio-looping-so-far-on-android","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」Toobar的一个简单封装","slug":"[Android]Toobar的一个简单封装","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]Toobar的一个简单封装/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]Toobar的一个简单封装/","excerpt":"","text":"Toolbar和ActionBar的直观区别就是需要我们自己将ToolBar加到自己的布局文件中。目前的情况是：在我们的现有项目上改动，多数的Activity都是继承一个BaseActivity。为了用最小的代价达到目的，简单的思考之后，做了如下的改动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 带ToolBar的基类 */public class BaseActivity extends ActionBarActivity &#123; private static final int BASE_VIEW_ID = R.layout.activity_base; private static final LayoutParams LAYOUT_PARAMS = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); private LinearLayout mParentView; private Toolbar mToolBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; ViewUtils.startTranslucent(this); super.onCreate(savedInstanceState); setContentView(BASE_VIEW_ID); &#125; @Override public void setContentView(int layoutResID) &#123; if (BASE_VIEW_ID == layoutResID) &#123; super.setContentView(layoutResID); mParentView = (LinearLayout) findViewById(R.id.base_parent_view); mToolBar = (Toolbar) findViewById(R.id.toolbar); initToolbar(mToolBar); return; &#125; mParentView.addView(getLayoutInflater().inflate(layoutResID, null), LAYOUT_PARAMS); &#125; @Override public void setContentView(View view) &#123; mParentView.addView(view, LAYOUT_PARAMS); &#125; private void initToolbar(Toolbar toolbar) &#123; setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); &#125; public Toolbar getToolBar() &#123; return mToolBar; &#125; public void setBackground(int colorId) &#123; if (null != mParentView) &#123; mParentView.setBackgroundColor(getResources().getColor(colorId)); &#125; &#125;&#125; 布局文件activity_base.xml： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/base_parent_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/global_background_status_bar\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/subview_toolbar\"/&gt;&lt;/LinearLayout&gt; 在基类中添加如上代码，基本可以用最小的改动达到使用Toolbar的目的。但是，这样也存在一个问题，就是会使我们的每个Activity的布局层次多了一层。 如果有更好的思路，欢迎分享～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」*不同Context区别","slug":"[Android]不同Context区别","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]不同Context区别/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]不同Context区别/","excerpt":"","text":"代码： 1234567AlertDialog dialog = new AlertDialog .Builder(context) .setTitle(title) .setCancelable(false) .setPositiveButton(\"确定\", listener) .create();dialog.show(); 错误信息： 123456789101112131415android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an at android.view.ViewRootImpl.setView(ViewRootImpl.java:589) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:326) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:224) at android.view.WindowManagerImpl$CompatModeWrapper.addView(WindowManagerImpl.java:149) at android.app.Dialog.show(Dialog.java:293) at com.ttdevs.easysecuritysmartbar.StartHandler.handleMessage(StartHandler.java:39) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:4866) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:511) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:786) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553) at dalvik.system.NativeStart.main(Native Method) 其中context是通 getApplicationContext() 获取的，将其换成 Activity 问题解决。 0xFF 参考 http://blog.csdn.net/lmj623565791/article/details/40481055","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」从浏览器中打开我们的应用","slug":"[Android]从浏览器中打开我们的应用","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]从浏览器中打开我们的应用/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]从浏览器中打开我们的应用/","excerpt":"","text":"0x01 需求有时候你会发现，用Android系统自带的浏览器（chrome）打开一个web页面，如果安装了相应的App，就会自动打开这个App并进入具体的界面中，比如手机上打开： https://www.zhihu.com/openinapp_instruction?app-id=432274380&amp;app-argument=zhihu://questions/24122524 如果我们安装了知乎手机客户端，这个时候会自动打开知乎手机客户端，并且进入问题展示界面。还比如网易云音乐，今日头条等等App都是支持这个功能的。之前我们自家App的分享都是打开一个App介绍的界面，即使安装了手机客户端，也不会自动打开手机客户端。为了追求更好的体验，我们需要实现这个功能。 0x01 Chrome浏览器研究这个功能，还是查阅了不少资料，比如 app link、deep link、chrome browser等等，如果紧紧是实现上面介绍的功能，还是 so easy的，仅仅需要了解 Chrome 浏览器 创建 Intent 的方法即可。 Chrome构造一个 Intent 的基本语法如下： 123456789intent: HOST/URI-path // Optional host #Intent; package=[string]; action=[string]; category=[string]; component=[string]; scheme=[string]; end; 根据上面的语法，我们来看一个demo： 123456intent: //article/51348656 #Intent; package=com.ttdevs.android; scheme=ttdevs; end; 可以使用下面的 html 代码触发这个事件： 1&lt;a href=\"intent://article/51348656/#Intent;scheme=ttdevs;package=com.ttdevs.android;end\"&gt;ttdevs&lt;/a&gt; 另外还有个参数： 1S.browser_fallback_url=[encoded_full_url] 介绍如下（不过我没搞明白）： When an intent could not be resolved, or an external application could not be launched, then the user will be redirected to the fallback URL if it was given.Some example cases where Chrome does not launch an external application are as follows: The intent could not be resolved, i.e., no app can handle the intent. JavaScript timer tried to open an application without user gesture.Note that S. is a way to define string extras. S.browser_fallback_url was chosen for backward compatibility, but the target app won’t see browser_fallback_url value as Chrome removes it. 0x02 App内处理浏览器发来的Intent通过上面的介绍，如果我们点击链接，就会触发一个 Intent，有了Intent，我们还需要来处理它。在 AndroidManifest.xml 中相应的 Activity 中的配置中添加如下filter： 1234567&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;data android:host=\"article\" android:pathPattern=\"/.*\" android:scheme=\"ttdevs\"/&gt;&lt;/intent-filter&gt; 同时在Activity中处理Intent： 1234567891011121314151617public class RouterActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_router); handleIntent(getIntent()); &#125; private void handleIntent(Intent intent) &#123; String action = intent.getAction(); String data = intent.getDataString(); LogUtils.debug(action); LogUtils.debug(data); &#125;&#125; 运行上面的代码，同时用系统浏览器打开上面的html，点击链接，即可调起我们的app。或者也可以通过下面的adb命令触发： 1234adb shell am start \\-a android.intent.action.VIEW \\-c android.intent.category.BROWSABLE \\-d &quot;ttdevs://article/12345&quot; com.ttdevs.android 在我的设备（魅族MX4 Pro）上，如果没有安装处理这个 Intent 的App，则会打开系统自带的应用市场。 对于一个提供查询食物数据的App，如果我们分享出去的食物信息带上了相关的参数，在用户点击分享链接时，如果安装了我们的App则可以跳到App中展示食物的界面，如果没有安装，则会跳到应用市场下载，很好的逻辑～～ 0xFF 参考 https://developer.chrome.com/multidevice/android/intents","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」仿联系人列表上的字母索引","slug":"[Android]仿联系人列表上的字母索引","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]仿联系人列表上的字母索引/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]仿联系人列表上的字母索引/","excerpt":"","text":"这个小功能github有很多。不同的应用需求会有少许差别，比如listview滑动时字母是不是跟随滑动；手动点击字母是不是在屏幕中间显示一个提示；点击时索引的背景显示出来，离开后背景消失等等，当然这些都是细节问题。实现思路上也可以有多种，比如自己去draw每个字母，然后处理滑动、借助TextView来展示字母列表等。看了几个demo，感觉和自己的需求有些差别，而且这些demo为了实现”大而全”有些多余的东西，因此决定自己写个。 0x01 分析我们的需求是这样的：中文参与索引，字母或者其他开头的item不参与索引，直接放到第一个“#”里；点击字母索引其被点击字母列表颜色跟随变化；手动滑动listview字母索引的字母颜色也跟随变化；自己顺手加了个点击某个字母弹出提示的接口。最后效果如下图： 0x02 实现决定直接使用垂直方向的LinearLayout嵌套TextView来展示字母列表。思路如下：根据索引高度，大概计算每个字母的高度，然后添加到Linearlayout中；然后处理Linearlayout的touch事件，拿到坐标计算当前应该索引哪个。其中遇到的主要问题是对TextView的把握，比如它的高度如何计算？（真正实现的时候你会发现它有个paddingTop和paddingBottom）其他的比如滑动逻辑这些调试下即可，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238/** * 右侧字母索引。可作为一个独立的view插入自己的布局中&lt;br&gt; * &lt;br&gt; * 描述：&lt;br&gt; * 线型布局中嵌套一个线型布局（目的为了增大可滑动区域的面积，若不考虑此可不使用嵌套）。&lt;br&gt; * 每个字母插入内嵌的线性布局中，根据控件的高度计算每个字母的尺寸。&lt;br&gt; * &lt;br&gt; * 使用：&lt;br&gt; * 将此view插入你的布局文件中，初始化完成之后设置你的ListView和索引用的数据源(需要自己组织排序数据源)即可。&lt;br&gt; * &lt;br&gt; * 数据源的组织：若某项不参与排序则数据源中设置为'0'或其他小于'A'的ASCII字符，内部会将所有字符转换成大写，所以务必在外部做好排序。&lt;br&gt; * &lt;br&gt; * 建议：若你的数据中包括ASCII码为a0、20的字符，建议剔除，如：&lt;br&gt; * str.replace(' ', ' '); // a0-&gt;20 str.replaceAll(\" \", \"\");&lt;br&gt; * &lt;br&gt; * 如果你处理的是中文，可使用libs中的pinyin4j处理 * * @author ttdevs 2014-07-31 */public class ListViewLetterIndicator extends LinearLayout implements OnScrollListener &#123; private static final String INDICATOR = \"#ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; private LinearLayout llMain; private ListView mListView; // ListView private List&lt;String&gt; mData; // 数据源 private TextView tvAlert; // 显示当前的字母 private int mIndex; // 当前所处的indicator位置 private boolean scrollable = true; // public ListViewLetterIndicator(Context context) &#123; this(context, null); &#125; public ListViewLetterIndicator(Context context, AttributeSet attrs) &#123; super(context, attrs); setOrientation(LinearLayout.VERTICAL); setBackgroundColor(getResources().getColor(R.color.letter_indicator_background)); // setPadding(8, 8, 8, 8); llMain = new LinearLayout(getContext()); llMain.setOrientation(LinearLayout.VERTICAL); llMain.setGravity(Gravity.CENTER); // llMain.setPadding(2, 2, 2, 2); int width = (int) getResources().getDimension(R.dimen.letter_indicator_width); addView(llMain, width, LinearLayout.LayoutParams.MATCH_PARENT); &#125; /** * 设置数据源 * * @param lv 绑定的ListView * @param data 排序用的数据源 */ public void setData(ListView lv, List&lt;String&gt; data) &#123; setData(lv, data, null); &#125; /** * 设置数据源 * * @param lv 绑定的ListView * @param data 排序用的数据源 * @param tv 显示当前所处字母的TextView */ @SuppressLint(\"DefaultLocale\") public void setData(ListView lv, List&lt;String&gt; data, TextView tv) &#123; mListView = lv; mData = data; tvAlert = tv; for (int i = 0; i &lt; mData.size(); i++) &#123; String str = mData.get(i); mData.set(i, str.toUpperCase()); &#125; mListView.setOnScrollListener(this); mIndex = 0; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); initView(); &#125; private void initView() &#123; int childCount = llMain.getChildCount(); if (childCount == INDICATOR.length()) &#123; // llMain.invalidate(); return; &#125; int height = llMain.getHeight(); int textHeight = (int) Math.floor(height / (INDICATOR.length() + 6)); LinearLayout.LayoutParams llpText = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); for (int i = 0; i &lt; INDICATOR.length(); i++) &#123; String str = String.valueOf(INDICATOR.charAt(i)); TextView tvIndicator = new TextView(getContext()); tvIndicator.setText(str); tvIndicator.setIncludeFontPadding(false); tvIndicator.setTextSize(TypedValue.COMPLEX_UNIT_PX, textHeight); tvIndicator.setTextColor(getResources().getColor(R.color.letter_indicator_text_normal)); // tvIndicator.setPadding(0, -4, 0, -4); llMain.addView(tvIndicator, llpText); &#125; &#125; @SuppressLint(\"DefaultLocale\") @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: scrollable = false; float y = ev.getY(); float childY = 0; int index = 0; for (int i = 0; i &lt; INDICATOR.length(); i++) &#123; TextView view = (TextView) llMain.getChildAt(i); childY = view.getTop(); int height = view.getHeight(); if (childY &lt; y &amp;&amp; childY + height &gt; y) &#123; index = i; break; &#125; view = null; // not neccessary &#125; TextView view = (TextView) llMain.getChildAt(INDICATOR.length() - 1); if (y &gt; view.getTop()) &#123; index = INDICATOR.length() - 1; &#125; view = null; changeIndicatorColor(index); char indexIndicator = INDICATOR.charAt(index);// A:65, #:23 if (indexIndicator &lt; 'A') &#123; mListView.setSelection(0); &#125; else &#123; for (int i = 0; i &lt; mData.size(); i++) &#123; if (mData.get(i).charAt(0) &gt;= indexIndicator) &#123; mListView.setSelection(i); return true; &#125; &#125; &#125; break; case MotionEvent.ACTION_UP: postDelayed(new Runnable() &#123; @Override public void run() &#123; scrollable = true; &#125; &#125;, 100); showText(\"\", false); break; default: break; &#125; return true; &#125; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; // invalidate(); &#125; @SuppressLint(\"DefaultLocale\") @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; try &#123; if (!scrollable || null == mData || mData.size() == 0) &#123; return; &#125; if (null != mData) &#123; String str = mData.get(firstVisibleItem); char indicator = str.charAt(0); if (indicator &lt; 'A') &#123; changeIndicatorColor(0); return; &#125; for (int i = 1; i &lt; INDICATOR.length(); i++) &#123; if (INDICATOR.charAt(i) == indicator) &#123; changeIndicatorColor(i); return; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void changeIndicatorColor(int index) &#123; if (mIndex != 0 &amp;&amp; mIndex == index) &#123; return; &#125; TextView tv = (TextView) llMain.getChildAt(mIndex); tv.setTextColor(getResources().getColor(R.color.letter_indicator_text_normal)); tv = (TextView) llMain.getChildAt(index); tv.setTextColor(getResources().getColor(R.color.letter_indicator_text_select)); mIndex = index; showText(String.valueOf(INDICATOR.charAt(mIndex)), true); &#125; private void showText(String text, boolean isShow) &#123; if (null != tvAlert) &#123; tvAlert.setText(text); tvAlert.setVisibility(isShow ? View.VISIBLE : View.INVISIBLE); &#125; &#125; // private Drawable initBackground() &#123; // float[] roundRect = new float[] &#123; 12, 12, 12, 12, 12, 12, 12, 12 &#125;; // RoundRectShape reoundRechShape = new RoundRectShape(roundRect, null, // null); // ShapeDrawable drawable = new ShapeDrawable(reoundRechShape); // drawable.getPaint().setColor(Color.parseColor(GRAY_AA)); // // drawable.getPaint().setStyle(Paint.Style.FILL); // return drawable; // &#125;&#125; 测试过程中发现，有些item明明是汉字开头的（这个时候你可能还需要个汉字转拼音的工具包），却出现在“#”里，仔细检查，你会发现，那个并不是空格，细节请看代码注释。 由于很简单，不做详细介绍，仅仅做个记录，有问题可以留言一起讨论。 0x04 Demo最后附个测试demo： 下载","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」使用VideoView和MediaController进行视频播放","slug":"[Android]使用VideoView和MediaController进行视频播放","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]使用VideoView和MediaController进行视频播放/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]使用VideoView和MediaController进行视频播放/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 视频播放的activity&lt;br&gt; * 使用方法：&lt;br&gt; * 1、AndroidManifest.xml中添加此activity&lt;br&gt; * 2、Intent中存入待播放视频的URL，支持本地和网络&lt;br&gt; * 3、启动这个activity&lt;br&gt; * &lt;br&gt; * example：&lt;br&gt; * String url = \"play url\";&lt;br&gt; * Intent intent = new Intent();&lt;br&gt; * intent.setClass(this, VideoPlayActivity.class);&lt;br&gt; * intent.putExtra(VideoPlayActivity.KEY_URL, url);&lt;br&gt; * startActivity(intent);&lt;br&gt; * * @author ttworking */public class VideoPlayActivity extends Activity implements OnPreparedListener, OnErrorListener &#123; public static final String KEY_URL = \"view_url\"; private static final String TAG = \"VideoPlayActivity\"; private static final int PLAY_RETURN = 2 * 1000; // 2 seconds private static final String KEY_PLAY_POSITON = \"paly_position\"; private static final String TOAST_ERROR_URL = \"Paly url is null, please check parameter:\" + KEY_URL; private static final String TOAST_ERROR_PLAY = \"Paly error, please check url exist!\"; private static final String DIALOG_TITILE = \"奋力加载中，请稍后...\"; private static String url; private ProgressDialog progressDialog; private MediaController mc; private VideoView videoView; private LinearLayout llMain; private LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); url = getIntent().getStringExtra(KEY_URL); if (url == null &amp;&amp; savedInstanceState != null) &#123; url = savedInstanceState.getString(KEY_URL); &#125; if (url == null) &#123; Toast.makeText(getApplicationContext(), TOAST_ERROR_URL, Toast.LENGTH_LONG).show(); finish(); return; &#125; setTheme(android.R.style.Theme_NoTitleBar_Fullscreen); videoView = new VideoView(this); videoView.setVideoURI(Uri.parse(url)); videoView.requestFocus(); videoView.setOnPreparedListener(this); videoView.setOnErrorListener(this); mc = new MediaController(this); mc.setAnchorView(videoView); mc.setKeepScreenOn(true); videoView.setMediaController(mc); llMain = new LinearLayout(this); llMain.setGravity(Gravity.CENTER_VERTICAL); llMain.setOrientation(LinearLayout.VERTICAL); llMain.setLayoutParams(params); llMain.addView(videoView, params); setContentView(llMain); initDialog(); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); int palyPosition = videoView.getCurrentPosition(); if (palyPosition &gt; PLAY_RETURN) &#123; palyPosition -= PLAY_RETURN; &#125; outState.putInt(KEY_PLAY_POSITON, palyPosition); outState.putString(KEY_URL, url); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); videoView.seekTo(savedInstanceState.getInt(KEY_PLAY_POSITON)); &#125; @Override public void onPrepared(MediaPlayer mp) &#123; progressDialog.cancel(); videoView.start(); &#125; @Override public boolean onError(MediaPlayer mp, int what, int extra) &#123; Log.d(TAG, \"onError:\" + url); Toast.makeText(getApplicationContext(), TOAST_ERROR_PLAY + \"\\n\" + url, Toast.LENGTH_LONG).show(); progressDialog.cancel(); finish(); return true; &#125; private void initDialog() &#123; progressDialog = new ProgressDialog(this); progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); progressDialog.setMessage(DIALOG_TITILE); progressDialog.setCancelable(false); progressDialog.show(); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」内存泄漏相关内容总结(上)","slug":"[Android]内存泄漏相关内容总结(上)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]内存泄漏相关内容总结(上)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]内存泄漏相关内容总结(上)/","excerpt":"","text":"0x00 忏悔好久没有认真的写博客了，草稿箱中静静躺着好几篇，但总是不能把他们写完，一直没有写的心情把，罪过… 废话一句说完，进入今天的正题：内存泄露的相关知识。 0x01 内存问题很多时候我们是需要查看自己的应用内存占用情况，比如当出现闪退，异常退出时： 界面内存占用：比如我们的启动画面，如果出现OOM的问题，这个时候可以通过差看内存情况，如果确是内存占用比较大就可以考虑做相应优化 内存泄漏的初步查找：这个和直接的OOM有些差别，虽然他最终也会导致OOM。方法：反复打开、关闭可能内存泄漏的界面，如果每次打开关闭之后内存都有所增加，就可以初步判断为内存泄漏。正常情况应用是进入界面内存占用有所增加，但是离开后内存会降到之前的水平。 0x02 内存泄漏与内存溢出(OOM)的区别与联系内存溢出做android开发的各位应该是比较熟悉，图片加载稍微不小心就会导致out of memory的错误，这个错误出现的原因就是我们的应用去申请内存时系统无法再分配导致的。所以我们需要有节制的使用内存。 和C++相比，java的一个很大特点就是有GC，我们不需要去专注内存的释放与回收。但是，这也不是绝对的：当我们的代码出现问题导致GC无法及时的回收相关的内存时就会导致内存泄漏。这句不算太规范的描述（语文太差，见谅）他的重点是什么呢——GC无法及时的回收相关内存——这将导致我们的内存占用越来越多——最终的体现就是OOM。 希望这个简单的描述，各位可以理解什么是memory leak和OOM。 0x03 DDMS 给我们的提示 logcat中的信息 关于内存的信息，logcat会给我们一些提示信息，比如： 1D/dalvikvm( 9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms 这行信息怎么理解？它包含哪些信息呢？通过 DDMS的文档 我们可以得知这个信息的格式如下： 1D/dalvikvm(dvm pid): &lt;GC_Reason&gt; &lt;Amount_freed&gt;, &lt;Heap_stats&gt;, &lt;External_memory_stats&gt;, &lt;Pause_time&gt; 这行信息我们主要关注的是：GC_Reason，他主要有下面几种： GC_CONCURRENT() A concurrent garbage collection that frees up memory as your heap begins to fill up. GC_FOR_MALLOC(当我们的应用申请内存时触发) A garbage collection caused because your app attempted to allocate memory when your heap was already full, so the system had to stop your app and reclaim memory. GC_HPROF_DUMP_HEAP() A garbage collection that occurs when you create an HPROF file to analyze your heap. GC_EXPLICIT(当我们手动点击DDMS&gt;heap&gt;Cause GC按钮时会触发) An explicit garbage collection, such as when you call gc() (which you should avoid calling and instead trust the garbage collector to run when needed). GC_EXTERNAL_ALLOC() This happens only on API level 10 and lower (newer versions allocate everything in the Dalvik heap). A garbage collection for externally allocated memory (such as the pixel data stored in native memory or NIO byte buffers). 当我们在app在出现问题时可以根据这些信息做初步判断。比如频繁出现GC_FOR_AMLLOC则预示着我们一直在申请内存。 heap页签的内存信息 通过这个工具这个我们可以更详细的看到内存的分配与使用。启动方法： 点击DDMS中我们的进程 &gt; 上部的Update heap按钮 &gt; Cause GC 即可，如下图： 0x04 通过内存快照更精准的查找内存信息当我们出现内存泄漏问题是，初学者可能会一头雾水，不知道如何解决，从何下手。这个时候我们就可以考虑使用mat对我们的内存进行详细的分析，找到内存泄漏点，做相应的处理。 Shallow size 和 Retained Size 在进行内存分析之前我们需要首先了解这两个概念。 Shallow size Shallow size就是对象本身占用内存的大小，不包含其引用的对象。常规对象（非数组）的Shallow size有其成员变量的数量和类型决定。数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定。Shallow size of a set of objects represents the sum of shallow sizes of all objects in the set.在32位系统上，对象头占用8字节，int占用4字节，不管成员变量（对象或数组）是否引用了其他对象（实例）或者赋值为null它始终占用4字节。故此，对于String对象实例来说，它有三个int成员（34=12字节）、一个char[]成员（14=4字节）以及一个对象头（8字节），总共34+14+8=24字节。根据这一原则，对String a=”rosen jiang”来说，实例a的shallow size也是24字节。 Retained Size Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)。换句话说，Retained Size 就是当前对象被GC后，从Heap上总共能释放掉的内存。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。为了更好的理解retained size，不妨看个例子。把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain的起点。 从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。 所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。 对于obj2，它的retained size是：在左图中，是obj2和obj4的shallow size的和；在右图中，是obj2、obj3和obj4的shallow size的和。 总之，retained size是一个整体度量，有助于理解内存结构和对象图中的依赖关系并找到根节点。 HPROF file——内存快照文件 首先这个文件可以通过点击 DDMS 中 Update heap 右侧的 Dump HPROF file 得到（这个有时候可能会比较慢，特别是内存占用高的时候，需要等一会，出现hprof: dumping heap strings to “[DDMS]”.即代表已经触发）。 得到这个文件之后，我们还需要使用SDK的platform-tools文件夹下的“hprof-conv”工具进行转换，然后就可以使用内存分析工具查看了。转换方法： hprof-conv heap-original.hprof heap-converted.hprof 0x05 内存分析工具MAT这个是专门做内存分析的工具。通过它我们可以打开刚才转换后的到hprof文件，进行内存分析。每次都点击保存，转换，然后打开还是比较麻烦的。这个时候我们可以考虑使用eclipse的mat插件。 这篇就先写到这里。下一篇简单介绍如何通过MAT查找内存泄漏的问题。 0xFF 参考 https://developer.android.com/tools/debugging/debugging-memory.html http://blog.csdn.net/kingzone_2008/article/details/9083327 http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fshallowretainedheap.html&amp;resultof=%22Shallow%22%20%22shallow%22%20%22size%22%20","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」对App进行代码混淆","slug":"[Android]对App进行代码混淆","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]对App进行代码混淆/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]对App进行代码混淆/","excerpt":"","text":"接到一个新的任务，对现有项目进行代码混淆。之前对混淆有过一些了解，但是不够详细和完整，知道有些东西混淆起来还是比较棘手的。不过幸好目前的项目不是太复杂（针对混淆这块来说），提前完成～～ 现总结之。 0x01 第一部分介绍下操作流程（eclipse）： 打开混淆器 找到项目根目录下的 project.properties 文件 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt 将上面这行前的 # 删除即可 修改混淆配置文件 找到项目根目录下的 proguard-project.txt 文件，修改其中代码，这部分是最关键 保存相关文件供以后出错时使用 主要有导出的apk文件、项目根目录下的proguard目录下的文件（主要的是mapping.txt）和项目源码 项目运行过程出错处理 根据错误信息和第3步中保存的mapping定位错误位置 知道这些之后，我们对其进行展开。 打开eclipse然后新建一个项目，默认会创建 proguard-project.txt 和project.properties。编写我们的代码，修改 proguard-project.txt ： #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt :proguard-project.txt 将这行前的 # 删除，最后导出即可实现对代码的混淆（即使我们没有去编写proguard-project.txt中的内容）。下面是我的测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends Activity &#123; private String mName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mName = \"ttdevs\"; getString(mName); setName(mName); showDialog(); // testError(); &#125; public String getString(String name) &#123; return \"hello \" + name; &#125; public void setName(String name) &#123; System.out.println(\"I'm \" + name); &#125; private void showDialog() &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; ScoreAlertDialog.showDialog(MainActivity.this); &#125; &#125;, 2000); &#125; public static class ScoreAlertDialog &#123; public static void showDialog(final Activity activity) &#123; if (activity.isFinishing()) &#123; return; &#125; try &#123; AlertDialog.Builder builder = new AlertDialog.Builder(activity); builder.setTitle(\"alert_title\"); builder.setNegativeButton(\"cancel\", null); builder.setPositiveButton(\"submit\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; try &#123; Toast.makeText(activity, \"Welcome\", Toast.LENGTH_LONG).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); builder.show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void testError() &#123; try &#123; int error = 1 / 0; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打包，反编译，最后我们得到如下的代码： 分析上面的代码我们会发现，自定义的方法名都被替换成无特殊意义的短字母，而activity的onCreate()方法却没变；最后一个testError()方法由于我们没有调用也被剔除掉了。这些就是默认的混淆处理策略。看到这里，感觉混淆还是小case的哈～～ 继续往下，我们将注销的testError()打开，打包运行这个时候会报错，错误信息如下： 1234567891011121314151617java.lang.ArithmeticException: divide by zero at com.ttdevs.proguard.MainActivity.b(Unknown Source) at com.ttdevs.proguard.MainActivity.onCreate(Unknown Source) at android.app.Activity.performCreate(Activity.java:4531) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2150) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2229) at android.app.ActivityThread.access$600(ActivityThread.java:139) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1261) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:4945) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:511) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551) at dalvik.system.NativeStart.main(Native Method) 由于这个例子比较简单，很容易看出来是何地方出了问题，不过还是可以用来说明我们想表达的问题：如何还原混淆后的代码的错误信息？为了达到这个目的，我们需要三个文件: android-sdk-windows\\tools\\proguard\\bin\\retrace.bat mapping.txt log.info（上面的错误信息） 然后执行下面的命令（window系统） retrace.bat mapping.txt log.txt 从上图中可以很清楚的看到错误日志中的b()方法为我们实际代码中的setName()方法。 这里需要注意的是每次导出apk都会在项目中目录下的proguard文件夹下生成一个对应的mapping.txt 文件，所以对于每个apk我们都需要保存与之对应的mapping.txt文件。至此整个混淆的流程介绍完毕。 参考 官方文档 http://developer.android.com/tools/help/proguard.html 官方文档的翻译 http://www.cnblogs.com/over140/archive/2011/04/22/2024528.html （本想自己去翻一个，结果发现很久以前农民伯伯已经翻译，在此直接引用并感谢之） 0x02 第二部分第一部分讲了如何操作，参照官方文档，基本都会掌握。剩下的也是最难的就是 proguard-project.txt 文件的编写。对于这部分，两种处理策略：自己编写和使用别人写好的。先说如何使用别人写好的，我们引用的第三方库无论开源还是闭源如有特殊情况我们都可以在他的User Guide中找到混淆代码的配置，如我们引用的大名鼎鼎的 guillep PullToRefresh ，我们可以在他的文档 中找到如下的代码： 123456789101112131415161718192021222324252627282930313233343536-optimizationpasses 5-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-dontpreverify-verbose-optimizations !code/simplification/arithmetic,!field/*,!class/merging/* -keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class com.android.vending.licensing.ILicensingService -keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; -keepclasseswithmembernames class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet);&#125; -keepclasseswithmembernames class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; -keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; -keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; 有了这部分代码我们就可以直接copy插入我们的项目中即可。这种方式还是copy式的。那下面我们举个小例子看看如何自己写代码控制是否混淆。还是用第一部分的例子，我们在这个项目的 proguard-project.txt 文件中（之前为空）加入如下几行（proguard-project.txt中“#”代表注释）： 123456# -keep public class com.ttdevs.proguard.** &#123; *; &#125;# -keepclasseswithmembers public class com.ttdevs.proguard.** &#123; *; &#125; -keep public class com.ttdevs.proguard.MainActivity &#123;java.lang.String getString(java.lang.String);&#125; 然后我们导出apk再反编译，得到如下代码： 和之前的对比，我们发现其中的getString方法没有被混淆。没错，上面 proguard-project.txt的意思就是保持MainActivity的getString()方法不要被混淆。大家也可以试试上述混淆代码中被注释的两行分别是什么效果。 讲到这里已经开始涉及ProGuard的核心部分了，剩下的就是研读 ProGuard的文档 ，掌握的他的语法并使用之。本想找一个完整的ProGuard的翻译文档，但是找了N久没有发现一个，而且连零零散散的翻译也非常的少，最近时间很紧，加之能力有限，想翻译一下常用的几个命令也是很困，所以细读的想法只能暂时往后推了。这里先简单介绍下keep命令： -keep [,modifier,…] class_specification 在你的代码中指定作为切入点而被保留的类或者类的成员（属性和方法）。例如，为了保持一个应用，你可以指定主类和他的main方法。为了处理一个库，你需要详细说明他的public访问的元素。 另外还有keep的简单概述 和 语法中规范 。 Class Specification中会告诉你如何表示构造方法，属性和方法，* 与**的区别等等。比如 * 表示匹配任何的类名但是不包括包的分隔符，而 ** 则是匹配任何的类名并且包括任意数量的包分隔符，因此上面我们注释掉的代码意思如下： 第一行 保持com.ttdevs.proguard下的所有类和子包下的类的所有方法都不混淆 第二行 保持com.ttdevs.proguard下的所有类和子包下的类的所有方法和成员变量都不混淆。 // TODO 细节还有很多，比如-libraryjars、-dontwarn、-keepattributes等等，这些待续吧 参考 ProGuard 5.0 ProGuard 5.0 ProGuard 4.7 ProGuard 4.7","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」滚轮刻度尺的实现","slug":"[Android]滚轮刻度尺的实现","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]滚轮刻度尺的实现/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]滚轮刻度尺的实现/","excerpt":"","text":"0x00 滚轮刻度尺（卷尺）遇到下面这样一个需求： 0x01 问题分析卷尺，通过左右滑动来选择不同的刻度值。这方面的东西以前没弄过，以目前你的能力，想了几种思路都死在了半路上。比如上面的刻度线如何弄，滑动的时候又该如何弄；下面的数字又如何弄；看起来像圆圈的效果该如何弄。时间紧迫，就俩晚上的时间。没有好的思路就参考别人的先吧，说来也巧，两天前刚看过一个日期选择控件，还有以前看的一个仿iPhone滚动控件 ，效果类似： 本想找作者傲慢的上校交流下，但是时间比较紧，源码都给了也不是很好意思。大致的浏览了下，可能涉及下面几个东西： 背景：这个用shape实现。之前有研究过，也用过，但是还没实现过要求的效果 刻度和数字：这个就不要乱想了，直接draw。相对来说还是比较简单的，就是画直线和字 滚动：滚动的时候不停的重绘实现一个滚动的效果。弄过，但是不确定实现的是啥样的效果 快速滚动：Scroller和VelocityTracker可能是需要用到的东西。几乎完全没弄过，骚年，学习吧（需求的要求中，这个优先级可以最低） 需求：刻度的单位是可以变的，比如十格一个单位，或者两格一个单位，在或者可以是任意的（这个前期思路没想好，实现起来就困难了，最后只弄了两种） 其实，到了这一步基本上就已经可以实现了，看个最终效果先： 0x02 实现下面一步一步来。 在这之前还有个地方要说的，就是控件的接口：对外提供一个方法实现控件初始化和接收控件选择的值：显示的单位，最大值，最小值，当前值，回调接口。有了这些，先从最难的入手。 实现刻度和数字，并可以滑动 这个地方很关键，每个人有每个人的思路，而且思路的好坏直接影响到后面对不同单位的实现。目前的思路是根据当前显示的数值mValue，从控件中间向两边画刻度线，滑动的时候同时改变显示的值mValue，不足最小刻度的四舍五入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawScaleLine(canvas); // drawWheel(canvas); drawMiddleLine(canvas);&#125;private void drawWheel(Canvas canvas) &#123; Drawable wheel = getResources().getDrawable(R.drawable.bg_wheel); wheel.setBounds(0, 0, getWidth(), getHeight()); wheel.draw(canvas);&#125;/*** 从中间往两边开始画刻度线** @param canvas*/private void drawScaleLine(Canvas canvas) &#123; canvas.save(); Paint linePaint = new Paint(); linePaint.setStrokeWidth(2); linePaint.setColor(Color.BLACK); TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG); textPaint.setTextSize(TEXT_SIZE * mDensity); int width = mWidth, drawCount = 0; float xPosition = 0, textWidth = Layout.getDesiredWidth(\"0\", textPaint); for (int i = 0; drawCount &lt;= 4 * width; i++) &#123; int numSize = String.valueOf(mValue + i).length(); xPosition = (width / 2 - mMove) + i * mLineDivider * mDensity; if (xPosition + getPaddingRight() &lt; mWidth) &#123; if ((mValue + i) % mModType == 0) &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MAX_HEIGHT, linePaint); if (mValue + i &lt;= mMaxValue) &#123; switch (mModType) &#123; case MOD_TYPE_HALF: canvas.drawText(String.valueOf((mValue + i) / 2), countLeftStart(mValue + i, xPosition, textWidth), getHeight() - textWidth, textPaint); break; case MOD_TYPE_ONE: canvas.drawText(String.valueOf(mValue + i), xPosition - (textWidth * numSize / 2), getHeight() - textWidth, textPaint); break; default: break; &#125; &#125; &#125; else &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MIN_HEIGHT, linePaint); &#125; &#125; xPosition = (width / 2 - mMove) - i * mLineDivider * mDensity; if (xPosition &gt; getPaddingLeft()) &#123; if ((mValue - i) % mModType == 0) &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MAX_HEIGHT, linePaint); if (mValue - i &gt;= 0) &#123; switch (mModType) &#123; case MOD_TYPE_HALF: canvas.drawText(String.valueOf((mValue - i) / 2), countLeftStart(mValue - i, xPosition, textWidth), getHeight() - textWidth, textPaint); break; case MOD_TYPE_ONE: canvas.drawText(String.valueOf(mValue - i), xPosition - (textWidth * numSize / 2), getHeight() - textWidth, textPaint); break; default: break; &#125; &#125; &#125; else &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MIN_HEIGHT, linePaint); &#125; &#125; drawCount += 2 * mLineDivider * mDensity; &#125; canvas.restore();&#125; 滑动的加速问题 这里用到两个类Scroller和VelocityTracker，关于这两个类之后有机会会详细介绍，这里简单提下：VelocityTracker的作用是在用户加速滑动时计算该滑动多远，拿到这个之后通过Scroller来执行滑动过程的计算，最后是真实的“移动”——根据mValue的值进行重绘： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); int xPosition = (int) event.getX(); if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(event); switch (action) &#123; case MotionEvent.ACTION_DOWN: mScroller.forceFinished(true); mLastX = xPosition; mMove = 0; break; case MotionEvent.ACTION_MOVE: mMove += (mLastX - xPosition); changeMoveAndValue(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: countMoveEnd(); countVelocityTracker(event); return false; // break; default: break; &#125; mLastX = xPosition; return true;&#125;private void countVelocityTracker(MotionEvent event) &#123; mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt; mMinVelocity) &#123; mScroller.fling(0, 0, (int) xVelocity, 0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, 0); &#125;&#125;private void changeMoveAndValue() &#123; int tValue = (int) (mMove / (mLineDivider * mDensity)); if (Math.abs(tValue) &gt; 0) &#123; mValue += tValue; mMove -= tValue * mLineDivider * mDensity; if (mValue &lt;= 0 || mValue &gt; mMaxValue) &#123; mValue = mValue &lt;= 0 ? 0 : mMaxValue; mMove = 0; mScroller.forceFinished(true); &#125; notifyValueChange(); &#125; postInvalidate();&#125;private void countMoveEnd() &#123; int roundMove = Math.round(mMove / (mLineDivider * mDensity)); mValue = mValue + roundMove; mValue = mValue &lt;= 0 ? 0 : mValue; mValue = mValue &gt; mMaxValue ? mMaxValue : mValue; mLastX = 0; mMove = 0; notifyValueChange(); postInvalidate();&#125;private void notifyValueChange() &#123; if (null != mListener) &#123; if (mModType == MOD_TYPE_ONE) &#123; mListener.onValueChange(mValue); &#125; if (mModType == MOD_TYPE_HALF) &#123; mListener.onValueChange(mValue / 2f); &#125; &#125;&#125;@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; if (mScroller.getCurrX() == mScroller.getFinalX()) &#123; // over countMoveEnd(); &#125; else &#123; int xPosition = mScroller.getCurrX(); mMove += (mLastX - xPosition); changeMoveAndValue(); mLastX = xPosition; &#125; &#125;&#125; 圆圈背景的实现 这个用shape来做，可以使用setBackgroundDrawable()来做，也可以在draw中进行直接绘制，效果相同。还有一些细节问题，比如滑动时刻度线超过边界，滑动距离大时候显示不完整等问题，这个只有做了才会发现。下面是shape背景的代码： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" &gt; &lt;!-- two set color way --&gt; &lt;gradient android:angle=\"0\" android:centerColor=\"#66FFFFFF\" android:endColor=\"#66AAAAAA\" android:startColor=\"#66AAAAAA\" /&gt; &lt;corners android:radius=\"6dp\" /&gt; &lt;stroke android:width=\"6dp\" android:color=\"#FF666666\" /&gt; &lt;/shape&gt; 用代码可以这样写： 12345678910111213141516private GradientDrawable createBackground() &#123; float strokeWidth = 4 * mDensity; // 边框宽度 float roundRadius = 6 * mDensity; // 圆角半径 int strokeColor = Color.parseColor(\"#FF666666\");// 边框颜色 // int fillColor = Color.parseColor(\"#DFDFE0\");// 内部填充颜色 setPadding((int) strokeWidth, (int) strokeWidth, (int) strokeWidth, 0); int colors[] = &#123;0xFF999999, 0xFFFFFFFF, 0xFF999999&#125;;// 分别为开始颜色，中间夜色，结束颜色 GradientDrawable bgDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, colors);// 创建drawable // bgDrawable.setColor(fillColor); bgDrawable.setCornerRadius(roundRadius); bgDrawable.setStroke((int) strokeWidth, strokeColor); // setBackgroundDrawable(gd); return bgDrawable;&#125; 0x03 完整的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373package com.ttdevs.wheel.widget;/** * 卷尺控件类。由于时间比较紧，只有下班后有时间，因此只实现了基本功能。&lt;br&gt; * 细节问题包括滑动过程中widget边缘的刻度显示问题等&lt;br&gt; * &lt;p&gt; * 周末有时间会继续更新&lt;br&gt; * * @author ttdevs * @version create：2014年8月26日 */@SuppressLint(\"ClickableViewAccessibility\")public class TuneWheel extends View &#123; public interface OnValueChangeListener &#123; public void onValueChange(float value); &#125; public static final int MOD_TYPE_HALF = 2; public static final int MOD_TYPE_ONE = 10; private static final int ITEM_HALF_DIVIDER = 40; private static final int ITEM_ONE_DIVIDER = 10; private static final int ITEM_MAX_HEIGHT = 50; private static final int ITEM_MIN_HEIGHT = 20; private static final int TEXT_SIZE = 18; private float mDensity; private int mValue = 50, mMaxValue = 100, mModType = MOD_TYPE_HALF, mLineDivider = ITEM_HALF_DIVIDER; // private int mValue = 50, mMaxValue = 500, mModType = MOD_TYPE_ONE, // mLineDivider = ITEM_ONE_DIVIDER; private int mLastX, mMove; private int mWidth, mHeight; private int mMinVelocity; private Scroller mScroller; private VelocityTracker mVelocityTracker; private OnValueChangeListener mListener; @SuppressWarnings(\"deprecation\") public TuneWheel(Context context, AttributeSet attrs) &#123; super(context, attrs); mScroller = new Scroller(getContext()); mDensity = getContext().getResources().getDisplayMetrics().density; mMinVelocity = ViewConfiguration.get(getContext()).getScaledMinimumFlingVelocity(); // setBackgroundResource(R.drawable.bg_wheel); setBackgroundDrawable(createBackground()); &#125; private GradientDrawable createBackground() &#123; float strokeWidth = 4 * mDensity; // 边框宽度 float roundRadius = 6 * mDensity; // 圆角半径 int strokeColor = Color.parseColor(\"#FF666666\");// 边框颜色 // int fillColor = Color.parseColor(\"#DFDFE0\");// 内部填充颜色 setPadding((int) strokeWidth, (int) strokeWidth, (int) strokeWidth, 0); int colors[] = &#123;0xFF999999, 0xFFFFFFFF, 0xFF999999&#125;;// 分别为开始颜色，中间夜色，结束颜色 GradientDrawable bgDrawable = new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, colors);// 创建drawable // bgDrawable.setColor(fillColor); bgDrawable.setCornerRadius(roundRadius); bgDrawable.setStroke((int) strokeWidth, strokeColor); // setBackgroundDrawable(gd); return bgDrawable; &#125; /** * 考虑可扩展，但是时间紧迫，只可以支持两种类型效果图中两种类型 * * @param value 初始值 * @param maxValue 最大值 * @param model 刻度盘精度：&lt;br&gt; * &#123;@link MOD_TYPE_HALF&#125;&lt;br&gt; * &#123;@link MOD_TYPE_ONE&#125;&lt;br&gt; */ public void initViewParam(int defaultValue, int maxValue, int model) &#123; switch (model) &#123; case MOD_TYPE_HALF: mModType = MOD_TYPE_HALF; mLineDivider = ITEM_HALF_DIVIDER; mValue = defaultValue * 2; mMaxValue = maxValue * 2; break; case MOD_TYPE_ONE: mModType = MOD_TYPE_ONE; mLineDivider = ITEM_ONE_DIVIDER; mValue = defaultValue; mMaxValue = maxValue; break; default: break; &#125; invalidate(); mLastX = 0; mMove = 0; notifyValueChange(); &#125; /** * 设置用于接收结果的监听器 * * @param listener */ public void setValueChangeListener(OnValueChangeListener listener) &#123; mListener = listener; &#125; /** * 获取当前刻度值 * * @return */ public float getValue() &#123; return mValue; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; mWidth = getWidth(); mHeight = getHeight(); super.onLayout(changed, left, top, right, bottom); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawScaleLine(canvas); // drawWheel(canvas); drawMiddleLine(canvas); &#125; private void drawWheel(Canvas canvas) &#123; Drawable wheel = getResources().getDrawable(R.drawable.bg_wheel); wheel.setBounds(0, 0, getWidth(), getHeight()); wheel.draw(canvas); &#125; /** * 从中间往两边开始画刻度线 * * @param canvas */ private void drawScaleLine(Canvas canvas) &#123; canvas.save(); Paint linePaint = new Paint(); linePaint.setStrokeWidth(2); linePaint.setColor(Color.BLACK); TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG); textPaint.setTextSize(TEXT_SIZE * mDensity); int width = mWidth, drawCount = 0; float xPosition = 0, textWidth = Layout.getDesiredWidth(\"0\", textPaint); for (int i = 0; drawCount &lt;= 4 * width; i++) &#123; int numSize = String.valueOf(mValue + i).length(); xPosition = (width / 2 - mMove) + i * mLineDivider * mDensity; if (xPosition + getPaddingRight() &lt; mWidth) &#123; if ((mValue + i) % mModType == 0) &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MAX_HEIGHT, linePaint); if (mValue + i &lt;= mMaxValue) &#123; switch (mModType) &#123; case MOD_TYPE_HALF: canvas.drawText(String.valueOf((mValue + i) / 2), countLeftStart(mValue + i, xPosition, textWidth), getHeight() - textWidth, textPaint); break; case MOD_TYPE_ONE: canvas.drawText(String.valueOf(mValue + i), xPosition - (textWidth * numSize / 2), getHeight() - textWidth, textPaint); break; default: break; &#125; &#125; &#125; else &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MIN_HEIGHT, linePaint); &#125; &#125; xPosition = (width / 2 - mMove) - i * mLineDivider * mDensity; if (xPosition &gt; getPaddingLeft()) &#123; if ((mValue - i) % mModType == 0) &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MAX_HEIGHT, linePaint); if (mValue - i &gt;= 0) &#123; switch (mModType) &#123; case MOD_TYPE_HALF: canvas.drawText(String.valueOf((mValue - i) / 2), countLeftStart(mValue - i, xPosition, textWidth), getHeight() - textWidth, textPaint); break; case MOD_TYPE_ONE: canvas.drawText(String.valueOf(mValue - i), xPosition - (textWidth * numSize / 2), getHeight() - textWidth, textPaint); break; default: break; &#125; &#125; &#125; else &#123; canvas.drawLine(xPosition, getPaddingTop(), xPosition, mDensity * ITEM_MIN_HEIGHT, linePaint); &#125; &#125; drawCount += 2 * mLineDivider * mDensity; &#125; canvas.restore(); &#125; /** * 计算没有数字显示位置的辅助方法 * * @param value * @param xPosition * @param textWidth * @return */ private float countLeftStart(int value, float xPosition, float textWidth) &#123; float xp = 0f; if (value &lt; 20) &#123; xp = xPosition - (textWidth * 1 / 2); &#125; else &#123; xp = xPosition - (textWidth * 2 / 2); &#125; return xp; &#125; /** * 画中间的红色指示线、阴影等。指示线两端简单的用了两个矩形代替 * * @param canvas */ private void drawMiddleLine(Canvas canvas) &#123; // TOOD 常量太多，暂时放这，最终会放在类的开始，放远了怕很快忘记 int gap = 12, indexWidth = 8, indexTitleWidth = 24, indexTitleHight = 10, shadow = 6; String color = \"#66999999\"; canvas.save(); Paint redPaint = new Paint(); redPaint.setStrokeWidth(indexWidth); redPaint.setColor(Color.RED); canvas.drawLine(mWidth / 2, 0, mWidth / 2, mHeight, redPaint); Paint ovalPaint = new Paint(); ovalPaint.setColor(Color.RED); ovalPaint.setStrokeWidth(indexTitleWidth); canvas.drawLine(mWidth / 2, 0, mWidth / 2, indexTitleHight, ovalPaint); canvas.drawLine(mWidth / 2, mHeight - indexTitleHight, mWidth / 2, mHeight, ovalPaint); // RectF ovalRectF = new RectF(mWidth / 2 - 10, 0, mWidth / 2 + 10, 4 * // mDensity); //TODO 椭圆 // canvas.drawOval(ovalRectF, ovalPaint); // ovalRectF.set(mWidth / 2 - 10, mHeight - 8 * mDensity, mWidth / 2 + // 10, mHeight); //TODO Paint shadowPaint = new Paint(); shadowPaint.setStrokeWidth(shadow); shadowPaint.setColor(Color.parseColor(color)); canvas.drawLine(mWidth / 2 + gap, 0, mWidth / 2 + gap, mHeight, shadowPaint); canvas.restore(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); int xPosition = (int) event.getX(); if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(event); switch (action) &#123; case MotionEvent.ACTION_DOWN: mScroller.forceFinished(true); mLastX = xPosition; mMove = 0; break; case MotionEvent.ACTION_MOVE: mMove += (mLastX - xPosition); changeMoveAndValue(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: countMoveEnd(); countVelocityTracker(event); return false; // break; default: break; &#125; mLastX = xPosition; return true; &#125; private void countVelocityTracker(MotionEvent event) &#123; mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt; mMinVelocity) &#123; mScroller.fling(0, 0, (int) xVelocity, 0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, 0); &#125; &#125; private void changeMoveAndValue() &#123; int tValue = (int) (mMove / (mLineDivider * mDensity)); if (Math.abs(tValue) &gt; 0) &#123; mValue += tValue; mMove -= tValue * mLineDivider * mDensity; if (mValue &lt;= 0 || mValue &gt; mMaxValue) &#123; mValue = mValue &lt;= 0 ? 0 : mMaxValue; mMove = 0; mScroller.forceFinished(true); &#125; notifyValueChange(); &#125; postInvalidate(); &#125; private void countMoveEnd() &#123; int roundMove = Math.round(mMove / (mLineDivider * mDensity)); mValue = mValue + roundMove; mValue = mValue &lt;= 0 ? 0 : mValue; mValue = mValue &gt; mMaxValue ? mMaxValue : mValue; mLastX = 0; mMove = 0; notifyValueChange(); postInvalidate(); &#125; private void notifyValueChange() &#123; if (null != mListener) &#123; if (mModType == MOD_TYPE_ONE) &#123; mListener.onValueChange(mValue); &#125; if (mModType == MOD_TYPE_HALF) &#123; mListener.onValueChange(mValue / 2f); &#125; &#125; &#125; @Override public void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; if (mScroller.getCurrX() == mScroller.getFinalX()) &#123; // over countMoveEnd(); &#125; else &#123; int xPosition = mScroller.getCurrX(); mMove += (mLastX - xPosition); changeMoveAndValue(); mLastX = xPosition; &#125; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」用support annotation替代enum","slug":"[Android]用support annotation替代enum","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]用support annotation替代enum/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]用support annotation替代enum/","excerpt":"","text":"Allocation.MipmapControl,Authenticator.RequestorType,AvoidXfermode.Mode,Bitmap.CompressFormat,Bitmap.Config, BlurMaskFilter.Blur,Canvas.EdgeType,Canvas.VertexMode,ClientInfoStatus,ConsoleMessage.MessageLevel,CursorJoiner.Result,and 48 others. 简单看了下，Android还是有好多地方使用了。那为什么还不建议使用呢？查了一番，看到google官方有一段关于enum使用的介绍。既然使用不当可能会导致性能问题，那我们怎么办呢？ 这里介绍下Support包中的annotation，使用 @IntDef 和 @StringDef 来达到我们枚举的效果。由于@IntDef 的介绍比较多，这里给个@StringDef 的Demo： 12345678910111213141516public class MyClient &#123; public static final String ONE = \"one\"; public static final String RECORD = \"record\"; public static final String STATUS = \"status\"; @StringDef(&#123;ONE, RECORD, STATUS&#125;) public @interface Client &#123; &#125; private String mClient; public MyClient(@Client String client) &#123; mClient = client; &#125; ...&#125; 这样，在外面创建MyClient对象的时候，构造方法中传入的参数就必须为 ONE, RECORD, STATUS 其中之一，从而达到类似enum的效果。 参考 https://noobcoderblog.wordpress.com/2015/04/12/java-enum-and-android-intdefstringdef-annotation/ The price of ENUMs http://tools.android.com/tech-docs/support-annotations http://developer.android.com/reference/java/lang/Enum.html http://stackoverflow.com/questions/29183904/should-i-strictly-avoid-using-enums-on-android","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」各种小记录","slug":"[Android]各种小记录","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]各种小记录/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]各种小记录/","excerpt":"","text":"0x00 小记录这里是一些零碎知识点 0x01 sqlite中处理单引号所有单引号换成双单引号，如： content.replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;); 这样是不行的，临时抱佛脚，换成了带”？”的通配形式 0x02 SimpleCursorAdapter.notifyDataSetChanged无效可以使用SimpleCursorAdapter的changeCursor方法： http://stackoverflow.com/questions/1985955/android-simplecursoradapter-not-updating-with-database-changes http://stackoverflow.com/questions/14034770/using-notifydatasetchanged-on-simplecursoradapter-does-not-work 0x03 listview隐藏分割线 setDriver(null) 在xml文件中属性设置为 @null 0x04 sqlite中replace into无效之前写好的代码调试都通过了，今天突然发现不能运行了： sqlite，表中创建唯一索引，然后使用replace into实现插入或者更新，结果变成了只插入 折腾了几个小时，最后改掉了表中一个名为id的字段，实在是无语 0x05 临时写java的Thread封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public abstract class BaseThread extends Thread &#123; private volatile boolean mQuit = false; public BaseThread() &#123; &#125; /** * prepare if needed */ public boolean prepare() &#123; return true; &#125; /** * run body */ public abstract void execute() throws Exception; // third modify,second modify maybe not neccessary /** * recycle if needed */ public void recycle() &#123; &#125; /** * stop thread */ public final void quit() &#123; mQuit = true; interrupt(); &#125; @Override public void run() &#123; // TODO Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); if (!prepare()) &#123; return; &#125; while (true) &#123; if (mQuit) &#123; // second modify recycle(); return; &#125; try &#123; execute(); &#125; catch (Exception e) &#123;// &#125; catch (InterruptedException e) &#123; if (mQuit) &#123; recycle(); return; &#125; continue; &#125; &#125; &#125;&#125;``` ## 0x06 Volley中设置连接超时设置超时的地方：HurlStack：``` java/*** Opens an &#123;@link HttpURLConnection&#125; with parameters.** @param url* @return an open connection* @throws IOException*/private HttpURLConnection openConnection(URL url, Request&lt;?&gt; request) throws IOException &#123; HttpURLConnection connection = createConnection(url); int timeoutMs = request.getTimeoutMs(); connection.setConnectTimeout(timeoutMs); connection.setReadTimeout(timeoutMs); connection.setUseCaches(false); connection.setDoInput(true); // use caller-provided custom SslSocketFactory, if any, for HTTPS if (\"https\".equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) &#123; ((HttpsURLConnection) connection).setSSLSocketFactory(mSslSocketFactory); &#125; return connection;&#125;``` HttpClientStack： ``` java@Overridepublic HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders); addHeaders(httpRequest, additionalHeaders); addHeaders(httpRequest, request.getHeaders()); onPrepareRequest(httpRequest); HttpParams httpParams = httpRequest.getParams(); int timeoutMs = request.getTimeoutMs(); // TODO: Reevaluate this connection timeout based on more wide-scale // data collection and possibly different for wifi vs. 3G. HttpConnectionParams.setConnectionTimeout(httpParams, 5000); HttpConnectionParams.setSoTimeout(httpParams, timeoutMs); return mClient.execute(httpRequest);&#125; Request中： 123456/*** Sets the retry policy for this request.*/public void setRetryPolicy(RetryPolicy retryPolicy) &#123; mRetryPolicy = retryPolicy;&#125; RetryPolicy ： 123456789101112131415161718192021222324/*** Retry policy for a request.*/public interface RetryPolicy &#123; /** * Returns the current timeout (used for logging). */ public int getCurrentTimeout(); /** * Returns the current retry count (used for logging). */ public int getCurrentRetryCount(); /** * Prepares for the next retry by applying a backoff to the timeout. * * @param error The error code of the last attempt. * @throws VolleyError In the event that the retry could not be performed (for example if we * ran out of attempts), the passed in error is thrown. */ public void retry(VolleyError error) throws VolleyError;&#125; 0x07 Android与图片相关http://developer.android.com/training/displaying-bitmaps/index.html 0x08 将eclipse项目中的文件夹移除SVN的控制（添加到svn:ignore）以删除android项目中的bin文件夹为例 a、关闭项目的自动build：project-Build Automaticallyb、删除bin文件夹c、提交d、打开 项目的自动build，这个时候会生成bin文件夹e、将bin添加到svn:ignore：右键-Team-添加至svn:ignoref、提交 0x09 屏幕旋转，Activity的成员变量被全部释放？！貌似是这样子的 0x10 ViewPager频繁被回收ViewPager) 12345678910111213141516171819202122232425262728/*** Set the number of pages that should be retained to either side of the* current page in the view hierarchy in an idle state. Pages beyond this* limit will be recreated from the adapter when needed.** &lt;p&gt;This is offered as an optimization. If you know in advance the number* of pages you will need to support or have lazy-loading mechanisms in place* on your pages, tweaking this setting can have benefits in perceived smoothness* of paging animations and interaction. If you have a small number of pages (3-4)* that you can keep active all at once, less time will be spent in layout for* newly created view subtrees as the user pages back and forth.&lt;/p&gt;** &lt;p&gt;You should keep this limit low, especially if your pages have complex layouts.* This setting defaults to 1.&lt;/p&gt;** @param limit How many pages will be kept offscreen in an idle state.*/public void setOffscreenPageLimit(int limit) &#123; if (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123; Log.w(TAG, \"Requested offscreen page limit \" + limit + \" too small; defaulting to \" + DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES; &#125; if (limit != mOffscreenPageLimit) &#123; mOffscreenPageLimit = limit; populate(); &#125;&#125; 0x11 Android SQLite 分页查询，参数为页大小和起始编号先看数据： 查询第0条之后的5条：select * from china_city where province = &#39;北京&#39; order by code limit 5 offset 0 查询第5条之后的5条：select * from china_city where province = &#39;北京&#39; order by code limit 5 offset 5 0x12 获取进程内存 和 已使用内存 进程内存 123int memClass = ((ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass();int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); 已使用内存 Log.i(&quot;tag&quot;, where+&quot;usedMemory: &quot;+Debug.getNativeHeapSize()/ 1048576L); 0x13 与联系人相关http://developer.android.com/training/contacts-provider/display-contact-badge.html 0x14 设置字体大小可以用setTextSize()的另外一种形式，可以指定单位：setTextSize(int unit, int size) TypedValue.COMPLEX_UNIT_PX: Pixels TypedValue.COMPLEX_UNIT_SP: Scaled Pixels TypedValue.COMPLEX_UNIT_DIP: Device Independent Pixels 0x15 交换两个变量的值123date3 = date1;date1 = date2;date2 = date3; 12345if (date2 &gt; date1) &#123; date2 = date2 + date1; date1 = date2 - date1; date2 = date2 - date1;&#125; 123date2 = date1 ^ date2;date1 = date1 ^ date2;date2 = date1 ^ date2; 0x16 获取URI真实的地址1234567891011121314151617181920212223242526272829303132333435363738394041424344private String getRealPath(Uri uri) &#123; String path = \"\"; String[] proj = &#123;MediaStore.Images.Media.DATA&#125;; Cursor cursor = getActivity().getContentResolver().query(uri, proj, null, null, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; path = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)); &#125; return path;&#125;``` ## 0x17 自定义Gridview，解决ScrollView中嵌套Gridview显示不正常的问题网上到处都可以找到下面的解决办法，但是这样会有一个问题：当图片非常多的时候是一次加载完毕的，而我们希望的应该是本来的GridView可以通过滑动判断当前显示条目的情况，在此记录一下。``` java/*** 自定义Gridview，解决ScrollView中嵌套Gridview显示不正常的问题&lt;br&gt;* 但是，这又产生了一个新的问题：所有的item都是一次加载完毕的，再想滑动加载就不行了** @author ttdevs*/public class ImageGridView extends GridView &#123; public ImageGridView(Context context) &#123; this(context, null); &#125; public ImageGridView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ImageGridView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //super.onMeasure(widthMeasureSpec, heightMeasureSpec); int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125;&#125; 0x18 .9图片的制作一个图片只想横向拉伸。所以就想当然的只在左边画了一条横线，运行的时候怎么都是有黑线，没拉伸。 最后解决：给左边也加一条竖线！ 0x20 listview点击背景不变这个应该还是焦点的问题，在item的view最上层布局中添加一个属性： android:descendantFocusability=&quot;blocksDescendants&quot; 0x21 Volley Cookieshttp://stackoverflow.com/questions/16680701/using-cookies-with-android-volley-library 0x22 EditText设置readOnly123et.setCursorVisible(false); et.setFocusable(false); et.setFocusableInTouchMode(false); 0x23 保存对象到SharedPreferences想保存一个List 到SharedPreferences。网上找了一圈有一种说法利用set，或者base64，都感觉不好。朋友一句提示：json。然后豁然开朗。现转化成json，然后保存，效果不错。 0x24 获取字符123456789public String getCharacter(String str) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; if (String.valueOf(str.charAt(i)).getBytes().length &gt; 1) &#123; sb.append(str.charAt(i)); &#125; &#125; return sb.toString();&#125; 0x25 Android 4 按钮样式style=&quot;?android:attr/buttonBarButtonStyle&quot; 0x26 几个sqlite的sql语句 select count(*) from notes create table notes_new as select * from notes; select count(*) from notes_new delete from notes_new where word like ‘% %’; delete from notes_new where word like ‘%-%’; delete from notes_new where phonetic like ‘’; create table notes_new_new as select * from notes_new; select count(*) from notes_new_new delete from notes_new_new where _id not in (select min(_id) from notes_new_new group by word) select * from notes_new_new insert into notes_word(word,detail,created,phonetic) select word,detail,created,phonetic from notes_new_new; Create Table: 1234567CREATE TABLE notes_word( _id INTEGER PRIMARY KEY AUTOINCREMENT, word TEXT, detail TEXT, created INT, phonetic TEXT); 0x27 加密相关 http://blog.csdn.net/androidsecurity/article/details/8666954 http://blog.csdn.net/baolong47/article/details/17335227 http://blog.csdn.net/guolin_blog/article/details/11952409 0x28 FaceBook开源项目 0x29 ScrollView与高度固定的GridView或者ListView嵌套时，界面不显示在最上面 gvGroup.setFocusable(false); lvGroup.setFocusable(false);在设置Adapter之前让其失去焦点 svMain.fullScroll(ScrollView.FOCUS_UP); 在合适的时候(如delay10ms)让ScrollView滚动到最顶端 0x30 获取view的高度123Rect rect = new Rect();getDrawingRect(rect);int height = rect.bottom - rect.top; 0x31 http://hold-on.iteye.com/blog/19434370x32 调用系统的浏览器打开网页区分大小写，http必须为小写 1234String url = \"http://www.baidu.com\";Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(url));startActivity(intent); 0x33 HTTP POST 乱码1234567List&lt;NameValuePair&gt; postParameters = new ArrayList&lt;NameValuePair&gt;();postParameters.add(new BasicNameValuePair(\"v\", param));postParameters.add(new BasicNameValuePair(\"s\", Utils.MD5Encode(param, \"\")));postParameters.add(new BasicNameValuePair(\"e\", String.valueOf(encryptType)));UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(postParameters, \"UTF-8\");mPost.setEntity(formEntity); 0x34 读取联系人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 读取本地通讯录（手机）&lt;br&gt; * 用户通讯录： 手机号码、联系人命名、备注信息、分组信息&lt;br&gt; * 耗时 * * @param context * @return */@SuppressLint(\"UseSparseArrays\")public static Map&lt;String, ContactInfo&gt; getContracts(Context context) &#123; Map&lt;String, ContactInfo&gt; contactMap = new HashMap&lt;String, ContactInfo&gt;(); try &#123; ContentResolver resolver = context.getContentResolver(); if (null == resolver) &#123; return contactMap; &#125; // 手机：姓名和手机号 Cursor curosr = resolver.query(Phone.CONTENT_URI, new String[]&#123;Phone.CONTACT_ID, Phone.DISPLAY_NAME, Phone.NUMBER&#125;, null, null, null); if (null != curosr &amp;&amp; curosr.moveToFirst()) &#123; int keyId = curosr.getColumnIndex(Phone.CONTACT_ID); int keyName = curosr.getColumnIndex(Phone.DISPLAY_NAME); int keyNumber = curosr.getColumnIndex(Phone.NUMBER); do &#123; String id = curosr.getString(keyId); String name = curosr.getString(keyName); String number = curosr.getString(keyNumber); ContactInfo info = new ContactInfo(); info.setName(name); if (!TextUtils.isEmpty(number)) &#123; number = number.replace(\"-\", \"\"); number = number.replace(\" \", \"\"); info.setNumber(number); &#125; contactMap.put(id, info); &#125; while (curosr.moveToNext()); &#125; curosr.close(); // SIM卡：姓名和手机号 curosr = resolver.query(Uri.parse(\"content://icc/adn\"), new String[]&#123;Phone.CONTACT_ID, Phone.DISPLAY_NAME, Phone.NUMBER&#125;, null, null, null); if (null != curosr &amp;&amp; curosr.moveToFirst()) &#123; int keyId = curosr.getColumnIndex(Phone.CONTACT_ID); int keyName = curosr.getColumnIndex(Phone.DISPLAY_NAME); int keyNumber = curosr.getColumnIndex(Phone.NUMBER); do &#123; String id = curosr.getString(keyId); String name = curosr.getString(keyName); String number = curosr.getString(keyNumber); ContactInfo info = new ContactInfo(); info.setName(name); info.setNumber(number); contactMap.put(id, info); &#125; while (curosr.moveToNext()); &#125; curosr.close(); // 备注 curosr = resolver.query(Data.CONTENT_URI, new String[]&#123;Data.CONTACT_ID, Data.DATA1&#125;, null, null, null); if (null != curosr &amp;&amp; curosr.moveToFirst()) &#123; int keyId = curosr.getColumnIndex(Data.CONTACT_ID); int keyRemark = curosr.getColumnIndex(Data.DATA1); do &#123; String id = curosr.getString(keyId); String remark = curosr.getString(keyRemark); ContactInfo info = contactMap.get(id); if (null != info) &#123; info.setRemark(remark); &#125; &#125; while (curosr.moveToNext()); &#125; curosr.close(); // 获取所有分组 Map&lt;String, String&gt; groupData = new HashMap&lt;String, String&gt;(); curosr = resolver.query(Groups.CONTENT_URI, new String[]&#123;Groups._ID, Groups.TITLE&#125;, null, null, null); if (null != curosr &amp;&amp; curosr.moveToFirst()) &#123; int keyId = curosr.getColumnIndex(Groups._ID); int keyGroupName = curosr.getColumnIndex(Groups.TITLE); do &#123; String id = curosr.getString(keyId); String name = curosr.getString(keyGroupName); groupData.put(id, name); &#125; while (curosr.moveToNext()); &#125; curosr.close(); // 关联联系人和分组 curosr = resolver.query(Data.CONTENT_URI, new String[]&#123;GroupMembership.CONTACT_ID, GroupMembership.GROUP_ROW_ID&#125;, Data.MIMETYPE + \" = ?\", new String[]&#123;GroupMembership.CONTENT_ITEM_TYPE&#125;, null); if (null != curosr &amp;&amp; curosr.moveToFirst()) &#123; int keyId = curosr.getColumnIndex(GroupMembership.CONTACT_ID); int keyGroupId = curosr.getColumnIndex(GroupMembership.GROUP_ROW_ID); do &#123; String id = curosr.getString(keyId); String groupId = curosr.getString(keyGroupId); String groupName = groupData.get(groupId); ContactInfo info = contactMap.get(id); if (null != info &amp;&amp; !TextUtils.isEmpty(groupName)) &#123; info.setGroup(groupName); &#125; &#125; while (curosr.moveToNext()); &#125; curosr.close(); Iterator&lt;String&gt; iterator = contactMap.keySet().iterator(); while (iterator.hasNext()) &#123; String id = iterator.next(); ContactInfo info = contactMap.get(id); System.out.println(String.format(\"%s, %s, %s, %s.\", info.getName(), info.getNumber(), info.getGroup(), info.getRemark())); &#125; groupData.clear(); groupData = null; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return contactMap;&#125; 0x35 单元测试——测试异步任务1234567891011121314151617public void testAsynchronous() &#123; try &#123; CountDownLatch signal = new CountDownLatch(1); new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); signal.countDown(); Looper.loop(); &#125; &#125;).start(); signal.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 0x36 GridLayout合并123456789101112131415161718192021222324252627282930313233343536373839&lt;GridLayout android:id=\"@+id/glNumber\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/etPassword\" android:layout_centerHorizontal=\"true\" android:alignmentMode=\"alignBounds\" android:columnCount=\"3\" android:orientation=\"horizontal\" android:rowCount=\"4\"&gt; &lt;com.ttdevs.blur.CircleButton android:id=\"@+id/cbt1\" android:layout_width=\"64dp\" android:layout_height=\"64dp\" /&gt; &lt;com.ttdevs.blur.CircleButton android:id=\"@+id/cbt2\" android:layout_width=\"64dp\" android:layout_height=\"64dp\" android:layout_margin=\"10dp\" /&gt; &lt;com.ttdevs.blur.CircleButton android:id=\"@+id/cbt3\" android:layout_width=\"64dp\" android:layout_height=\"64dp\" /&gt; &lt;com.ttdevs.blur.CircleButton android:id=\"@+id/cbt0\" android:layout_width=\"64dp\" android:layout_height=\"64dp\" android:layout_columnSpan=\"2\" android:layout_gravity=\"right\" /&gt; &lt;com.ttdevs.blur.CircleButton android:id=\"@+id/cbtDel\" android:layout_width=\"64dp\" android:layout_height=\"64dp\" /&gt;&lt;/GridLayout&gt; 0x37 PopupWindow显示的时候左右不靠边（有边缝）setBackgroundDrawable(new ColorDrawable(0xa0000000)); 0x38 EditText限制可输入小数etInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL); 0x39 隐藏键盘隐藏键盘貌似在onDestory中调用无效，最后自己把它写在了onStop中 1234567891011/** * 关闭键盘 * @param context * @param windowToken * @param flag */public static void close(Context context, IBinder windowToken, int flag) &#123; InputMethodManager imm = (InputMethodManager) context .getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(windowToken, flag);&#125; 0x40 Android TextView 显示不全的问题代码如下，当给TextView的属性设置成match_parent的时候，text中设置的文字比较长的时候会出现显示不全的问题 123456789101112131415161718192021222324&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"top\" android:orientation=\"horizontal\" android:padding=\"@dimen/global_padding_normal\"&gt; &lt;ImageView android:id=\"@+id/iv_health_light\" android:layout_width=\"@dimen/detail_light_width\" android:layout_height=\"@dimen/detail_light_height\" android:gravity=\"center_horizontal\" /&gt; &lt;TextView android:id=\"@+id/tv_appraise\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"@dimen/global_margin_normal\" android:gravity=\"left|top\" android:lineSpacingExtra=\"@dimen/global_line_space\" android:textColor=\"@color/global_gray_dark\" android:textSize=\"@dimen/global_font_small\" /&gt;&lt;/LinearLayout&gt; 0x41 查看系统alarm(闹钟)队列 Alarm事件队列 adb shell dumpsys alarm 查看intent adb shell dumpsys activity intents 0x42 singleTask与onNewIntentsingleTask与onNewIntent同时存在时，onNewIntent不是总被调用。比如：当前App启动过，第三方App再次启动时是不会调用onNewIntent的，再或者我们从任务列表中再次启动当前App也是不会触发onNewIntent的。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」让RecyclerView支持加载更多(Endless RecyclerView)","slug":"[Android]让RecyclerView支持加载更多(Endless RecyclerView)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]让RecyclerView支持加载更多(Endless RecyclerView)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]让RecyclerView支持加载更多(Endless RecyclerView)/","excerpt":"","text":"0x00 问题好久没有写博客，最近正好有时间，打算把之前很长很长一段时间落下的坑都给填了。 在Android的Support包中我们有很多新的组件可以使用，比如代替ListView的RecyclerView。使用RecyclerView和SwipeRefreshLayout组合，我们可以实现很酷炫的下拉刷新的功能。但是，事情总不是那么美好，有了下拉刷新，却找不到上拉加载更多（我们已经习惯了PullToRefresh），最终还是放弃了使用RecyclerView。现在看来，自己实在是太懒了。好了，今天就让我们的RecyclerView支持加载更多。 0x01 Endless RecyclerViewRecyclerView的的使用多数是与SwipeRefreshLayout进行组合，当然，你也可以算上CardView。使用SwipeRefreshLayout时，受PullToRefresh的影响，很自然的会想到给SwipeRefreshLayout加个上拉加载更多的功能。如果你也这么想，那么我们就一起来YY下google为什么没有官方支持这么做。 给SwipeRefreshLayout添加加载更多功能：我们期望的(比如：SwipeRefreshLayout + RecyclerView，但是google没这么做)。如果SwipeRefreshLayout中是TextView或者自定义的View，很显然，我们并不能保证这个加载更多是可以实现的（即使实现了，他们耦合也会很高）。 给RecyclerView添加加载更多功能：这个方案是可行的 给其他更多SwipeRefreshLayout包含的view添加加载更多功能：第二种情况的扩展，这个根据具体的view来讨论 因此，我们应该把加载更多放到具体的view中。 0x02 实现下面是我们支持加载更多的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Created by ttdevs 9/3/15 1:31 PM. https://github.com/ttdevs * Copyright (c) 2015 ttdevs, Inc. All rights reserved. */package com.ttdevs.support.recycler;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import com.ttdevs.utils.LogUtils;/** * RecyclerView加载更多的类,支持LinearLayoutManager和GridLayoutManager * 使用: * RecyclerView.addOnScrollListener(new OnRecyclerLoadMoreListener()&#123; * public void onLoadMore()&#123;...&#125; * &#125;); */public abstract class OnRecyclerLoadMoreListener extends RecyclerView.OnScrollListener &#123; private LinearLayoutManager mLayoutManager; private int mItemCount, mLastCompletely, mLastLoad; /** * load more */ public abstract void onLoadMore(); @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) &#123; mLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); mItemCount = mLayoutManager.getItemCount(); mLastCompletely = mLayoutManager.findLastCompletelyVisibleItemPosition(); &#125; else &#123; return; &#125; if (mLastLoad != mItemCount &amp;&amp; mItemCount == mLastCompletely + 1) &#123; LogUtils.debug(String.format(\"****************load more****************\")); LogUtils.debug(String.format(\"mItemCount:%d \\t mLastCompletely:%d\", mItemCount, mLastCompletely)); LogUtils.debug(String.format(\"****************load more****************\")); mLastLoad = mItemCount; onLoadMore(); &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Android」通过Intent传递数据","slug":"[Android]通过Intent传递数据","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android]通过Intent传递数据/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android]通过Intent传递数据/","excerpt":"","text":"0x00 需求日常开发中，我们经常遇到通过 Intent 来传递数据（如果你使用Bundle也是一样的），默认情况，我们可以看到支持的数据类型： 基本类型 boolean、byte、char 、short、double、float、int、long 字符串类型 String、String[]、CharSequence、CharSequence[] 序列化类型 Serializable、Parcelable 其他类型 八种基本类型的数组、IntegerArray、StringArray、CharSequenceArray、ParcelableArray 对于基本类型我们可以不做任何处理即可在Activity或者Service中传递。那么对于自定义类型，我们怎么做呢？ 0x01 何谓序列化当我们需要对JVM中的java对象进行转储时，就需要将其转化成二进制序列，然后才能存储到外部。这个序列中保存了java对象的类型，数据，数据类型等。当需要的时候，再对存储的二进制序列进行反序列化，即可将其还原。常见的场景比如：存储JVM中对象，通过Socket传递java对象，RMI等等。 0x02 String类型 为什么把这个放在第一位呢？原因很简单：简单 基本类型不用说，直接传递即可，对于我们的自定义类型，如果你跟我一样，不太喜欢（熟悉 T-T）Serializable和Parcelable，那用String类型最简单了。其实这个说法还有个前提，就是我们的项目中需要集成json工具（不过至少有gson）。使用方法如下：首先通过json工具将我们的Object转换成json字符串，然后在接收处在通过json工具还原为Object。 从效率来看，会比下面两种情况低。但是对初学者来说，会比下面两种用起来简单。目前还没有遇到出错的问题（可能时因为我传递的数据比较小比较简单吧）。 0x02 SerializableJava中经常会遇到 Serializable，比如这样： 123456public class Person implements Serializable &#123; public String name; public int age; public boolean login; public float score;&#125; 有些地方需要进行序列化时，IDE会提示我们实现一个接口：Serializable，然后我们乖乖地加上这个接口即可（有时候IDE还会自动生成一个静态常量：private static final long serialVersionUID = 23333333333333333333L;）。如果你没有去追究为什么，那么事情就此结束。通过Intent传递数据时，也是如此。好了，我们进入下一部分～～ 哈哈，哪能这么简单。你可能会问，为什么加个这个接口即可？Serializable是一种 标记接口，当我们实现这个接口之后，系统会自动通过反射机制将我们对象的成员进行序列化。这里会涉及一些其他信息，比如：serialVersionUID、静态常量的序列化等等，更多信息请参考这里。 0x03 ParcelableParcelable是android特有的处理序列化的方法。先看简单的使用： 创建一个类： 123456public class User implements Parcelable &#123; public String userName; public int age; public boolean login; public float score;&#125; 使用AndroidStudio的代码生成功能生成如下 模版 代码： 1234567891011121314151617181920212223242526272829303132333435363738 public class User implements Parcelable &#123; public String userName; public int age; public boolean login; public float score; protected User(Parcel in) &#123; userName = in.readString(); age = in.readInt(); login = in.readByte() != 0; score = in.readFloat(); &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(userName); dest.writeInt(age); dest.writeByte((byte) (login ? 1 : 0)); dest.writeFloat(score); &#125; @Override public int describeContents() &#123; return 0; &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;;&#125; 对比上面的两段代码，我们可以发现： 构造方法中接收一个 Parcel 对象，通过这个对象对成员变量赋值 实现了 Parcelable 接口的方法 在 writeToParcel 方法中将我们的成员变量写入 Parcel 在 describeContents 中返回一个数字 0 Describe the kinds of special objects contained in this Parcelable instance’s marshaled representation. For example, if the object will include a file descriptor in the output of writeToParcel(Parcel, int), the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit. 创建了一个 public static final 常量 CREATOR 这样我们就可以通过Intent传递对象了。 在android的很多文章中都可以看到，Intent中传递数据，强烈推荐使用 Parcelable 他的效率会比 Serializable更高（比如后者没有使用反射等等）。当然没有完美的事情，Parcelable 并不能完全取代Serializable，比如将JVM对象存储到磁盘等等。但是对于Android开发中的通过Intent传递数据来说，已经足够。 0xFF 参考 http://stackoverflow.com/questions/3611843/is-using-serializable-in-android-bad/3612364#3612364 http://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html https://developer.android.com/reference/android/os/Parcelable.html http://blog.csdn.net/js931178805/article/details/8268144","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"}]},{"title":"「Flask」0x00Welcome","slug":"[Flask]0x00Welcome","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Flask]0x00Welcome/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Flask]0x00Welcome/","excerpt":"","text":"0x00 Welcome to Flask Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. And before you ask: It’s BSD licensed! 0xFF 参考 https://pypi.python.org/pypi/Flask/0.10.1 http://flask.pocoo.org/docs/0.10/ https://github.com/pallets/flask","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://ttdevs.github.io/tags/Flask/"}]},{"title":"「Flask」0x01FlaskMail","slug":"[Flask]0x01FlaskMail","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Flask]0x01FlaskMail/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Flask]0x01FlaskMail/","excerpt":"","text":"0x00 简介 Welcome to Flask-Mail, you can use to send mail in your web site. Flask-Mail 提供了一个简单的接口，让我们可以方便的在 Flask 应用中使用 SMTP协议 发送邮件。 0x01 安装pip install Flask-Mail 目前最新版本是 0.9.1 ，从 Flask-Mail的github地址可以发现，两年没有更新了。不过这个并不影响我们使用，毕竟发送邮件是个比较成熟的东西，只祈求和最新的Flask不要出现兼容问题即可。 如果你不想使用这个工具，可以找找其他的，不过你会发现，其他的可能更老，也是醉了=_= 如果时间充足，我们可以去读读 Flask-Mail 的源码，你会发现，最终是用系统自带的 smtplib 实现的。 0x02 使用一句话总结：Flask-Mail 的使用还是相当easy的。 配置Flask-Mail 使用 Flask 标准的配置 API 进行配置。下面是所有的配置选项： MAIL_SERVER : 默认为 ‘127.0.0.1’ MAIL_PORT : 默认为 25 MAIL_USE_TLS : 默认为 False MAIL_USE_SSL : 默认为 False MAIL_DEBUG : 默认为 app.debug MAIL_USERNAME : 默认为 None MAIL_PASSWORD : 默认为 None MAIL_DEFAULT_SENDER : 默认为 None MAIL_MAX_EMAILS : 默认为 None MAIL_SUPPRESS_SEND : 默认为 app.testing MAIL_ASCII_ATTACHMENTS : 默认为 False 这个配置的参数我们可以在这里看到。 初始化可以使用下面的两种方式进行初始化： 第一种方式： 使用传入到 Mail 实例中的应用程序的配置项进行邮件发送 12345from flask import Flaskfrom flask_mail import Mailapp = Flask(__name__)mail = Mail(app) 第二种方式： 使用 Flask 的 current_app 中的配置项进行邮件发送，如果我们有多个 不同配置的应用程序 则使用此种方式比较方便 1234mail = Mail()app = Flask(__name__)mail.init_app(app) 发送发送之前我们需要先构建一个 Message 对象，如下： 123from flask_mail import Messagemsg = Message(\"Hello Flask\", sender=\"ttdevs@gmail.com\", recipients=[\"ttdevs@live.com\"]) 我们也可以同时指定多个收件人 12msg.recipients = [\"ttdevs@gmail.com\", \"ttdevs@foxmail.com\"]msg.add_recipient(\"ttdevs@live.com\") 如果我们配置了 MAIL_DEFAULT_SENDER 字段，就可以不再设置 sender ，这个时候会使用 MAIL_DEFAULT_SENDER 中指定的发件人，像这样： 1msg = Message(\"Hello Flask\", recipients=[\"ttdevs@live.com\"]) 如果我们希望在收件列表中显示一个名字，可以通过一个二元祖来指定： 1msg = Message(\"Hello\", sender=(\"ttdevs\", \"ttdevs@live.com\")) 同时， 我们还可以指定下面两个字段： 12msg.body = \"this is body string\"msg.html = \"&lt;h2&gt;this is html message&lt;/b&gt;\" 最后就是发送： 1mail.send(msg) 发送完毕后，与邮件服务器的链接就会关闭。 发送大量邮件如果我们一次发送大量的邮件，可以通过下面的方式发送： 12345678with mail.connect() as conn: for user in users: message = '...' subject = \"hello, %s\" % user.name msg = Message(recipients=[user.email], body=message, subject=subject) conn.send(msg) 与电子邮件服务器的连接会一直保持直到所有的邮件都已经发送完毕才会断开。 Some mail servers set a limit on the number of emails sent in a single connection. You can set the max amount of emails to send before reconnecting by specifying theMAIL_MAX_EMAILS setting. 添加附件在邮件中添加附件同样非常简单： 123image = 'umbrella.jpg'with app.open_resource(image) as fp: msg.attach(image, 'image/jpg', fp.read()) 0x03 Demo下面是一个简单的Demo，装好相关的类库， 直接可以跑，大家可以参考： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# coding:utf-8from flask import Flaskfrom flask_mail import Mailfrom flask_mail import Messageapp = Flask(__name__)app.config['MAIL_SERVER'] = 'smtp.qq.com'app.config['MAIL_PORT'] = 465app.config['MAIL_USE_SSL'] = Trueapp.config['MAIL_USERNAME'] = 'iot.raspi@qq.com'app.config['MAIL_PASSWORD'] = '********'app.config['MAIL_DEFAULT_SENDER'] = 'iot.raspi@qq.com'mail = Mail(app)@app.route('/')def welcome(): msg = Message('这是一封测试邮件Header', recipients=['56532799@qq.com']) msg.body = '这是一封测试邮件 bodyer' msg.html = '这是一封测试邮件 htmler' image = 'umbrella_伞.jpg' with app.open_resource(image) as fp: msg.attach(image, 'image/jpg', fp.read()) mail.send(msg) return 'Hello world!'if __name__ == '__main__': app.run(debug=tuple) 邮件参数说明上面的Demo中用到QQ邮箱，这里简单介绍下。由于QQ邮箱需要安全验证，所以我们配置下面几个参数： MAIL_SERVER SMTP地址：smtp.qq.com MAIL_PORT 由于需要安全验证，所以此处用465 MAIL_USE_SSL：True SSL，走加密方式 MAIL_USERNAME iot.raspi@qq.com MAIL_PASSWORD 这个地方我们需要使用授权码： 打开 QQ邮箱 &gt; 设置 &gt; POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 &gt; 生成授权码 最后别忘了打开SMTP服务～～ 0x04 其他（TODO 留坑，其实暂时还没学到～～） 单元测试禁止发送邮件头注入信号量API0xFF 参考 http://pythonhosted.org/Flask-Mail/ http://www.pythondoc.com/flask-mail/ https://pypi.python.org/pypi/Flask-Mail/","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://ttdevs.github.io/tags/Flask/"}]},{"title":"「Flask」0x02给我们的Flask应用配置Supervisor","slug":"[Flask]0x02给我们的Flask应用配置Supervisor","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Flask]0x02给我们的Flask应用配置Supervisor/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Flask]0x02给我们的Flask应用配置Supervisor/","excerpt":"","text":"0x00 场景 Nginx ＋ uWSGI ＋ Flask 的场景中，当我们的代码出现异常或者其他一些原因导致服务挂掉，我们会希望能自动重启 uWSGI 这个时候我们我们可以考虑使用 supervisor来达到我们的目的。此文接上一篇，因此我的系统还是Raspbian(Debian)。这里分享一些简单的配置使用。先看一下 supervisor 的介绍： Supervisor is a client/server system that allows its users to monitor and control a number of processes on UNIX-like operating systems. 0x01 安装这个比较简单，我们直接使用 apt-get 即可安装。 pi@raspberrypi:~ $ sudo apt-get install supervisor (卸载用：apt-get remove) 当然，你也可以用 pip 进行安装： sudo pip install supervisor 0x02 配置supervisor 的配置文件位于 /etc/supervisor/ 下，如： 12pi@raspberrypi:/etc/supervisor $ lsconf.d supervisord.conf supervisord.conf 是默认的配置文件，我们无需修改，在 conf.d 目录下，我们创建自己的配置文件即可，这里我建了一个 uwsgi.conf 文件： 123pi@raspberrypi:/etc/supervisor $ cd conf.d/pi@raspberrypi:/etc/supervisor/conf.d $ touch uwsgi.confpi@raspberrypi:/etc/supervisor/conf.d $ sudo nano uwsgi.conf uwsgi.conf 文件内容： 12345678[program:raspi]command=/home/pi/raspi/venv/bin/uwsgi /home/pi/raspi/uwsgi.inidirectory=/home/pi/raspiuser=piautostart=trueautorestart=truestdout_logfile=/home/pi/raspi/logs/uwsgi_supervisor.logstderr_logfile=/home/pi/raspi/logs/uwsgi_supervisor_err.log command：执行的命令 directory：工作的目录，在执行前会进行切换，由于上面我使用的绝对路径，可以不配置 stdout_logfile 和 stderr_logfile 配置我们日志输出位置 这个配置文件的更多可选参数可参考这里。 supervisor 还提供了一个web管理界面，我们需要先对其进行配置，修改 /etc/supervisor/supervisord.conf 文件，增加如下内容即可： 123456789101112131415161718 [supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socketserverurl=http://192.168.1.56:9000username=ttdevs ; (default is no username (open server))password=admin ; (default is no password (open server)); The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files = /etc/supervisor/conf.d/*.conf[inet_http_server] ; inet (TCP) server disabled by defaultport=192.168.1.56:9000 ; (ip_address:port specifier, *:port for all iface)username=ttdevs ; (default is no username (open server))password=admin ; (default is no password (open server)) 0x03 操作安装好以后，我们有两个命令可以使用，一个是 supervisord，另一个是 supervisorctl，supervisord 负责启动服务，supervisorctl 负责操作服务，C/S模式。 启动 supervisor： sudo supervisord 更多的启动参数可以参考这里。 启动/重启/停止某个我们配置的进程：supervisorctl start/restart/stop programABC 另外在上面的配置中，我们还可以使用浏览器访问 http://192.168.1.56:9000/对我们的进程进行管理。 0xFF 参考 http://blog.chinaunix.net/uid-26000296-id-4759916.html http://liyangliang.me/posts/2015/06/using-supervisor/ http://www.restran.net/2015/10/04/supervisord-tutorial/","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://ttdevs.github.io/tags/Flask/"}]},{"title":"「Android-Bluetooth」0x01操作","slug":"[Android-Bluetooth]0x01操作","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Android-Bluetooth]0x01操作/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Android-Bluetooth]0x01操作/","excerpt":"","text":"0x00 蓝牙（Bluetooth）这个小硬件已经是Android机器的标配了，由于平时不怎么用，因此到现在都没有去研究过。现在有一个简单的小需求：通过蓝牙连接一个串口设备读取其上面的数据，即从已配对的设备列表中选择我们的串口蓝牙设备（从），连接，然后读取数据。遂写此文。 0x01 简单使用蓝牙设备的详细使用，可以参考Android关于蓝牙的官方文档。如果你和我一样，之前没有研究过蓝牙，估计看看完后也会有一堆问题存在：什么主设备、从设备、UUID是干嘛的，如何免密钥配对等等。不着急，我们慢慢来。 上面已经说到，我们的设备已经提前配对完成（怎么配对：网络设置中中找到蓝牙，然后搜索，找到你的设备，然后配对。这个时候可能会提示输入密码，默认密码比0000，1234等）。我们只需要连接即可。下面简述操作步骤： 添加蓝牙权限 12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; 判断是否支持蓝牙 123456789101112131415private void initBluetooth() &#123; mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (null == mBluetoothAdapter) &#123; tvContent.setText(\"BluetoothAdapter is null\"); return; &#125; if (!mBluetoothAdapter.isEnabled()) &#123; tvContent.setText(\"BluetoothAdapter is disable, please open it\"); Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, REQUEST_ENABLE_BT); &#125; tvContent.setText(\"Bluetooth init success\");&#125; 首先是判断是否有蓝牙适配器，如果没有，`BluetoothAdapter.getDefaultAdapter()` 返回 `null`。然后判断蓝牙设备是否启用 `mBluetoothAdapter.isEnabled()` ，如果未启用，则发送一个 `Intent` 来让用户启用蓝牙，这个 `Intent` 是系统的，我们在 `onActivityResult` 中处理用户操作结果，如果用户顺利开启蓝牙，则会返回 `RESULT_OK`。 获取设备列表 12345678Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();if (null != pairedDevices &amp;&amp; pairedDevices.size() &gt; 0) &#123; for (BluetoothDevice device : pairedDevices) &#123; ...... String msg = String.format(\"%s %s\\n\", device.getName(), device.getAddress()); ...... &#125;&#125; 这个时候我们可以拿到 `BluetoothDevice` ，这个对象中保存了已配对蓝牙设备的信息，比如名称，MAC地址，状态，UUID等信息（但这些信息不一定都都），我们需要保存下来，在接下来连接的时候会使用。 连接设备 有了 BluetoothDevice 信息，我们就可以连接这个已经配对的蓝牙设备了。 12345678910111213 public static final UUID DEFAULT_UUID = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\"); try &#123; if(null == mSocket)&#123; mSocket = mDevice.createRfcommSocketToServiceRecord(DEFAULT_UUID); &#125; mSocket.connect(); // 阻塞的 mIn = mSocket.getInputStream();&#125; catch (IOException e) &#123; e.printStackTrace(); return false;&#125; 连接成功后，我们会得到一个 `BluetoothSocket` 对象，然后调用其阻塞的 `connect()` 方法，等待两台设备连接成功（所以这个时候必须在另外一个线程中进行）。当两台设备连接成功之后会继续向下执行。 读取数据 连接成功之后，我们可以通过 mSocket.getInputStream() 获得一个输入流，结下来的操作就是流的操作了，这个和普通 socket 中输入输出流的操作一样了。 1234567891011 try &#123; mBytes = mIn.read(readBuffer); System.arraycopy(readBuffer, 0, tempBuffer, mCount, mBytes); mCount += mBytes; if (mCount &gt;= SIZE) &#123; parseData(tempBuffer); mCount = 0; &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 0x02 总结Android蓝牙（主从）的操作： 检查是否支持，是否启用（包括是否可见等） 扫描设备 配对 连接 数据交换 等等 这里只讲了检查部分操作，涉及的扫描与配对可能是更复杂一些的，在接下来讲述。 最后，项目代码可参考这里github/ttdevs/air。 0x03 Java线程的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Created by ttdevs * 2017-01-22 (android) * https://github.com/ttdevs */public abstract class BaseWorkerThread extends Thread &#123; private boolean isRunning = true; @Override public void run() &#123; super.run(); isRunning = workerBefore(); while (isRunning) &#123; workerCycle(); &#125; workerAfter(); &#125; /** * 提前执行 true: 继续 false: 结束 * * @return */ public boolean workerBefore() &#123; return true; &#125; /** * 工作方法，被循环调用 * * @return true: 继续 false: 结束 */ public abstract void workerCycle(); /** * 结束执行 */ public void workerAfter() &#123; &#125; /** * 开始线程 */ public void startThread() &#123; isRunning = true; try &#123; start(); &#125; catch (Exception e) &#123; e.printStackTrace(); isRunning = false; &#125; &#125; /** * 结束线程 */ public void stopThread() &#123; isRunning = false; &#125;&#125; 0x04 参考 https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ttdevs.github.io/tags/Android/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"https://ttdevs.github.io/tags/Bluetooth/"}]},{"title":"「Java」(==)与(equals)","slug":"[Java](==)与(equals)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Java](==)与(equals)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Java](==)与(equals)/","excerpt":"","text":"0x01 两种比较方法 == 基本类型 对于基本类型，== 的功能是比较值。 Object 比较对象在内存中的地址。 equals 基本类型无equals方法。Object对象默认equals的实现如下： 1234567891011/** * ... * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */public boolean equals(Object obj) &#123; return (this == obj);&#125; 有很长一段注释，最终的实现我们可以看到还是用的 `==` 来比较两个对象在内存中的地址。 0x02 equals() &amp; hashCode()对于equals的默认实现——比较对象在内存中的地址——有时候可能并不是我们期望的，比如有一个Student类： 12345678910class Student&#123; private int id; private String name; public Student(int id)&#123; this.id = id; &#125; // ... getter and setter&#125; 当 Student.id 相同时，我们更愿意认为这是同一个学生，而下面这个测试是无法通过的： 1234567@Testpublic void equalsStudent() throws Exception &#123; Student st1 = new Student(2333); Student st2 = new Student(2333); assertEquals(st1, st2); // assertNotEquals(st1, st2);&#125; 为了达到我们的目的——相同的学号就认为是同一个人——我们可以重写Student类的 equals 方法： 12345678910111213141516171819202122class Student &#123; private int id; private String name; public Student(int id) &#123; this.id = id; &#125; @Override public boolean equals(Object o) &#123; if (null == o) &#123; return false; &#125; Student std = (Student) o; if (this.id == std.id) &#123; return true; &#125; return super.equals(o); &#125; // ... getter and setter&#125; 修改之后上面的测试就可以通过了。Demo毕竟是简单的，当我们在实际的使用中需要重写equals方法时还是需要遵守它的生成规则，这里贴出来供参考： 12345678910111213141516171819202122232425262728293031323334353637public boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 参数： obj - 要与之比较的引用对象。 返回： 如果此对象与 obj 参数相同，则返回 true；否则返回 false。 另请参见： hashCode(), Hashtable``` 事情还没有结束。看下面代码：``` java@Testpublic void studentSet() throws Exception &#123; Student st1 = new Student(2333); Student st2 = new Student(2333); Set&lt;Student&gt; stds = new HashSet&lt;&gt;(); stds.add(st1); stds.add(st2); assertEquals(1, stds.size());&#125; 你会发现这段代码测试不通过。set不是重复对象只会保留一份吗，为什么不是 1 呢？ 这里就要介绍 hashCode() 方法： 12345678910111213141516public int hashCode() 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 返回： 此对象的一个哈希码值。 另请参见： equals(java.lang.Object), Hashtable 当我们使用用哈希表实现的工具类时，这个方法的价值就体现了。由于之前我们没有重写这个方法，把Student对象存入HashSet时还是按照之前系统默认的方式计算他们的hash值，导致Set中存在两个Student对象。 下面做一个简单修改： 12345678910111213141516171819202122232425262728293031323334353637class Student &#123; private int id; private String name; public Student(int id) &#123; this.id = id; &#125; @Override public boolean equals(Object o) &#123; if (null == o) &#123; return false; &#125; // 有时候instanceof不合适的时候可以考虑用getClass()方法 if (getClass() != o.getClass()) &#123; return false; &#125; if (o instanceof Student) &#123; Student std = (Student) o; if (this.id == std.id) &#123; return true; &#125; &#125; return super.equals(o); &#125; @Override public int hashCode() &#123; return this.id; // return super.hashCode(); &#125; // ... getter and setter&#125; 再运行下面的测试，你会发现和我们期待的一致了： 12345678910@Testpublic void studentSet() throws Exception &#123; Student st1 = new Student(2333); Student st2 = new Student(2333); Set&lt;Student&gt; stds = new HashSet&lt;&gt;(); stds.add(st1); stds.add(st2); assertEquals(1, stds.size());&#125; Demo中直接将id作为hashcode返回不是一种好的生成方式，具体的生成规则请参考上面的注释。 0x03 Demo再来看一个demo： 123456789101112@Testpublic void stringTest() throws Exception &#123; String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(\"abc\"); System.out.println(str1 == str2); System.out.println(str1 == str3); assertEquals(str1, str2); assertEquals(str1, str3);&#125; 结果会怎样？没错，测试通过，输出：true，false。 首先我们来看下String类重写的equals()和hashCOde(): 123456789101112131415161718192021222324252627282930313233343536373839@Override public boolean equals(Object other) &#123; if (other == this) &#123; return true; &#125; if (other instanceof String) &#123; String s = (String)other; int count = this.count; if (s.count != count) &#123; return false; &#125; if (hashCode() != s.hashCode()) &#123; return false; &#125; for (int i = 0; i &lt; count; ++i) &#123; if (charAt(i) != s.charAt(i)) &#123; return false; &#125; &#125; return true; &#125; else &#123; return false; &#125;&#125;@Override public int hashCode() &#123; int hash = hashCode; if (hash == 0) &#123; if (count == 0) &#123; return 0; &#125; for (int i = 0; i &lt; count; ++i) &#123; hash = 31 * hash + charAt(i); &#125; hashCode = hash; &#125; return hash;&#125; 从上面可以看出，String类重写了这两个方法，equals()中的逻辑是比较字符串中每个字符是否相同。因此 str1, str2, str3相同就可以理解了。对于 str1 == str2 和 str1 != str3 这涉及到不同字符串创建方法。 在开始这个例子之前，同学们需要知道JVM处理String的一些特性。Java的虚拟机在内存中开辟出一块单独的区域，用来存储字符串对象，这块内存区域被称为字符串缓冲池。当使用 String a = “abc”这样的语句进行定义一个引用的时候，首先会在字符串缓冲池中查找是否已经相同的对象，如果存在，那么就直接将这个对象的引用返回给a，如果不存在，则需要新建一个值为”abc”的对象，再将新的引用返回a。String a = new String(“abc”);这样的语句明确告诉JVM想要产生一个新的String对象，并且值为”abc”，于是就在堆内存中的某一个小角落开辟了一个新的String对象。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ttdevs.github.io/tags/Java/"}]},{"title":"「Java」Java中TCP和UDP总结","slug":"[Java]Java中TCP和UDP总结","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Java]Java中TCP和UDP总结/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Java]Java中TCP和UDP总结/","excerpt":"","text":"0x00 还是先说点啥之前写过一些关于TCP和UDP数据传输的代码，比如使用TCP传输音视频数据包，P2P打洞中使用UDP等。写好之后就直接丢下了，没有总结下都。最近准备找工作，再拿来温习下。 暂时把自己的定位很明确，就是android应用层的开发，所以关于TCP/UDP的实现细节，暂时也不想去深究。但是心里清楚这个必须去看的，有时间推荐大家看看《TCP/IP详解》或者网上有很多大牛的总结。 0x01 TCP不知道为什么，这个总结不想写的太细，不贴代码写的细又不知道能总结啥，好纠结，可能就是认识有限吧，公司要是有个架构就好了。不说了，还是安安稳稳的写总结吧。TCP这个可能是我们用的比较多的或者说我用的比较多的，主要的工作还是进行大量数据的传输和心跳保持（想想去年面试的时候都不知道啥是心跳，汗……）。对于心跳保持，就是一个简单的小心跳包；大量数据的传输，这个也总结不了啥东西，代码就那样，就是一些细节说一下。 客户端这个是我们关注的最多的，也是作为一个手机APP主要关注的，因为我们就是client。 创建clientnew Socket(ip, port); 我们可以通过上面的方式创建一个socket，如果失败，会抛出IOException。参数中的IP和Port是目标服务器的IP和端口号。若你想得到本地的IP和PORT也可通过这个socket拿到。当然，创建socket还有多种方法，比如 new Socket(proxy)，如果有需要你可以查阅相关资料。 拿到socket对象之后我们接着要做的事情就是从这个socket中拿到输入和输出流，这样我们才可以进行数据的收发： 12InputStream is = mSocket.getInputStream();OutputStream out = mSocket.getOutputStream(); 通过输出流，我们可以使用 is.read(receiveBuffer) 和 out.write(data); 来进行数据的收发。这里给两个简单实例： 接收数据 1234567891011121314151617@Overridepublic void execute() &#123; try &#123; int count = is.read(receiveBuffer); if (count == -1) &#123; notifyError(); &#125; byte[] data = getPacket(receiveBuffer, count, is); mReceiverQueue.put(data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); notifyError(); &#125; catch (IOException e) &#123; e.printStackTrace(); notifyError(); &#125;&#125; 假如我们的数据包协议格式如下： 这个时候，如果进行大量数据传输的时候我们从InputStream中一次读取的数据可能不是一个完整的数据包。这个时候我们需要做下面的判断： a、读取的数据长度是否达到包头大小，若没有包头长，继续读，直到达到或者超过包头大小b、从包头中解出长度字段，循环读取，直到读到长度字段标示长度为止c、校验数据，去除包头，取出包体d、重复上述步骤 发送数据12345678910111213@Overridepublic void execute() &#123; try &#123; byte[] data = mSenderQueue.take(); out.write(data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); notifyError(); &#125; catch (IOException e) &#123; e.printStackTrace(); notifyError(); &#125;&#125; mSenderQueue和mReceiverQueue一样，都是阻塞队列。发送的时候，我们从队列中取出要发送的数据，然后通过输出流写入即可。这个地方比发送简单了一些。可能你已经注意到，我的发送和接收都用了阻塞队列，这个原因就是考虑到大量数据的时候做一个缓冲，如果没有缓冲，可能导致代码的阻塞。另外就是当我们的阻塞队列充满的时候可以手动丢弃一些数据，这个就是具体应用了。 服务端这个可以简单了解下，可以使用各种语言实现，比如Java、C++等。这里简单介绍Java的实现。 首先，我们创建一个ServerSocket对象并指定一个端口号，通过这个对象的accept()方法等待客户的连接，这个方法是阻塞的；当有客户端连接上来之后，我们就拿到了连接的socket，拿到这个socket之后的操作就和客户端一样了，最后看一下关键代码： 123456789try &#123; ServerSocket serverSocket = new ServerSocket(9559); while (true) &#123; Socket socket = serverSocket.accept(); // new ServiceSocketThread(socket).start(); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 因为服务端不可能只与一个客户端连接，因此上面的代码写在一个死循环中。拿到socket之后起一个新的线程来处理这个socket。当然，实际情况可能不是这样，为每一个连接创建一个新的线程是很耗费资源的。 最后，还有一点需要注意的是：从Socket中拿到InputStream和OutputStream之后如果关闭它们，socket也将随之关闭(未验证)。 0x02 UDP这个东西用的很少，就是当初测试P2P的时候用过。能想到的问题就是数据大小的问题，比如发送数据我们的数据定义为多大合适。但是最后没有实际的项目验证，在此也不好回答。先贴一段代码出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class UDPServer extends BaseThread &#123; /** * 发送队列大小 */ public static final int SENDQUEUESIZE = 10; /** * 接收队列大小 */ public static final int RECEIVEQUEUESIZE = 10; /** * UDP接收缓存大小 */ public static final int RECEIVERBUFFERSIZE = 1024; /** * UDP接收缓存大小 */ public static final int RECEIVERPACKETSIZE = 1024 * 64; private int count = 0; private DatagramPacket receivePacket; private DatagramSocket mSocket; @Override public boolean prepare() &#123; receivePacket = new DatagramPacket(new byte[RECEIVERPACKETSIZE], RECEIVERPACKETSIZE); try &#123; mSocket = new DatagramSocket(9559); &#125; catch (SocketException e) &#123; System.out.println(String.format(\"udp connect init error: %s\", e.getMessage())); return false; &#125; return true; &#125; @Override public void execute() &#123; try &#123; mSocket.receive(receivePacket); byte[] data = receivePacket.getData(); int length = receivePacket.getLength(); int offset = receivePacket.getOffset(); System.out.print(++count + String.format(\"length:%d|%d, offset:%d, data: %s \\n\", length, data.length, offset, new String(data, \"gbk\"))); System.out.println(data[1024]); &#125; catch (SocketException e) &#123; System.out.println(String.format(\"udp connect init error: %s\", e.getMessage())); &#125; catch (IOException e) &#123; System.out.println(String.format(\"udp connect init error: %s\", e.getMessage())); &#125; &#125;&#125; byte[] data = receivePacket.getData(); 这个地方拿到的data是缓冲区的大小，他们地址是一样的，这个大家可以试试就知道。至于这个data中有多少数据，就需要我们通过 receivePacket.getLength(); 拿到。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ttdevs.github.io/tags/Java/"}]},{"title":"「Java」Java中获取本地IP和Port","slug":"[Java]Java中获取本地IP和Port","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Java]Java中获取本地IP和Port/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Java]Java中获取本地IP和Port/","excerpt":"","text":"0x00 问题项目中要用到DatagramSocket，同时也要获取本地的IP和PORT，直接创建并获取端口获取的IP总是0.0.0.0，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static void testGetDatagramSocket() &#123; try &#123; DatagramSocket socket = new DatagramSocket(); System.out.println(socket.getLocalSocketAddress()); socket.close(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125;&#125;``` 输出结果：`0.0.0.0/0.0.0.0:55816`## 0x01 解决查了些资料，比如查询可用端口并绑定，没有现成方法，好像实现不了。个中原因也没太多时间去细究，好像是还没和网卡关联（纯属个人YY）。由于项目对本地端口没有特别要求，自己写了一个方法获取DatagramSocket，如下：``` java/** * 从最大端口开始向下遍历，有可能端口就返回 * * @return DatagramSocket, 为null的可能性极小 */public static DatagramSocket getDatagramSocket() &#123; DatagramSocket socket = null; int port = 65535; while (port &gt; 0) &#123; try &#123; socket = new DatagramSocket(new InetSocketAddress(InetAddress.getLocalHost(), --port)); System.out.println(port); break; &#125; catch (SocketException e) &#123; e.printStackTrace(); continue; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); continue; &#125; &#125; return socket;&#125; 出现异常继续运行，代价使用者自行斟酌。 0x02 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainTest &#123; public static void main(String[] args) &#123; testGetDatagramSocket(); testGetUDPSocketInfo(); testGetLocalHost(); &#125; private static void testGetDatagramSocket() &#123; try &#123; DatagramSocket socket = new DatagramSocket(); System.out.println(socket.getLocalSocketAddress()); socket.close(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; private static void testGetUDPSocketInfo() &#123; DatagramSocket socket = getDatagramSocket(); System.out.println(socket.getLocalSocketAddress()); socket.close(); &#125; /** * 从最大端口开始向下遍历，有可能端口就返回 * * @return DatagramSocket, 为null的可能性极小 */ public static DatagramSocket getDatagramSocket() &#123; DatagramSocket socket = null; int port = 65535; while (port &gt; 0) &#123; try &#123; socket = new DatagramSocket(new InetSocketAddress(InetAddress.getLocalHost(), --port)); System.out.println(port); break; &#125; catch (SocketException e) &#123; e.printStackTrace(); continue; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); continue; &#125; &#125; return socket; &#125; private static void testGetLocalHost() &#123; try &#123; InetAddress address = InetAddress.getLocalHost(); System.out.println(address.getHostAddress()); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ttdevs.github.io/tags/Java/"}]},{"title":"「Java」NumberFormatException之InvalidFloat分析","slug":"[Java]NumberFormatException之InvalidFloat分析","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Java]NumberFormatException之InvalidFloat分析/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Java]NumberFormatException之InvalidFloat分析/","excerpt":"","text":"0x00 问题新版本上线，4天时间一个错误出现一百多次，如下： 12345java.lang.NumberFormatException: Invalid float: \"55,4\" at java.lang.StringToReal.invalidReal(StringToReal.java:63) at java.lang.StringToReal.initialParse(StringToReal.java:164) at java.lang.StringToReal.parseFloat(StringToReal.java:323) at java.lang.Float.parseFloat(Float.java:306) 0x01 分析发现此问题后感觉很熟悉，以前应该是见过，但是忘记怎么解决的了，没办法，踩过的坑再踩一遍。涉及的代码如下： 12345678910111213141516public class OnePreference&#123; ... public static void setLatestWeight(float weight) &#123; getInstance(MyApplication.getContext()).putFloat(PREFS_LATEST_WEIGHT, Float.parseFloat(NumberUtils.formatFloatWithOneDot(weight))); &#125; ...&#125;public class NumberUtils &#123; ... public static String formatFloatWithOneDot(float number) &#123; number = Math.round(number * 10) / 10f; return String.format(\"%.1f\", number); &#125; ...&#125; 确认问题 android无法复现，iOS后台未报此错误 怀疑是数据的问题 这是一个记录体重的功能，新版体重输入已经做了限制，所以怀疑可能是老数据的问题。因此找后端的同事降此数据做处理：如果此字段无法解析为数字则过滤掉。 但是遗憾的，后端发布之后问题依然存在。 分析代码 setLatestWeight(float weight) 这个传入的是float，所以之前的假设是错误的 —— 如果是数据的问题，那根本走不到方法里。 这样的话那就是 formatFloatWithOneDot(float number) 这个方法的问题，但是想了下之前都有这么写过 —— 将float类型格式化为一位小数的字符串，应该没问题啊。那会是怎样呢？可能很自然会想到国际化的问题。遂作了一个简单的测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ExampleUnitTest &#123; @Test public void testStringLocale() throws Exception &#123; Locale[] locales = new Locale[]&#123; Locale.CANADA, Locale.CANADA_FRENCH, Locale.CHINESE, Locale.ENGLISH, Locale.FRANCE, Locale.GERMAN, Locale.GERMANY, Locale.ITALIAN, Locale.ITALY, Locale.JAPAN, Locale.JAPANESE, Locale.KOREA, Locale.KOREAN, Locale.PRC, Locale.ROOT, Locale.SIMPLIFIED_CHINESE, Locale.TAIWAN, Locale.TRADITIONAL_CHINESE, Locale.UK, Locale.US &#125;; String weightString = null; for (Locale locale : locales) &#123; try &#123; weightString = formatFloatWithOneDot(locale, 55.4f); float weight = Float.parseFloat(weightString); &#125; catch (NumberFormatException e) &#123; System.out.println(locale + \"&gt;&gt;&gt;&gt;&gt;\" + weightString + \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; error\"); continue; &#125; System.out.println(locale + \"&gt;&gt;&gt;&gt;&gt;\" + weightString); &#125; &#125; public static String formatFloatWithOneDot(Locale locale, float number) &#123; number = Math.round(number * 10) / 10f; return String.format(locale, \"%.1f\", number); &#125;&#125; 输出结果如下： 12345678910111213141516171819202122en_CA&gt;&gt;&gt;&gt;&gt;55.4fr_CA&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorzh&gt;&gt;&gt;&gt;&gt;55.4en&gt;&gt;&gt;&gt;&gt;55.4fr_FR&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorde&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorde_DE&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorit&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorit_IT&gt;&gt;&gt;&gt;&gt;55,4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errorja_JP&gt;&gt;&gt;&gt;&gt;55.4ja&gt;&gt;&gt;&gt;&gt;55.4ko_KR&gt;&gt;&gt;&gt;&gt;55.4ko&gt;&gt;&gt;&gt;&gt;55.4zh_CN&gt;&gt;&gt;&gt;&gt;55.4&gt;&gt;&gt;&gt;&gt;55.4zh_CN&gt;&gt;&gt;&gt;&gt;55.4zh_TW&gt;&gt;&gt;&gt;&gt;55.4zh_TW&gt;&gt;&gt;&gt;&gt;55.4en_GB&gt;&gt;&gt;&gt;&gt;55.4en_US&gt;&gt;&gt;&gt;&gt;55.4Process finished with exit code 0 我们可以看到，在不同的语言下 `String.format(locale, &quot;%.1f&quot;, number)` 格式化的结果是不一样的，55.4可能会被格式化为55,4，然后就出现了上面的错误。将我们的测试机语言设置成出错的语言，问题可以复现。 再来看下后台的错误： ![错误信息]() - 大部分是华为的设备，然后是三星，索尼 - 各个版本都有，从4.4到最新的7.0 - 不同的渠道都有，主要的渠道来自华为 这些信息也从侧面反映了问题的原因。看来华为的国际化之路还是很屌的。 0x02 解决 由于我们并没有做国际化的适配，因此这里改起来还是很方便的，直接给 String.format() 方法指定Locale信息： String.format(Locale.ENGLISH, &quot;%.1f&quot;, number); or String.format(Locale.CHINA, &quot;%.1f&quot;, number); NumberFormat(DecimalFormat)","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ttdevs.github.io/tags/Java/"}]},{"title":"「Python」Python中的Thread Local","slug":"[Python]Python中的Thread Local","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Python]Python中的Thread Local/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Python]Python中的Thread Local/","excerpt":"","text":"在线程内部，我们可能会用到线程内部的全局变量，这个也是比较常用的，因为可以全局访问。但是，如果线程内部的方法比较多，这个时候就需要我们一层层的传递，一层还好，二层三层甚至更多的时候就比较郁闷了。如果不传递，那么我们可能很难拿到线程内部的全局变量，这个时候我们就希望有个应用内的全局变量，供我们随时调用，thread local就可以满足我们的需求。看一个demo： 12345678910111213141516171819202122232425import threadinglocal = threading.local()def end_learning(): print('%s is finish.(Current Thread: %s)' % (local.name, threading.current_thread().name))def start_learning(): print('%s is learning.(Current Thread: %s)' % (local.name, threading.current_thread().name)) end_learning()def learn_python(name): local.name = name start_learning()if __name__ == '__main__': thread1 = threading.Thread(target=learn_python, args=('ttdevs1',), name='Thread-A') thread1.start() thread2 = threading.Thread(target=learn_python, args=('ttdevs2',), name='Thread-B') thread2.start() 执行结果如下：123456ttdevs1 is learning.(Current Thread: Thread-A)ttdevs1 is finish.(Current Thread: Thread-A)ttdevs2 is learning.(Current Thread: Thread-B)ttdevs2 is finish.(Current Thread: Thread-B)Process finished with exit code 0 从上面的demo中，我们可以还可以看到：线程A和线程B之间的数据是没有相互干扰的。 看到这里你可能会感觉这个不是特别简单嘛。是的，这个就是很简单，通过查看源码我们可以发现，他的实现就是通过一个字典来存放我们不同线程的数据，我们也可以自己实现的。既然系统实现了，我们就可以直接拿来用了。 比如，在实际的应用中，我们可以为每个线程保存一个数据库连接，在线程的不同方法中使用就非常的方便了。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ttdevs.github.io/tags/Python/"}]},{"title":"「Python」使用requests处理cookie","slug":"[Python]使用requests处理cookie","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Python]使用requests处理cookie/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Python]使用requests处理cookie/","excerpt":"","text":"0x00 需求常见的 application/json 请求，如果token进行验证，我们可以在header或者body中直接添加，对于使用cookie进行验证的请求，虽然可以自己维护cookie，但是会比token麻烦很多。 之前的忘了请求都是使用python3的urllib进行，当处理cookie时，发现比较困难，因此着手另寻他法，这样就发现了requests。简单看了下，使用起来比urllib方便了好多，好多。不紧紧实现了手动添加cookie的需求，其他接口使用也是相当友好。有时间打算吧之前的代码重构一下。 下面简单介绍下requests的使用。 0x01 requestsRequest GET 无参数 1&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/events&apos;)` - url参数 1234&gt;&gt;&gt; payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;&gt;&gt;&gt; r = requests.get(&apos;http://httpbin.org/get&apos;, params=payload)&gt;&gt;&gt; print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1 输出： 12&gt;&gt;&gt; print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1 POST - form参数 1r = requests.post(&apos;http://httpbin.org/post&apos;, data = &#123;&apos;key&apos;:&apos;value&apos;&#125;) - json参数 1234567891011121314151617181920212223&gt;&gt;&gt; import json&gt;&gt;&gt; url = &apos;https://api.github.com/some/endpoint&apos;&gt;&gt;&gt; payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload)) ``` - file `TODO`- Other: - PUT: `r = requests.put(&apos;http://httpbin.org/put&apos;, data = &#123;&apos;key&apos;:&apos;value&apos;&#125;)` - DELETE: `r = requests.delete(&apos;http://httpbin.org/delete&apos;)` - HEAD: `r = requests.head(&apos;http://httpbin.org/get&apos;)` - OPTIONS: `r = requests.options(&apos;http://httpbin.org/get&apos;)` - HEADER ``` shell&gt;&gt;&gt; url = &apos;https://api.github.com/some/endpoint&apos;&gt;&gt;&gt; headers = &#123;&apos;user-agent&apos;: &apos;my-app/0.0.1&apos;&#125;&gt;&gt;&gt; r = requests.get(url, headers=headers) COOKIES 请求： 123&gt;&gt;&gt; url = &apos;http://httpbin.org/cookies&apos;&gt;&gt;&gt; cookies = dict(cookies_are=&apos;working&apos;)&gt;&gt;&gt; r = requests.get(url, cookies=cookies) 请求的数据： 1234567GET /cookies HTTP/1.1Host: httpbin.orgConnection: keep-aliveUser-Agent: python-requests/2.12.4Accept-Encoding: gzip, deflateAccept: */*Cookie: cookies_are=working Response12&gt;&gt;&gt; import requests&gt;&gt;&gt; response = requests.get(&apos;https://api.github.com/events&apos;) response.url response.encoding 编码 response.status_code 状态吗 response.headers headers response.text 返回的文本 response.json() json response.raw 原始数据 response.raise_for_status() 错误请求信息 response.cookies response.history 0x03 总结使用过urllib的话，来看requests你会发现简单好多，同时支持python2 和 python3。 0xFF 参考 https://pypi.python.org/pypi/requests http://docs.python-requests.org/en/master/ https://github.com/kennethreitz/requests","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ttdevs.github.io/tags/Python/"}]},{"title":"「Python」文件拷贝工具Shutil介绍","slug":"[Python]文件拷贝工具Shutil介绍","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Python]文件拷贝工具Shutil介绍/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Python]文件拷贝工具Shutil介绍/","excerpt":"","text":"一哥们让帮写个脚本：从一个文件夹中按照指定的规则拷贝部分文件。给半小时时间，虽然水平很菜没有信心，但还是应下了这个需求。 0x01 分析首先想到的就是os，sys这些系统库完成这些操作，由于不熟悉这几个库，还是google一下。不过在搜索的时候发现了这个库： shutil。查看了下简直太简单，一行代码完成拷贝。自己之前还想着创建目录，检查文件是否存在，文件读写，各种问题…… 0x02 shutilshutil是一个python提供的高级文件操作工具，他可以帮助我们快速的进行常规文件操作。文件拷贝操作如下： shutil.copyfile(src, dst, *, follow_symlinks=True) 第一个参数原文件，第二个参数目标文件位置。简单吧，想想如果java写的话，各种判断，各种iostream，各种蛋疼啊，python就一行啊啊啊啊…… 方法说明 copy(src, dst) 将文件src复制到文件dst，包含权限 copy2(src, dst) 同copy，同时复制文件元数据 copyfile(src, dst) 将文件src复制到文件dst，但不包含元数据 copymode(src, dst) 复制文件权限 copystat(src, dst) 将权限位、 最后存取时间、 最后修改时间和标志从src复制到dst copytree(src, dst, symlinks=False, ignore=None) 递归复制目录 rmtree(path[, ignore_errors[, onerror]]) 删除目录 move(src, dst) 递归移动目录 Demo1234567891011121314151617import shutil SOURCE = &#123; \"1f604\", ... \"1f349\"&#125; def replace(): base_path = \"drawable/\" dest_path = \"drawable_dest/\" for name in SOURCE: file_name = base_path + \"emoji_\" + name + \".png\" dest_name = dest_path + \"emoji_\" + name + \".png\" shutil.copy(file_name, dest_name) if __name__ == '__main__': replace()","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ttdevs.github.io/tags/Python/"}]},{"title":"「Retrofit」0x00初探","slug":"[Retrofit]0x00初探","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Retrofit]0x00初探/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Retrofit]0x00初探/","excerpt":"","text":"0x00 Retrofit很久以前就计划要研究一下，但是一直拖到现在，不知道是因为优先级放的比较低还是因为拖延症。总只，现在要完整的看一遍。 由于这个已经出来很久了，所以我就直接选择了Refrofit2，没有去关注Refrofit1，等看完Refrofit2有时间的话再去看看Refrofit1，看看它们的变迁。好了，先从Refrofit2开始吧。 0x01 简介简介如果你接触Android时间比较长，从最初的自己封装线程，到使用异步任务，到开源的各种第三方网络请求框架如xUtils，到谷歌的Volley，androider总在探索一种更好的网络请求形式。Retrofit就是这样的一款产品。 PS：从上面一句话，我们也可以看到，android生态在不断的进步和完善～～ 引入两个问题，gradle和混淆： Gradle： Retrofit： compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39; JSON解析器： compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39; Proguard： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions ``` ## 0x02 从一个demo开始``` java public class ExampleUnitTest &#123; @Test public void test_retrofit() throws Exception&#123; String url = &quot;http://api.github.com/&quot;; OkHttpClient client = new OkHttpClient.Builder() .build(); Retrofit.Builder builder = new Retrofit.Builder() .client(client) .baseUrl(url) .addConverterFactory(GsonConverterFactory.create()); Retrofit retrofit = builder.build(); GitHubService github = retrofit.create(GitHubService.class); Call&lt;User&gt; ttdevs = github.userInfo(&quot;ttdevs&quot;); final CountDownLatch countDownLatch = new CountDownLatch(1); ttdevs.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User ttdevs = response.body(); String message = String.format( &quot;I&apos;m %s.\\n%s&quot;, ttdevs.getName(), ttdevs.getHtml_url()); System.out.println(message); countDownLatch.countDown(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; countDownLatch.countDown(); &#125; &#125;); countDownLatch.await(); &#125;&#125; 0x03 第一个问题：Header执行上面的小demo，我们通过抓包发现它的header信息如下： 123Host: api.github.com:443Proxy-Connection: Keep-AliveUser-Agent: okhttp/3.3.0 这个header信息是不是很简单，如果你用这样的请求去写爬虫的话，多数情况下是得不到结果的。而实际情况也是：我们需要在header中使用标准http头信息，也可能需要加入自定义的头信息，比如token等。Retrofit2没有直接给他们提供这样的方法，但是我们知道，Retrofit2用的是Okhttp3，因此，我们可以从Okhttp3中下手，代码如下： 创建 HeadersInterceptor 类，代码如下： 123456789101112131415161718192021222324252627282930public class HeadersInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request original = chain.request(); Request request = original.newBuilder() .header(\"User-Agent\", \"ttdevs\") .header(\"Content-Type\", \"application/json; charset=utf-8\") .header(\"Accept\", \"application/json\") .header(\"token\", \"abcdefg_ttdevs_hijklmn\") .header(\"user_key\", \"ttdevs\") .method(original.method(), original.body()) .build(); long t1 = System.nanoTime(); String requestHeader = String.format(\"&gt;&gt;&gt;&gt;&gt;Sending request %s on %s%n%s\", request.url(), chain.connection(), request.headers()) System.out.println(requestHeader); Response response = chain.proceed(request); long t2 = System.nanoTime(); System.out.println(String.format(\"&gt;&gt;&gt;&gt;&gt;Received response for %s in %.1fms%n%s\", response.request().url(), (t2 - t1) / 1e6d, response.headers())); System.out.println(\"=====================================================\"); return response; &#125;&#125; 在 Okhttp 中加入 HeadersInterceptor 1234567891011String url = \"http://api.github.com/\";OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new HeadersInterceptor()) .build();Retrofit.Builder builder = new Retrofit.Builder() .client(client) .baseUrl(url) .addConverterFactory(GsonConverterFactory.create());Retrofit retrofit = builder.build();GitHubService github = retrofit.create(GitHubService.class);Call&lt;User&gt; ttdevs = github.userInfo(\"ttdevs\"); 这样在运行上面的代码，我们就可以在 Http 请求的 Header 中看到我们加入的信息了。 源码参考：ttdevs 0xFF 参考 https://github.com/square/retrofit http://square.github.io/retrofit/ https://futurestud.io/blog/retrofit-add-custom-request-header","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://ttdevs.github.io/tags/Retrofit/"}]},{"title":"「Retrofit」0x02Header问题补充","slug":"[Retrofit]0x02Header问题补充","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Retrofit]0x02Header问题补充/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Retrofit]0x02Header问题补充/","excerpt":"","text":"0x00 Retrofit Header上一篇中我们介绍Retrofit的一个简单的Demo和添加Header方法，这一篇在补充一下Header的另外几种处理方法。 0x01 Header 使用OkHTTP的Interceptor来处理Header信息，这种方法是需要我们在封装Retrofit的时候考虑的。但是有时候我们还希望能灵活的控制每一个请求的Header信息，接下来的几种方法满足我们这样的要求。他们都是在各自的Service方法上添加注解来达到添加Header的目的。 添加单个Header字段123@Headers(\"User-Agent: Your-App-Name\")@GETpublic Call&lt;ResponseBody&gt; weatherReport(String cityCode); 添加多个Header字段123456@Headers(&#123; \"Accept: application/json\", \"User-Agent: ttdevs\"&#125;)@GETpublic Call&lt;ResponseBody&gt; weatherReport(String cityCode); 使用Map添加单个Header字段12@GETpublic Call&lt;ResponseBody&gt; requestWithHeaderMap(@HeaderMap Map&lt;String, String&gt; header); 源码参考：ttdevs 0xFF 参考 https://github.com/square/retrofit http://square.github.io/retrofit/ https://futurestud.io/","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://ttdevs.github.io/tags/Retrofit/"}]},{"title":"「Retrofit」0x01请求参数","slug":"[Retrofit]0x01请求参数","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Retrofit]0x01请求参数/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Retrofit]0x01请求参数/","excerpt":"","text":"0x00 请求参数常见的Http请求，除了指定的请求地址，很多时候我们还需要加上一些请求参数，这些参数可能是固定的，也可能是动态添加的。在Retrofit中，我们该如何处理呢？这里以GET方式中添加请求参数为例。 0x01 固定请求参数这里说的固定请求参数是指每次请求我们都在Url中添加相同的请求的参数。这种场景多出现在需要认证的情况，比如添加 Token 字段等。 在之前的文章中，我们有提到在构建OkHttpClient对象的时候使用过 Interceptor ，在 Interceptor 的逻辑中，我们会重新创建一个 Request 对象，在这个对象中我们可以传入一个 HttpUrl ，在这个对象中，我们可以传入一些需要的请求参数。通过之前对 Interceptor 了解，我们应该知道，这里做的操作是对所有的请求都有效的。这样就可以完成我们为每个请求添加固定请求参数的目的。代码如下： 123456789101112131415161718192021222324OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request original = chain.request(); HttpUrl originalHttpUrl = original.url(); HttpUrl url = originalHttpUrl .newBuilder() .addQueryParameter(\"token\", \"I_am_user_token\") .addQueryParameter(\"user_key\", \"I_am_user_user_key\") .build(); Request request = original .newBuilder() .url(url) .build(); okhttp3.Response response = chain.proceed(request); return response; &#125; &#125;) .build(); 0x02 动态请求参数这个指我们在不同的请求中添加不同过的请求参数。比如，在请求用户信息的接口中我们可能需要传入用户ID，在请求记录的接口中我们需要传入起止时间等。由于这样的参数是针对接口的，因此我们就需要在每一个接口做中处理。 @Query 添加一个请求参数 123// http://119.29.29.29/d?dn=ttdevs.vicp.com@GET(\"/d\")public Call&lt;ResponseBody&gt; singleParams(@Query(\"dn\") String domain); 通过上面的方式，我们发出的请求就是： `http://119.29.29.29/d?dn={domain}` @QueryMap 添加一组请求参数 12@GET(\"/record\") public Call&lt;ResponseBody&gt; multiParams(@QueryMap(encoded = true) Map&lt;String, String&gt; options); 上面我们发出的请求是： http://ttdevs.vicp.net/record?p1=v1&amp;p2=v2 这个这个例子中还可以看到，我们使用了一个参数：encoded = true，这个参数的意思是，对我们的参数进行URL Encode。 0x03 总结通过上面的介绍，我们可以了解，如果添加我们的请求参数。当需要给每一个请求都添加相同参数时该如何封装，把Retrofit打造成更适合我们使用的工具。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://ttdevs.github.io/tags/Retrofit/"}]},{"title":"「Retrofit」0x03同步与异步请求","slug":"[Retrofit]0x03同步与异步请求","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Retrofit]0x03同步与异步请求/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Retrofit]0x03同步与异步请求/","excerpt":"","text":"0x00 请求的形式我们正常的网络请求有两种形式：同步方式和异步方式。所谓同步方式，是指我们在在发出网络请求之后当前线程呗阻塞，直到请求的结果（成功或者失败）到来，才继续向下执行。所谓异步，是指我们的网络请求发出之后，不必等待请求结果的到来，就可以去做其他的事情，当请求结果到来时，我们在做处理结果的动作。当时无论是同步还是异步，最终都是同步请求。 0x01 同步请求Retrofit的同步请求比较简单，直接调用 Call 的execute方法即可。这个时候我们会拿到请求的结果。 12345678@Test public void synchronousRequest() throws Exception &#123; Retrofit retrofit = RetrofitManager.getRetrofit(); GitHubService service = retrofit.create(GitHubService.class); Call&lt;User&gt; example = service.userInfo(\"ttdevs\"); Response&lt;User&gt; response = example.execute(); print(response.body().getName()); &#125; 0x02 异步请求之前文章的请求都是异步方式，在请求的回调中我们会拿到请求结果，接下来 处理这个结果即可。 1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void requestHeader() throws Exception &#123; OkHttpClient client = RetrofitManager.getClient(new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request original = chain.request(); Request request = original.newBuilder() .header(\"Time-Zone\", \"Asia/Shanghai\") //https://developer.github.com/v3/#timezones .header(\"user_key\", \"I_am_user_key\") .method(original.method(), original.body()) .build(); okhttp3.Response response = chain.proceed(request); return response; &#125; &#125;); Retrofit retrofit = RetrofitManager.getRetrofit(client); ExampleService service = retrofit.create(ExampleService.class); String url = \"http://www.weather.com.cn/adat/sk/101020100.html\"; Call&lt;ResponseBody&gt; example = service.requestWithHeader(url); final CountDownLatch countDownLatch = new CountDownLatch(1); example.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; print(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; countDownLatch.countDown(); &#125; &#125;); countDownLatch.await(); &#125; 总结由于同步请求会阻塞当前线程，android的设计逻辑不能在主线程中发起网络请求（可能会导致ANR），所以我们比较常见的都是异步形式的网络请求。但是，有时候我们在工作线程中处理一些网络请求的时候，可以接受阻塞的情况（这个时候使用回调往往会使问题复杂化），那么我们就可以使用同步的方式来发起网络请求，比如，在使用Rxjava封装某个网络功能的逻辑是（如图片上传）我们就可以同步形式的网络请求。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://ttdevs.github.io/tags/Retrofit/"}]},{"title":"「Retrofit」0x04POST方式提交JSON数据","slug":"[Retrofit]0x04POST方式提交JSON数据","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Retrofit]0x04POST方式提交JSON数据/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Retrofit]0x04POST方式提交JSON数据/","excerpt":"","text":"0x00 HTTP Method：POSTPOST请求再日常的使用中很常见，比如登录，上传数据中使用。之前介绍了GET方式，今天简单介绍下如何使用POST来提交数据。 0x01 常用的POST方式POST方式提交数据再浏览器中的表现主要是使用Form，在客户端中国中的主要表现是提交JSON数据。当然，具体是什么数据格式并不重要，我们可以通过抓包来分析：最终数据都是一样的。 使用Model对象首先新建一个model对象，比如：User，添加常用的熟悉和get／set方法。新建我们的Service： 12@POST(\"/send\")public Call&lt;ResponseBody&gt; modelPost(@Url String url, @Body User user); 测试代码： 1234567891011121314151617181920212223242526272829303132333435@Testpublic void modelPost() throws Exception &#123; HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BASIC); OkHttpClient client = RetrofitManager.getClient(logging); Retrofit retrofit = RetrofitManager.getRetrofit(client); ExampleService service = retrofit.create(ExampleService.class); String url = \"http://www.remoteurl.com\"; User user = new User(); user.setName(\"ttdevs\"); Call&lt;ResponseBody&gt; example = service.modelPost(url, user); final CountDownLatch countDownLatch = new CountDownLatch(1); example.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; print(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; countDownLatch.countDown(); &#125; &#125;); countDownLatch.await();&#125; 使用RequestBody对象这里我们来提交一份JSON数据，首先还是再Service中创建一个方法： 12@POST(\"/send\")public Call&lt;ResponseBody&gt; withRequestBody(@Url String url, @Body RequestBody body); 再接着创建我们的请求： 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void withRequestBody() throws Exception &#123; HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BASIC); OkHttpClient client = RetrofitManager.getClient(logging); Retrofit retrofit = RetrofitManager.getRetrofit(client); ExampleService service = retrofit.create(ExampleService.class); String url = \"http://www.remoteurl.com\"; JSONObject result = new JSONObject(); try &#123; result.put(\"record\", \"hello\"); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; RequestBody body = RequestBody.create(MediaType.parse(\"application/json\"), result.toString()); Call&lt;ResponseBody&gt; example = service.withRequestBody(url, body); final CountDownLatch countDownLatch = new CountDownLatch(1); example.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; print(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; countDownLatch.countDown(); &#125; &#125;); countDownLatch.await();&#125; 0x02 总结第一种方法，我们需要为每一个请求的对象创建一个Model，如果你不想创建model则可以选择第二种方式，直接创建一个JSON字符串，然后提交即可。还是相当简答的。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://ttdevs.github.io/tags/Retrofit/"}]},{"title":"「Volley」0x04一些细节","slug":"[Volley]0x04一些细节","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Volley]0x04一些细节/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Volley]0x04一些细节/","excerpt":"","text":"最近又把volley拿出来整理了下。之前没有遇到过的一些小问题又来了，在此记录下： 1、HttpUrlConnection DELETE 方式无法添加body的问题：java.net.ProtocolException:DELETE does not support writing 这个可以算是一个系统级的bug，为什么这么说，请看这里，这个问题在java8中才得以解决。没办法直接过去，咱就绕过去。查看HttpUrlConnection，我们发现他是一个抽象类，因此可以试试能不能通过它的其他实现来达到我们的目的。最终我们决定使用 okhttp 这个实现。地址为： https://github.com/square/okhttp 。 接着我们还得去看看volley的源码，由于我们的app兼容的最低版本是4.0，因此我们知道最终调用的是HurlStack： public static RequestQueue newRequestQueue(Context context, HttpStack stack) { ... if (stack == null) { if (Build.VERSION.SDK_INT &gt;= 9) { stack = new HurlStack(); } else { // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } ... } 因此我们只需要将HurlStack的相关代码修改即可，如下： volley.java public static RequestQueue newRequestQueue(Context context, HttpStack stack) { ... if (stack == null) { if (Build.VERSION.SDK_INT &gt;= 9) { // old way: stack = new HurlStack(); // http://square.github.io/okhttp/ stack = new HurlStack(null, null, new OkUrlFactory(new OkHttpClient())); } else { // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } ... } HurlStack.java /** * An {@link HttpStack} based on {@link HttpURLConnection}. */ public class HurlStack implements HttpStack { private final OkUrlFactory mOkUrlFactory; /** * @param urlRewriter Rewriter to use for request URLs * @param sslSocketFactory SSL factory to use for HTTPS connections * @param okUrlFactory solution delete body(https://github.com/square/okhttp) */ public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory, OkUrlFactory okUrlFactory) { mUrlRewriter = urlRewriter; mSslSocketFactory = sslSocketFactory; mOkUrlFactory = okUrlFactory; } /** * Create an {@link HttpURLConnection} for the specified {@code url}. */ protected HttpURLConnection createConnection(URL url) throws IOException { if(null != mOkUrlFactory){ return mOkUrlFactory.open(url); } return (HttpURLConnection) url.openConnection(); } @SuppressWarnings(&quot;deprecation&quot;) /* package */ static void setConnectionParametersForRequest(HttpURLConnection connection, Request&lt;?&gt; request) throws IOException, AuthFailureError { switch (request.getMethod()) { ... case Method.DELETE: connection.setRequestMethod(&quot;DELETE&quot;); addBodyIfExists(connection, request); break; ... default: throw new IllegalStateException(&quot;Unknown method type.&quot;); } } ... } 2015-04-26更新： 再次使用到需要使用到okhttp，回头看下上面的代码，不知道当时怎么想的，使用这么复杂的方法引入Okhttp，估计是脑袋进水了。再来看下这个方法：newRequestQueue(Context context, HttpStackstack)，有两个参数：context和HttpStack，这里是要传入自己的HttpStack就好了。那么我们用OKhttp的实现： /** * An {@link com.android.volley.toolbox.HttpStack HttpStack} implementation which * uses OkHttp as its transport. */ public class OkHttpStack extends HurlStack { private final OkHttpClient client; public OkHttpStack() { this(new OkHttpClient()); } public OkHttpStack(OkHttpClient client) { if (client == null) { throw new NullPointerException(&quot;Client must not be null.&quot;); } this.client = client; } @Override protected HttpURLConnection createConnection(URL url) throws IOException { return client.open(url); } } 参考： https://gist.github.com/JakeWharton/5616899 2、关于（修改）volley的缓存volley有完整的一套缓存机制。而目前我们想做个简单的需求：部分界面（几乎不会改动的）简单的做一定时间的缓存，研究了下代码发现很容易修改达到自己的目的（有时间在分析下volley的缓存机制，这个一定要做）。简单来说修改一个地方：request. parseNetworkResponse中的 HttpHeaderParser（此处突然感慨volley的设计TMD灵活了，想怎么改就怎么改）。 HttpHeaderParser修改后的代码如下： /** * 修改后的，用户处理缓存 */ public class BHHttpHeaderParser { /** * Extracts a {@link Cache.Entry} from a {@link NetworkResponse}. * * @param response The network response to parse headers from * @return a cache entry for the given response, or null if the response is not cacheable. */ public static Cache.Entry parseCacheHeaders(NetworkResponse response, boolean isCustomCache) { ... if(isCustomCache){ softExpire = now + Config.HTTP_CACHE_TTL; } else { if (hasCacheControl) { softExpire = now + maxAge * 1000; } else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) { // Default semantic for Expire header in HTTP specification is softExpire. softExpire = now + (serverExpires - serverDate); } } Cache.Entry entry = new Cache.Entry(); entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; entry.ttl = entry.softTtl; entry.serverDate = serverDate; entry.responseHeaders = headers; return entry; } ... } 此处大家可以发现，我们主要是根据自定义的变量决定如何修改cache的TTL来达到自己的目的。 3、HttpUrlConnection与PATCH（2015-04-26）在使用Volley发送PATCH请求的时候，我们可能会遇到这样的问题：Unknown method ‘PATCH’; must be one of[OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE]。这个时候你的第一反应是什么呢？是Volley不支持PATCH请求吗？换成OkHttp是不是可以呢？查看了下Volley的源码，在HurlHttp.java中发现如下一段： /* package */ static void setConnectionParametersForRequest(HttpURLConnection connection, Request&lt;?&gt; request) throws IOException, AuthFailureError { switch (request.getMethod()) { case Method.DEPRECATED_GET_OR_POST: // This is the deprecated way that needs to be handled for backwards compatibility. // If the request&apos;s post body is null, then the assumption is that the request is // GET. Otherwise, it is assumed that the request is a POST. byte[] postBody = request.getPostBody(); if (postBody != null) { // Prepare output. There is no need to set Content-Length explicitly, // since this is handled by HttpURLConnection using the size of the prepared // output stream. connection.setDoOutput(true); connection.setRequestMethod(&quot;POST&quot;); connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getPostBodyContentType()); DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.write(postBody); out.close(); } break; case Method.GET: // Not necessary to set the request method because connection defaults to GET but // being explicit here. connection.setRequestMethod(&quot;GET&quot;); break; case Method.DELETE: connection.setRequestMethod(&quot;DELETE&quot;); break; case Method.POST: connection.setRequestMethod(&quot;POST&quot;); addBodyIfExists(connection, request); break; case Method.PUT: connection.setRequestMethod(&quot;PUT&quot;); addBodyIfExists(connection, request); break; case Method.HEAD: connection.setRequestMethod(&quot;HEAD&quot;); break; case Method.OPTIONS: connection.setRequestMethod(&quot;OPTIONS&quot;); break; case Method.TRACE: connection.setRequestMethod(&quot;TRACE&quot;); break; case Method.PATCH: connection.setRequestMethod(&quot;PATCH&quot;); addBodyIfExists(connection, request); break; default: throw new IllegalStateException(&quot;Unknown method type.&quot;); } } 通过这段代码，我们知道，Volley对PATCH还是支持的。在细看下错误这个是有HttpUrlConnection抛出的。因此我们需要在这方面下手。这里有一个参考： https://github.com/adriancole/retrofit/commit/e704b800878b2e37f5ac98b0139cb4994618ace0 以后有其他关于volley的总结都记录在此。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"https://ttdevs.github.io/tags/Volley/"}]},{"title":"「WebSocket」使用Websocket实现消息推送(上)","slug":"[WebSocket]使用Websocket实现消息推送(上)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[WebSocket]使用Websocket实现消息推送(上)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[WebSocket]使用Websocket实现消息推送(上)/","excerpt":"","text":"0x00 Websocket联系客服功能在项目中很难避免，一般有下面三种实现方式： 使用http的get方式轮询 接入第三方IM系统 自己的IM系统 基于socket 基于websocket 第一种方式，最low的，实现简单，但是浪费用户流量；第二种方式，接入简单，功能强大，但是可能需要一定的成本（比如付费）；第三种方式，需要一定的开发成本（服务器托管费用忽略）。对于第三种情况的 socket，实现IM的文字加音视频聊天，做过的话你可以也会直接懵逼。但是，简单的文字聊天还好，不过你还是需要去定义一些协议来实现这样一个功能。如果我们使用websocket，那事情就变的简单很多。 WebSocket一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范，WebSocketAPI被W3C定为标准。 WebSocket 是独立的、创建在 TCP 上的协议，和 HTTP 的唯一关联是使用 HTTP 协议的101状态码进行协议切换，使用的 TCP 端口是80，可以用于绕过大多数防火墙的限制。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端直接向客户端推送数据而不需要客户端进行请求，在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并允许数据进行双向传送。 目前常见的浏览器如 Chrome、IE、Firefox、Safari、Opera 等都支持 WebSocket，同时需要服务端程序支持 WebSocket。 来自维基百科 https://zh.wikipedia.org/wiki/WebSocket websocket只是一种协议，类似http，因此与语言无关。这里我使用java来做服务端，同时提供android和html的客户端，通过一个简单的demo来介绍websocket的使用，接下来的一篇会对websocket进行分析。 0x01 服务端这里我使用 Java-WebSocket 这个库来实现 websocket server。需要的jar包位于项目的 /Java-WebSocket/dist/java-websocket.jar 位置。效果如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class SocketServer extends WebSocketServer &#123; private static final int PORT = 2333; public static void main(String[] args) &#123; SocketServer server = new SocketServer(PORT); server.start(); try &#123; String ip = InetAddress.getLocalHost().getHostAddress(); int port = server.getPort(); print(String.format(\"服务已启动: %s:%d\", ip, port)); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; InputStreamReader in = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(in); while (true) &#123; try &#123; String msg = reader.readLine(); server.broadcastMessage(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public SocketServer(int port) &#123; super(new InetSocketAddress(port)); &#125; public SocketServer(InetSocketAddress address) &#123; super(address); &#125; @Override public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) &#123; String address = webSocket.getRemoteSocketAddress().getAddress().getHostAddress(); String message = String.format(\"(%s) &lt;加入&gt;\", address); broadcastMessage(message); print(message); &#125; @Override public void onClose(WebSocket webSocket, int code, String reason, boolean remote) &#123; String address = webSocket.getRemoteSocketAddress().getAddress().getHostAddress(); String message = String.format(\"(%s) &lt;离开&gt;\", address); broadcastMessage(message); print(message); &#125; @Override public void onMessage(WebSocket webSocket, String msg) &#123; String address = webSocket.getRemoteSocketAddress().getAddress().getHostAddress(); String message = String.format(\"(%s) %s\", address, msg); broadcastMessage(message); print(message); &#125; @Override public void onError(WebSocket webSocket, Exception e) &#123; if (null != webSocket) &#123; if (!webSocket.isClosed()) &#123; webSocket.close(0); &#125; &#125; e.printStackTrace(); &#125; /** * 广播收到消息 * * @param msg */ private void broadcastMessage(String msg) &#123; Collection&lt;WebSocket&gt; connections = connections(); synchronized (connections) &#123; for (WebSocket client : connections) &#123; client.send(msg); &#125; &#125; &#125; private static void print(String msg) &#123; System.out.println(String.format(\"[%d] %s\", System.currentTimeMillis(), msg)); &#125;&#125; 0x02 客户端 Android 这里也是用java-websocket这个库，效果如下： 核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183 public class WebSocketActivity extends BaseActivity &#123; private static final int STATUS_CLOSE = 0; private static final int STATUS_CONNECT = 1; private static final int STATUS_MESSAGE = 2; @Bind(R.id.etIP) EditText etIP; @Bind(R.id.etPort) EditText etPort; @Bind(R.id.tvStatus) TextView tvStatus; @Bind(R.id.tvMsg) TextView tvMsg; @Bind(R.id.rgVersion) RadioGroup rgVersion; @Bind(R.id.etMessage) EditText etMessage; @Bind(R.id.svContent) ScrollView svContent; @Bind(R.id.viewMain) View viewMain; @Bind(R.id.btConnect) Button btConnect; @Bind(R.id.btDisconnect) Button btDisconnect; @Bind(R.id.btSend) Button btSend; @OnClick(&#123;R.id.btConnect, R.id.btDisconnect, R.id.btSend&#125;) public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.btConnect: connectToServer(); break; case R.id.btDisconnect: if (null != mClient) &#123; mClient.close(); &#125; break; case R.id.btSend: if (null != mClient) &#123; String msg = etMessage.getText().toString(); if (!TextUtils.isEmpty(msg)) &#123; try &#123; mClient.send(msg); &#125; catch (NotYetConnectedException e) &#123; e.printStackTrace(); return; &#125; etMessage.setText(\"\"); &#125; &#125; break; default: break; &#125; &#125; private Client mClient; private Handler mHandle = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; String message = String.format(\"[%d] %s\\n\", System.currentTimeMillis(), msg.obj.toString()); tvMsg.append(message); switch (msg.what) &#123; case STATUS_CONNECT: btConnect.setEnabled(false); btDisconnect.setEnabled(true); btSend.setEnabled(true); break; case STATUS_CLOSE: btConnect.setEnabled(true); btDisconnect.setEnabled(false); btSend.setEnabled(false); break; case STATUS_MESSAGE: // TODO: 16/8/24 break; default: break; &#125; svContent.postDelayed(new Runnable() &#123; @Override public void run() &#123; svContent.fullScroll(View.FOCUS_DOWN); &#125; &#125;, 100); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_web_socket); ButterKnife.bind(this); System.setProperty(\"java.net.preferIPv6Addresses\", \"false\"); System.setProperty(\"java.net.preferIPv4Stack\", \"true\"); &#125; private void connectToServer() &#123; String ip = etIP.getText().toString(); String port = etPort.getText().toString(); if (TextUtils.isEmpty(ip) || TextUtils.isEmpty(port)) &#123; Snackbar.make(viewMain, \"IP and Port 不能为空\", Snackbar.LENGTH_LONG).show(); return; &#125; String address = String.format(\"ws://%s:%s\", ip, port); Draft draft = null; switch (rgVersion.getCheckedRadioButtonId()) &#123; case R.id.rbDraft10: draft = new Draft_10(); break; case R.id.rbDraft17: draft = new Draft_17(); break; case R.id.rbDraft75: draft = new Draft_75(); break; case R.id.rbDraft76: draft = new Draft_76(); break; default: draft = new Draft_17(); break; &#125; try &#123; URI uri = new URI(address); mClient = new Client(uri, draft); mClient.connect(); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); return; &#125; tvStatus.setText(address); &#125; private class Client extends WebSocketClient &#123; public Client(URI serverURI) &#123; super(serverURI); &#125; public Client(URI serverUri, Draft draft) &#123; super(serverUri, draft); &#125; @Override public void onOpen(ServerHandshake handShakeData) &#123; Message msg = new Message(); msg.what = STATUS_CONNECT; msg.obj = String.format(\"[Welcome：%s]\", getURI()); mHandle.sendMessage(msg); &#125; @Override public void onMessage(String message) &#123; Message msg = new Message(); msg.what = STATUS_MESSAGE; msg.obj = message; mHandle.sendMessage(msg); &#125; @Override public void onClose(int code, String reason, boolean remote) &#123; Message msg = new Message(); msg.what = STATUS_CLOSE; msg.obj = String.format(\"[Bye：%s]\", getURI()); mHandle.sendMessage(msg); &#125; @Override public void onError(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; Html H5使用了这个库：sstephenson/prototype，效果如下： 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type=\"text/javascript\"&gt; document.observe(\"dom:loaded\", function () &#123; function log(text) &#123; var value = (new Date).getTime(); value += \": \"; value += text.escapeHTML(); value += $(\"log\").innerHTML; $(\"log\").innerHTML = value; &#125; if (!window.WebSocket) &#123; alert(\"浏览器不支持,换一个吧\"); &#125; var ws; $(\"connectForm\").observe(\"submit\", function (e) &#123; e.stop(); ws = new WebSocket($F(\"uri\")); ws.onopen = function () &#123; log(\"连接到服务器\\n\"); &#125; ws.onmessage = function (e) &#123; log(\"服务器信息: \" + e.data + \"\\n\"); &#125; ws.onclose = function () &#123; log(\"断开服务器连接\\n\"); $(\"uri\", \"connect\").invoke(\"enable\"); $(\"close\").disable(); ws = null; &#125; $(\"uri\", \"connect\").invoke(\"disable\"); $(\"close\").enable(); &#125;); $(\"close\").observe(\"click\", function (e) &#123; e.stop(); if (ws) &#123; ws.close(); ws = null; &#125; &#125;); $(\"sendForm\").observe(\"submit\", function (e) &#123; e.stop(); if (ws) &#123; var message = $(\"message\"); ws.send(message.value); message.value = \"\"; message.focus(); &#125; &#125;); &#125;);&lt;/script&gt; 所有的代码都可以到github查看：ttdevs。 下一篇将通过对websocket协议的分析，来对其做进一步的了解。 0xFF 参考 https://github.com/sstephenson/prototype https://github.com/TooTallNate/Java-WebSocket/ http://www.cnblogs.com/wlfcolin/p/5193583.html","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://ttdevs.github.io/tags/WebSocket/"}]},{"title":"「WebSocket」使用Websocket实现消息推送(下)","slug":"[WebSocket]使用Websocket实现消息推送(下)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[WebSocket]使用Websocket实现消息推送(下)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[WebSocket]使用Websocket实现消息推送(下)/","excerpt":"","text":"0x00 WebSocket上一篇使用 Java-WebSocket 写了一套 WebSocket 的Demo，这一篇着重分析下WebSocket 的一些实现细节，更加详细的协议细节可参考 RFC6455。 0x01 WebSocket协议 WebSocket 协议: 可参考RFC6455 抓包工具：Charles 和 WireShark 测试代码：参考上一篇Demo 0x02 数据传输 连接和断开 当 Client 向 Server 发起 ws 连接请求后，会先使用 HTTP 协议建立 TCP 长链接，通过抓包，我们会看到类似这样的信息： Request： Response： 这里简单介绍几个关键的Header字段： upgrade:websocket connection:Upgrade sec-websocket-version:13 sec-websocket-key:xxxxxx sec-websocket-accept: 这些字段的信息可参考这里。 数据传输 当 HTTP 连接建立之后，就可以通过这个长链接进行数据传输了。如果你使用 Charles 进行数据抓包的话，可以看到类似下图中这样的聊天内容： 在同一个 HTTP 请求中，我们看到不断有数据交互，而不是像之前的 HTTP 请求那样，每发送一条数据，都需要发起一次新的请求。 下面我们来尝试分析一下。这里要用到Wireshark。可能你会为什么换了Wireshark而不用Charles了？原因很简单，Charles给我们呈现的是应用层最终的结果，而传输层的具体的数据包发送接收却不能展示，这个时候就需要借助Wireshark来对TCP数据包进行分析了。 首先，查询 RFC6455文档，我们得知 ws 协议的数据包格式如下： 有了这个参考，我们就可以进行数据分析了。下面是我的一次数据收发过程：客户端向服务端发送数据：123456789，然后服务端原样发回，抓包如下： Sender： Receiver： 下面我们着重对这两个数据包进行分析。细心的你可能会发现，截图中有四条数据，如果你对TCP的传输有所了解，第二条和第三条是确认报文。 我们先看下接收到数据。点击数据中的 Data(11bytes) 部分，下方是自动选择了数据部分：8109313233343536373839。（在此之前是TCP报文的Header部分，我们可以忽略）根据 ws 协议，我们将其展开： 1234567891011121314151617181920212223242581 09: 10000001 00001001 31 32: 00110001 0011001033 34: 00110011 0011010035 36: 00110101 0011011037 38: 00110111 0011100039 : 00111001``` 0：1，这是最后一帧1～3：全为04～7：001，附加数据帧8：0，PlayloadData未经过掩码 9～15：0001001 = 9 &lt; 125，因此数据长度位9 剩下的：313233343536373839即为数据 123456789再来看看发送的数据。点击 Data(15bytes) 部分，下方的数据部分：818911eb9db220d9ae8624ddaa8a28，展开：``` shell81 89 : 10000001 10001001 11 eb : 00010001 111010119d b2 : 10011101 1011001020 d9 : 00100000 11011001ae 86 : 10101110 1000011024 dd : 00100100 11011101aa 8a : 10101010 1000101028 : 00101000 0：1，这是最后一帧 1～3：全为0 4～7：001，附加数据帧 8：1，PlayloadData经过掩码，（所有的由客户端发往服务端的帧此数位都被设置成 1。） 9～15：0001001 = 9 &lt; 125，因此数据长度位9 11 eb 9d b2：掩码 20 d9 ae 86 24 dd aa 8a 28：数据 关于掩码的计算： 连接保持 除了正常的数据传输之外，Socket编程还有一个重要的组成部分：心跳保持。ws协议中定义了专门的数据包： Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented. 其他 一个协议不可能就这么简单，如果你还想了解更多，可参考RFC6455。 0xFF 参考 http://www.jianshu.com/p/867274a5e054 http://www.jianshu.com/p/fc09b0899141 https://datatracker.ietf.org/doc/rfc6455/ https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://ttdevs.github.io/tags/WebSocket/"}]},{"title":"「WebSocket」使用Websocket实现消息推送(心跳)","slug":"[WebSocket]使用Websocket实现消息推送(心跳)","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[WebSocket]使用Websocket实现消息推送(心跳)/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[WebSocket]使用Websocket实现消息推送(心跳)/","excerpt":"","text":"0x00 心跳本来以为写完了，结果最近和一个同事在讨论心跳的事情，这里再做一个补充。先说我的结论： WebSocket协议已经设计了心跳，这个功能可以到达检测链接是否可用 心跳是用来检测链接是否可用的，不一定支持携带数据，可要看具体实现 如果非要心跳中带上复杂数据，那这个可作为应用层的一个功能自己去实现。 0x01 WebSocket协议的控制帧上一篇的最后简单提到了心跳，下面是对websocket协议控制帧的描述： 5.5. Control Frames Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined. Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message. All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented. Ping的协议头是0x9，Pong的协议头是0xA 控制帧最大载荷为125bytes且不能拆分 0x02 WebSocket协议的心跳下面再来看看对心跳的规定： 5.5.2. Ping The Ping frame contains an opcode of 0x9. A Ping frame MAY include &quot;Application data&quot;. // 注：Ping帧中可能会携带数据 Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in Section 5.5.3. // 注：在收到Ping帧后，端点必须发送Pong帧响应，除非已经收到了Close帧。在实际中应尽可能快的响应。 An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed. NOTE: A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still responsive. 5.5.3. Pong The Pong frame contains an opcode of 0xA. Section 5.5.2 details requirements that apply to both Ping and Pong frames. A Pong frame sent in response to a Ping frame must have identical &quot;Application data&quot; as found in the message body of the Ping frame being replied to. // 注：在响应Ping帧的的Pong帧中，必须携和被响应的Ping帧中相同的数据。 If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame. 从上面的描述我们可以得到如下结论： 心跳包中可能会携带数据 当收到Ping帧的时候需要立即返回一个Pong帧 在连接建立之后，随时都可以发送Ping帧 心跳是用来测试链接是否存在和对方是否在线 在响应Ping帧的的Pong帧中，必须携和被响应的Ping帧中相同的数据 0x03 测试和之前一样，自己本地搭建的服务器，用的库是 org.java_websocket。在其源码中我们可以找到这样一段： 12345678910111213141516package org.java_websocket;public abstract class WebSocketAdapter implements WebSocketListener &#123; ... public void onWebsocketPing(WebSocket conn, Framedata f) &#123; FramedataImpl1 resp = new FramedataImpl1(f); resp.setOptcode(Opcode.PONG); conn.sendFrame(resp); &#125; public void onWebsocketPong(WebSocket conn, Framedata f) &#123; &#125; ...&#125; 客户端也可以使用这个库，相同的逻辑，代码也是这一份。 然后我们再换一个库，com.squareup.okhttp3:okhttp-ws:3.4.2，他的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package okhttp3.internal.ws;public abstract class RealWebSocket implements WebSocket &#123; ... public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random, final Executor replyExecutor, final WebSocketListener listener, final String url) &#123; this.listener = listener; writer = new WebSocketWriter(isClient, sink, random); reader = new WebSocketReader(isClient, source, new FrameCallback() &#123; @Override public void onMessage(ResponseBody message) throws IOException &#123; listener.onMessage(message); &#125; @Override public void onPing(final Buffer buffer) &#123; replyExecutor.execute(new NamedRunnable(\"OkHttp %s WebSocket Pong Reply\", url) &#123; @Override protected void execute() &#123; try &#123; writer.writePong(buffer); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125;); &#125; @Override public void onPong(Buffer buffer) &#123; listener.onPong(buffer); &#125; @Override public void onClose(final int code, final String reason) &#123; readerSentClose = true; replyExecutor.execute(new NamedRunnable(\"OkHttp %s WebSocket Close Reply\", url) &#123; @Override protected void execute() &#123; peerClose(code, reason); &#125; &#125;); &#125; &#125;); &#125;...&#125; 在处理Ping帧的时候，也是将协议字段改为Pong然后返回。 对心跳的测试代码已经上传到Github：ttdevsWebSocketActivity.javaWebSocketOKActivity.javaSocketServer.java 在实际的测试中，可能会遇到一些异常，比如在我们自己的生产环境：当客户端发送带了简单数据的Ping帧后，服务器立马返回Pong帧，但是它会将携带的数据丢弃。这个就是服务端的问题了。 0xFF 参考 RFC6455: https://datatracker.ietf.org/doc/rfc6455/","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://ttdevs.github.io/tags/WebSocket/"}]},{"title":"「Wechat」微信公众号开发流程","slug":"[Wechat]微信公众号开发流程","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[Wechat]微信公众号开发流程/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[Wechat]微信公众号开发流程/","excerpt":"","text":"0x01申请订阅号或者服务号微信有三种号：订阅号，公众号，服务号，所有人都可以注册订阅号，个人很难注册公众号和服务号；订阅号不能认证，开放的接口也是最少的。既然做开发，这种肯定不好使。因此我们需要选择订阅号或者服务号来做开发。自己没办法注册，可以考虑万能的淘宝。或者我们也可以使用测试账号 0x02 服务器功能开发配置自己的服务器在开发之前我们需要进行服务器的配置，这个不涉及具体的语言。登录微信后台，在 开发 &gt; 基本配置 &gt; 服务器配置 中进行配置。这里需要配置四个参数： URL 这个是我们服务器的地址，必须是80端口。微信会把所有的事件和消息等都推送到这个地址上。 Token 这个Token是我们分配给微信的 EncodingAESKey 微信消息的加密秘钥 消息加解密方式 没有特殊要求我们可以选择明文模式 更多信息可以参考这里。 微信服务器验证如果我们直接配置了上面的参数，是无法保存的，只有在我们配置的地址正确处理了微信的验证请求之后才可以保存成功。过程是这样的，微信会以get方式向我们配置的地址发一个请求，这个请求带了验证信息，和返回的字符串，他们分别是 signature、 timestamp、 nonce、 echostr，前三个参数用于验证，后一个用于返回微信。如果我们按照规则验证参数是正确的（这里会用到我们配置的Token），将echostr字段的信息返回，这样就可以保存了。当然，你也可以不做验证直接返回echostr参数内容也是可以，但是不推荐这样做。更多信息可以参考这里。 微信事件处理配置了上面的参数我们就可以处理微信发给我们的各种信息了。微信所有信息都是以POST的方式发送到我们之前配置的地址上。在URL参数中会携带四个参数signature、 timestamp、 nonce和openid，数据部分在body中。按照微信的接口协议，我们就可以开始微信功能开发了。 最后，无论是实用的是什么语言，都建议你去找一份封装的SDK来使用。这样可以大大的增加你的开发效率，当然，如果你是像我一样为了学习，可以自己去解析这些xml格式的消息～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"Wechat","slug":"Wechat","permalink":"https://ttdevs.github.io/tags/Wechat/"}]},{"title":"「macOS」Crontab定时任务","slug":"[macOS]Crontab定时任务","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[macOS]Crontab定时任务/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[macOS]Crontab定时任务/","excerpt":"","text":"我们可以使用crontab执行一些周期任务 0x01 crontab命令crontab [-u user] file crontab [-u user] { -e | -l | -r } crontab file_name 将file做为crontab的任务列表文件并载入crontab crontab -e 编辑crontab文件内容 crontab -l 显示crontab文件内容 crontab -r 删除载入后的crontab文件内容 0x02 crontab文件 分 时 日 月 星期 要运行的命令 第1列 分钟1～59 第2列 小时1～23（0表示子夜） 第3列 日1～31 第4列 月1～12 第5列 星期0～7（0,7表示星期天） 第6列 要运行的命令 几个特殊符号：/ - , / 每(per): */2 每两个单位 - 连续: 1-5 1,2,3,4,5 , 非连续: 1,2,5 1和2和5 0x03 Demo1234567891011121314151617181920# 每分钟向用户目录下的log.txt写入当时日期* * * * * /bin/date &gt;&gt; ~/log.txt # 每分钟* * * * * /bin/date &gt;&gt; ~/log.txt# 每5分钟*/5 * * * * /bin/date &gt;&gt; ~/log.txt# 每小时的第五分钟5 * * * * /bin/date &gt;&gt; ~/log.txt # 4月1日早上8点0 8 1 4 * /bin/date &gt;&gt; ~/log.txt # 4和5月 1日早上8点0 8 1 4,5 * /bin/date &gt;&gt; ~/log.txt # 1230623-7 * * * * /bin/date &gt;&gt; ~/log.txt 更新(2015-03-26)0x01 crontab辅助工具这个工具可以生成crontab文件。比如我们按照自己的想法选择了任务的时间，可以使用它帮助我们生成对应的crontab文件。 地址：http://www.crontab-generator.org/ 0x02 crontab的调试这个建议在命令的后面加上 ... &gt;&gt; ~/log.txt 2&gt;&amp;1，这样我们就可以在用户目录下看到crontab执行的日志了。如： 1* * * * * /bin/date &gt;&gt; ~/log.txt &gt;&gt; ~/log.txt 2&gt;&amp;1 0x03 环境变量虽然我们知道crontab执行时是没有环境变量的，但是这个确是个讨厌的东西。我们在本地调试好了相关的代码，用crontab却怎么执行也不正确，比如执行下面的shell： 1234#!/bin/bashpy3=$(which python3)echo py3... 默认情况什么也不会输出。下面的逻辑自然就是错的了。为了解决这个问题，我们可以在最开始加上这么一行 source /etc/profile ，然后在执行就可以顺利拿到我们的值了： 12345#!/bin/bashsource /etc/profilepy3=$(which python3)echo py3...","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://ttdevs.github.io/tags/macOS/"}]},{"title":"「macOS」Mac一句话分享","slug":"[macOS]Mac一句话分享","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[macOS]Mac一句话分享/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[macOS]Mac一句话分享/","excerpt":"","text":"window下直接输入msconfig打开系统配置即可，在这里可以配置是否允许开机自启动。MAC下最近装了几个软件，发现每次开机都会自动运行，比较烦躁，遂干掉之： 打开系统偏好设置&gt;选择用户与群组&gt;在当前用户的右侧选择登录项，在这里即可添加删除我们要的程序。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://ttdevs.github.io/tags/macOS/"}]},{"title":"「macOS」macOS安装","slug":"[macOS]macOS安装","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[macOS]macOS安装/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[macOS]macOS安装/","excerpt":"","text":"0x00 要不要重装？对于重装系统，我是拒绝的。 想起刚买Mac那会，总是用Window的思维来理解Mac，费了老大的劲来对磁盘进行分区，最后分了两个区：用户目录放在一个区，其他文件放在另一区。感觉自己好屌，但是没过多久发现下面两个问题： 重装系统，之前用户目录的文件读取权限可能会有问题 别问我为什么，知道重装可以解决大部分问题就好了 随着时间的流逝，开始预留给 系统文件和App所在分区 越来越不够用 最后总结：Mac 很少坏，所以，分区并没什么卵用，只会给您的使用带来麻烦。 好了，言归正传，自从升级了macOS 就出现各种小问题，python用不了了，adb经常断，系统变卡了，每个小问题都要去整一下。想想还是算了，花点时间，在另一台 Mac Mini 上重新安装，然后用 Time Machine 还原到 Mac Book上。 0x01 系统安装电脑上有一份最新的macOS安装文件，打算去做安装U盘。下班回去准备操作的时候，发现做U盘安装盘的速度好慢慢好慢啊。想，还是算了吧，睡觉之前使用网络安装，第二天醒来应该可以装好。 这里附一个 macOS 安装文件下载地址：Install macOS Sierra.app。 网络安装开机按住 Option(Alt) 键，进入启动引导，选择那个虚拟盘（可能需要输入WIFI密码，我用的网线），先将主硬盘格式化（这将丢失所有数据，请提前做好备份），然后选择第二项安装系统，按照提示点击各种 继续、同意 之类，就可以去睡觉了。 第二天起床，发现已经安装好了。按照提示，进行初始化操作，比如登录icloud账号，设置用户名等等。然后新的系统就可以用了。 日常使用工具安装这里只按照个人需要，流水账一样的记录下。 iTerm2 这个是用来替代Terminal，可以做很多个性化的设置，用起来更顺手。IT必备吧。 下载地址：http://www.iterm2.com/index.html oh-my-zsh 默认情况iTerm2和Terminal一样，界面都是比较丑的。这个可以更改iTerm2的主题。同时还集成了各种命令的简写。 下载地址：http://ohmyz.sh go2shell 有朋友推荐一些工具来替代Finder，装个这个小工具之后，基本上就懒得再去学一个 类Finder 了。它的功能超级简单，点击一个按钮，在当前位置打开一个Terminal窗口。 下载地址：http://zipzapmac.com/Go2Shell （不建议从App Store下载） homebrew 这个用来管理软件的，类似wget等。之前安装软件，都是到各家官网去找安装包，自从有了这个，很多软件再也不用到处去找了。 下载地址：http://brew.sh alfred 如果你使用 Spotlight ，alfred可能是一个更好的选择。 下载地址：可以直接在App Store下载。 Firefox（这里仅仅记录几个常用的插件） Adblock Plus 广告已成往事 BingDcit 没找到更好的翻译替代工具 JSONView 网页查看json数据更友好 Octotree 访问Github时，会在左侧列出文件列表，下载浏览更方便 User-Agent Switcher 访问一下手机网页会更方便 TabTrekker 一个酷炫的桌面插件，每天给你不同的壁纸 Chrome（这里仅仅记录几个常用的插件） Adblock Plus JSONView 网页查看json数据更友好 Octotree 访问Github时，会在左侧列出文件列表，下载浏览更方便 OneTab Pocket Translt 一个翻译插件，双击即可翻译，体验很棒 Unsplash Instant 和TabTrekker很像 PS：Chrome插件虽好，但请按需选择，除非你的内存大大的。 python 和 python3 mac系统自带了python2.7，这里我还是选择了使用brew安装了python和python3。 IntelliJ IDEA (Plugins) GsonFormat Android ButterKnife Zelezny CodeGlance 其他开发工具 这个就看各位需要了，我装了一堆。 收费App mweb Inboard Day One 1Password Affinity Designer macOS Server Apple Remote Desktop Polarr PCalc 小历 Inbox for Gmail Paste 可意视频 TODO 还有很多没列出来 别问我是不是装了这里所有软件，告诉你我装了，但不要崇拜哥，万能的淘宝可以实现你的梦想🙈 环境配置 环境变量 安装好oh-my-sh之后，就可以添加自己的环境变量配置了，这里简单说些我的配置。首先我选择在一个单独的文件中~/.bash_profile 写自己的配置，然后将此文件添加到 ~/.zshrc 的最后 source ~/.bash_profile。.bash_profile的内容如下： 123456789101112131415export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Homeexport GRADLE_HOME=$HOME/android/gradle/gradle-2.14.1export ANDROID_HOME=$HOME/android/android-sdk-macosxexport NDK_HOME=$ANDROID_HOME/ndk-bundleexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools:$&#123;ANDROID_HOME&#125;/tools:$&#123;NDK_HOME&#125;/:$&#123;GRADLE_HOME&#125;/bin:$&#123;JAVA_HOME&#125;/bin:$&#123;JAVA_HOME&#125;/lib:## Aliases# Create by ttdevs 2016-03-31#alias oi=&apos;open -a iterm .&apos;alias of=&apos;open -a Finder .&apos;alias vv=&apos;virtualenv&apos;alias weather=&apos;curl http://wttr.in/shanghai&apos; 0x02 继续装逼重装系统，我仍是拒绝的。 此文不定期更新。 最后，App Store的软件还是比较贵的，入坑需谨慎 啊 啊 啊","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://ttdevs.github.io/tags/macOS/"}]},{"title":"「macOS」macOS安装Python","slug":"[macOS]macOS安装Python","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[macOS]macOS安装Python/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[macOS]macOS安装Python/","excerpt":"","text":"0x00 为什么要装(Bi)装逼遭雷劈。 上一篇介绍了重装macOS的方法。为什么会有上一篇？说到底就一个字：跑 python web 应用出问题了。把macOS从旧版本升级到新版本 10.12，之前跑的好好的web应用现在各种问题，所以，重装吧。然并卵，重装后问题依旧 😢，比如： ImportError: No module named &#39;_sqlite3&#39;ImportError: No module named &#39;pysqlite2&#39; 等等一堆问题。好吧，废话说多了，这里介绍下该怎么办。 0x01 安装情况是这样的，全新安装macOS，同时升级 xcode 到最新版8 (8A218a)，使用 homebrew 安装 python3 ： brew install python3 装好之后还是各种model找不到，缺少很多东西，尝试了各种方法，依然无法解决。 在反复重装 python3 的时候，看到这样一个提示：xcode-select --install。虽然不知道这个鬼东西是干嘛，但是确定一点，之前我有安装过。所以，就在命令行执行了一下，然后再重新安装 python3，他 就，就，就 可以了…… 0x02 Command Line Toolsxcode-select --install 这条命令是的作用是安装 Command Line Tools。找了半天，没看到哪有详细的介绍，在这里看到一个简短的介绍： The Command Line Tools Package is a small self-contained package available for download separately from Xcode and that allows you to do command line development in OS X. It consists of two components: OS X SDK and command-line tools such as Clang, which are installed in /usr/bin. 简单来说，应该就是一套工具集合。他会被安装在下面两个位置： /Library/Developer/CommandLineTools/usr/bin/usr/bin 在这里你会看到一堆常见的命令。看到这些之后，恍然大悟，homebrew好像是下的python3的源码，然后本地编译安装的。如果缺少了这些命令，可能就会出错。 好了，终于可以愉快的使用 python 了。","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://ttdevs.github.io/tags/macOS/"}]},{"title":"「macOS」用Homebrew安装Mysql","slug":"[macOS]用Homebrew安装Mysql","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[macOS]用Homebrew安装Mysql/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[macOS]用Homebrew安装Mysql/","excerpt":"","text":"0x00 需求简单记录mac下mysql安装。这里需要一个前提——先安装 homebrew，具体可以参考这里。 0x01 安装123456789101112➜ ~ brew install mysql＃ 以下为删除上个版本的遗留➜ ~ cd /usr/local/var/mysql➜ mysql git:(master) lsauto.cnf ib_buffer_pool mysql server-cert.pemca-key.pem ib_logfile0 mysqld_safe.pid server-key.pemca.pem ib_logfile1 performance_schema sysclient-cert.pem ibdata1 private_key.pem ttdevs.local.errclient-key.pem ibtmp1 public_key.pem ttdevs.local.pid➜ mysql git:(master) rm -rf ttdevs.local.err➜ mysql git:(master) cd ~＃ 以上为删除上个版本的遗留 卸载： brew uninstall mysql 0x02 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758➜ ~ /usr/local/opt/mysql/bin/mysql_secure_installationSecuring the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No:Please set the password for root here.New password:Re-enter new password:By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from&apos;localhost&apos;. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.By default, MySQL comes with a database named &apos;test&apos; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done!➜ ~ mysql.server startStarting MySQL SUCCESS! 0x03 启动停止 brew services start/stop mysql mysql.server start/stop 两种方式都可以，但是不可以交叉使用，比如用 brew services start mysql 启动 却不能用 mysql.server stop 停止。 0x04 GUI客户端 Sequel Pro 免费 Navicat For Mysql 收费 0x05 简单命令纪录 登录：mysql -u username -p 推出：exit; 默认 data 目录：/usr/local/var/mysql Emoji表情的支持请使用编码：utf8mb4 TODO 2016-09-07 0xFF 参考 https://segmentfault.com/q/1010000000475470 http://pein0119.github.io/2015/03/25/MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF-The-server-quit-without-updating-PID-file/","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://ttdevs.github.io/tags/macOS/"}]},{"title":"「玩转树莓派」0x00欢迎来到树莓派的世界","slug":"[玩转树莓派]0x00欢迎来到树莓派的世界","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x00欢迎来到树莓派的世界/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x00欢迎来到树莓派的世界/","excerpt":"","text":"0x00 初衷Welcome to Raspberry Pi world 之前加入的一个树莓派群最近突然活跃起来，经过观察发现是新版的树莓派发布了 —— Raspberry Pi 3。很高兴的是，各位小伙伴的活跃有些超出我的意料。 观察一段时间之后发现，很多小伙伴在问一些很基础的问题，开始尝试去帮他们解答，后来发现根本回答不过来，刚回答完又有小伙伴来问，因此决定尝试着做一些基础总结，给各位刚入门的小伙伴提供一些参考。 为什么买树莓派呢？很早就听说过树莓派，Arduino这些小板子，但是决定入手树莓派还是因为知乎的一个回答：树莓派 (Raspberry Pi) 是什么？普通人怎么玩？ 看完后很兴奋，这个小板还可以这样玩，遂入手。算起来从入手到现在已经半年左右。简单的入门操作都折腾了一遍，还买了一大堆硬件，但是很遗憾，不少硬件没有折腾成功。期间学了一些python基础知识，做了一些简单的服务在上面跑，然后就让他静静的躺在了角落里，没有再折腾。但有一件事让我非常的兴奋，这个小板子最长一次50多天没关机！！！这大大的出乎我的意料 为什么会说非常兴奋呢？跑了50多天后是我主动关机的。一个普通的用户，无论你是Windows，Linux还是Mac，作为日常使用的设备，还是会经常重启的，特别是Windows系统。一块放在床头的小板子，可以稳定的跑上几天，几周，几个月，有这么稳定的一个系统，还有那些GPIO，是不是给我们更多的折腾提供了非常好的基础! 决定写这些入门文章，我会本着直接告诉你一个结果的原则，循序渐进的把你正面对或者将会遇到的问题展现出来。如果讲的太粗，各位可以直接提问，我再补充。最后希望我会坚持把这些东西写下去。 0x01 什么是树莓派树莓派(Raspberry Pi) 是什么，来看看维基百科的介绍： 树莓派（英语：Raspberry Pi），是一款基于Linux的单板机电脑。它由英国的树莓派基金会所开发，目的是以低价硬件及自由软件刺激在学校的基本计算机科学教育。树莓派的生产是通过有生产许可的两家公司：Element 14/Premier Farnell和RS Components。这两家公司都在网上出售树莓派。树莓派配备一枚博通（Broadcom）出产的ARM架构700MHz BCM2835处理器，256MB內存（B型已升级到512MB内存），使用SD卡当作存储媒体，且拥有一个Ethernet、两个USB接口、以及HDMI（支持声音输出）和RCA端子输出支持。树莓派只有一张信用卡大小，体积大概是一个火柴盒大小，可以运行像《雷神之锤III竞技场》的游戏和进行1080p视频的播放。操作系统采用开源的Linux系统如Debian、ArchLinux，自带的Iceweasel、KOffice等软件，能够满足基本的网络浏览、文字处理以及电脑学习的需要。分A、B两种型号，售价分别是A型25美元、B型35美元。树莓派基金会从2012年2月29日开始接受B型的订货。树莓派基金会提供了基于ARM架构的Debian、Arch Linux和Fedora等的发行版供大众下载，还计划提供支持Python作为主要编程语言，支持BBC BASIC(通过RISC OS映像或者Linux的”Brandy Basic”克隆)、C语言和Perl等编程语言。树莓派基金会于2016年2月发布了树莓派3,较前一代树莓派2，树莓派3的处理器升级为了64位的博通BCM2837，并首次加入了Wi-Fi无线网络及蓝牙功能，而售价仍然是35美元。 简单来说，他就是一台ARM架构的电脑，信用卡大小，他有usb接口，有hdmi接口，有音频接口，有以太网接口等等。我们再来看看他的配置（From:维基百科）： 最新的Raspberry Pi 3 B型CPU有提升，增加了板载WIFI和蓝牙。但是，这样的配置，和我们普通的PC机比的话还是差的很远。那么，我们为什么还要使用树莓派呢？这里简单说说我的看法： 体积小：小到完全可以随身携带 省电：我的是2代B型，配置的电源5V 2A，最大功率也才10W GPIO：这个是最吸引我的，通过它可以控制一些开关等 便宜：200多块钱的价格，少吃一顿饭少看两场电影就剩下来了 … 其实既然你已经决定或者已经入手树莓派，我们就不过多的介绍他的优缺点了。反正就是你买了用起来，不会后悔的。接下来我会把更多的精力放在我们要做的事情上，而不是纠结具体在某个版本上，因为相同的OS他们差别不是很大。我用的是树莓派2代B型，和最新的3代比少了WIFI和Bluetooth，不过我自己准备了一个usb接口的WIFI和Bluetooth，最后我的基本配置如下： 树莓派主机：2代B型 电源适配器：2A，看挂的负载选择 存储卡：32G Sandisk，推荐这个牌子 无线网卡：RTL8192CU，可选 USB蓝牙：可选 摄像头：网上50快钱买的，可选 其他一堆硬件，如HC-SR501、LCD12864、LCD1602、MQ-135、MQ-2、DHT11等等，目前已知在用的是DHT11，检查房间温湿度。 123456~ $ lsusbBus 001 Device 005: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)Bus 001 Device 004: ID 0bda:8178 Realtek Semiconductor Corp. RTL8192CU 802.11n WLAN AdapterBus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet AdapterBus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 0x02 网络环境我用的是上海电信的30MB宽带，电信光猫下面接一个TP-Link路由器，路由器下面接上网设备。如下图： 起初，很多人会遇到和我一样的问题：光猫加电后就可以上网了，但是我们没办法通过公网访问我路由器下的设备。解决这个问题，我们会很自然的想到对光猫进行设置。经过各种google之后，确定了一个最简单的思路：破解光猫，从中获取我们拨号用的用户名和密码，然后把光猫设置成仅仅作为猫使用，用拿到的用户名密码到我们的路由器中进行拨号。听起来是不是还挺复杂的，那这里告诉你一个简单办法：随便找一个理由报修宽带，比如网速比较慢，等维修的师傅上门后告诉他你想用自己的路由器拨号上网，他就会帮你设置的。设置好这些之后我们就有了一个有公网IP的路由器。 0x03 花生壳虽然完美有了公网的IP，但是遗憾的是，这个公网IP在每次拨号时都会变。这个问题我们可以用花生壳来解决。花生壳可以免费给我们提供DDNS服务，将我们动态的IP映射到一个域名上。这样我们就可以在公网通过这个域名来访问家里的树莓派，而不用担心自己的公网IP变来变去找不到了。所以，我们需要先注册一个花生壳的账号，再花5块钱注册一个花生壳域名，拿着这个账号到我们的宽带路由器上登录即可: 很多时候事情并没有那么完美，比如某天你会发现我们宽带的某些端口（比如80端口）无法使用（被电信运营商封掉），这时候我们就需要使用花生壳的另一个服务：花生壳内网版 来解决。这个我会在接下来的文章中讲到。 0x04 工具俗话说工欲善其事必先利其器，在正式开始之前，给大家推荐几个工具： JuiceSSH 一个android系统的SSH客户端工具，可以通过它直接与树莓派相连。 GPIO tool for Raspberry Pi 一个客户端工具，支持android系统，连接树莓派后直接可以对树莓派的GPIO进行操作。 Fritizing 这个是用来画电路原理图的，很Cool，非常好用。 Serverauditor iOS系统的SSH客户端工具。 如果你有更好的工具，欢迎分享。 说了这么多，接下来正式进入树莓派的世界，提前祝大家玩的开心~~","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"「玩转树莓派」0x01选个系统先","slug":"[玩转树莓派]0x01选个系统先","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x01选个系统先/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x01选个系统先/","excerpt":"","text":"0x00 树莓派的安装配置（无显示器）树莓派没有硬盘，我们拿到设备之后是不能直接用的，因此需要先给它配置一个装好系统的存储卡。这篇文字，给大家介绍如何安装并初始化树莓派系统。 Raspbian 是树莓派基金会官方支持的系统，我们可以直接下载他的安装文件或者使用官网推荐的 NOOBS 来完成安装操作。除了官方支持的系统，树莓派还有很多第三方支持的系统，如：UBUNTU MATE、SN ![Uploading win32diskimager_914364.png . . .]APPY UBUNTU CORE、WINDOWS 10 IOT CORE、OSMC、OPENELEC、PINET、RISC OS、WEATHER STATION等，这里有我们比较熟悉的WINDOWS 10 IOT、UBUNTU、OSMC等。UBUNTU系统是非常火的一个Linux发行版本，WINDOWS 10 IOT是微软开发的物联网系统，OSMC可以作为家庭媒体中心使用，其他系统大家可以自行了解。 前一篇文章简单介绍了我的硬件环境，是没有显示器和外接键盘鼠标的，因此我会基于这个前提给大家介绍如何玩转树莓派。 这么多系统，初学者可能会很纠结如何选择。这里给大家推荐官方支持的Raspbian（基于Debian Jessie）系统，他预装了很多常用、编程、教育软件，如Python(python3)、Scratch、Sonic Pi、Java、Mathematica等等。Raspbian包含RASPBIAN JESSIE(Full desktop image based on Debian Jessie)和RASPBIAN JESSIE LITE(Minimal image based on Debian Jessie)两个版本，由于之后我们会用到桌面环境，因此我们最终选择RASPBIAN JESSIE，带桌面环境的版本。 0x01 下载决定了使用RASPBIAN JESSIE（非RASPBIAN JESSIE LITE），我们只需要到树莓派的官网下载系统文件即可。他的最新版本是 March 2016： 发布：2016-3-18 Linux内核：4.1 文件名：2016-02-26-raspbian-jessie.zip MD5: db41f2a8c6236c0ca9150fe4db2017c09e7871fb 大小：1.3G 对下载的文件进行加压，得到2016-02-26-raspbian-jessie.img，大小4.03G，这个就是我们安装要用到的系统镜像文件。 0x02 安装系统的安装比较简单，就是将我们刚下载的安装镜像文件写入到TF卡中。官方的 安装帮助文档 对系统的安装进行了详细的介绍。本着简化操作的原则，这里再做简单概述。 Windows系统 Windows系统安装推荐使用win32diskimager，这是一个图形化工具，操作非常简单：以管理员方式打开，ImageFile选择刚下载的img镜像，Device选择我们的TF卡所在驱动器，点击Write即可。 Mac系统 跟Windows系统一样，我们推荐图形界面的ApplePi-Baker，操作界面如下： 左侧选择SDCard，右侧选择我们的镜像文件，点击Restore Backup按钮即可。 Mac系统命令行方式 由于我用的Mac系统，所以简单介绍下这种稍微复杂点的方式但也就是简单几步操作： 插入SDCard卡，使用磁盘管理工具对其进行擦除，格式选择MS-DOS(FAT)，完成后推出SDCard（推出并不是拔出） 使用df -h查看SDCard的路径，如下的 /dev/disk2s1，我们记下 disk2： 1234567➜ ~ df -hFilesystem Size Used Avail Capacity iused ifree %iused Mounted ondevfs 185Ki 185Ki 0Bi 100% 640 0 100% /devmap -hosts 0Bi 0Bi 0Bi 100% 0 0 100% /netmap auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /home/dev/disk2s1 60Mi 20Mi 40Mi 34% 512 0 100% /Volumes/raspi➜ ~ 执行如下命令，将镜像文件烧录进SDCard，这个过程会因为你的SDCard卡的速度的不同而不同，期间你可以通过Ctrl+T来查看进度： sudo dd bs=1m if=2016-02-26-raspbian-jessie.img of=/dev/rdisk2 如果命令行方式有问题，请参考官方说明解决。 烧录完成之后SDCard内容如下： 0x03 登录树莓派完成以上操作，将SDCard插入树莓派加电就可以顺利跑起来了。我们再强调一遍，即使没有键盘鼠标显示器，也是可以操作树莓派的，包括安装时。简单的拓扑如下图： 启动树莓派可以有两种方式：无外接键盘鼠标显示器和有外接键盘鼠标显示器（虽然我假设自己没有多余的键盘显示器，但是我还是会在此介绍这种方式~~）。 这两种方式无论选择哪种，我们都需要先将树莓派通过RJ45接口与我们的路由器相连（说人话就是拿网线连接树莓派和路由器）。别问我为什么这么做，因为这样最简单，跟着做就好（当然，我知道你也可以直接拿根网线直接连接电脑和树莓派，但是非常不建议这么做，因为这么屌的你已经可以不用来看这篇文章了），或者你会说没有路由器，你真的没路由器？那赶紧买一个吧。 这里强烈建议通过路由器的设置给树莓派分配静态IP，否则会非常麻烦。更多获取树莓派的IP的方法可参考这里。 无外接键盘鼠标显示器 这种方式最简单。树莓派接入网络，我们只需要登录路由器，到DHCP服务器中的客户端列表中查看我们的树莓派的IP，然后通过ssh命令登录树莓派就可以操作了。[默认的用户名密码][c2]：pi：raspberry，ssh 命令如下： 1ssh pi@&lt;you ip address&gt; 密码输入无回显 外接键盘鼠标显示器 如果你有多余的键盘鼠标显示器供给树莓派使用，那么第一次启动的时候，我们需要简单配置下树莓派使其支持HDMI输出。打开我们的SDCard，在根目录下，看到有这么一个文件：config.txt。我们需要修改他支持HDMI的显示（1080P的输出），下面是我配置的Demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pi@raspi:/boot $ cat config.txt# For more options and information see# http://www.raspberrypi.org/documentation/configuration/config-txt.md# Some settings may impact device functionality. See link above for details# uncomment if you get no picture on HDMI for a default &quot;safe&quot; mode#hdmi_safe=1# uncomment this if your display has a black border of unused pixels visible# and your display can output without overscandisable_overscan=1# uncomment the following to adjust overscan. Use positive numbers if console# goes off screen, and negative if there is too much border#overscan_left=16#overscan_right=16#overscan_top=16#overscan_bottom=16# uncomment to force a console size. By default it will be display&apos;s size minus# overscan.#framebuffer_width=1280#framebuffer_height=720# uncomment if hdmi display is not detected and composite is being outputhdmi_force_hotplug=1# uncomment to force a specific HDMI mode (this will force VGA)hdmi_group=2hdmi_mode=82# uncomment to force a HDMI mode rather than DVI. This can make audio work in# DMT (computer monitor) modes#hdmi_drive=2# uncomment to increase signal to HDMI, if you have interference, blanking, or# no displayconfig_hdmi_boost=4# uncomment for composite PAL#sdtv_mode=2#uncomment to overclock the arm. 700 MHz is the default.#arm_freq=800# Uncomment some or all of these to enable the optional hardware interfaces#dtparam=i2c_arm=on#dtparam=i2s=on#dtparam=spi=on# Uncomment this to enable the lirc-rpi module#dtoverlay=lirc-rpi# Additional overlays and parameters are documented /boot/overlays/README# Enable audio (loads snd_bcm2835)dtparam=audio=ondevice_tree= 参考： 解决Raspberry Pi只能在默认640×480模式下显示的问题 http://elinux.org/RPiconfig 0x04 配置WIFI如果你想摆脱网线的束缚，我们可以使用WIFI来接入网络。最新的树莓派3板载了WIFI，树莓派2代需要我们自己配置无线网卡。官方的配置参考这里。如何查看我们的无线网卡是否正确识别，可以使用lsusb命令，如： 123456pi@raspi:~ $ lsusbBus 001 Device 005: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)Bus 001 Device 004: ID 0bda:8178 Realtek Semiconductor Corp. RTL8192CU 802.11n WLAN AdapterBus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet AdapterBus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 第二行的Devices 004 RTL8192CU就是我的无线网卡。RASPBIAN JESSIE系统默认集成了RTL8192CU的驱动，所以我插上去之后就能用了。如果你的无线网卡无法检测到，请检查驱动配置，由于无线网卡型号太多，驱动安装就不展开讲了，可以参考这里。 直接修改配置文件 树莓派的网络配置文件位于 /etc/network/interfaces 和 /etc/wpa_supplicant/wpa_supplicant.conf文件中，我们将通过对其修改来使用我们的WIFI。修改之前建议先做备份： 12sudo cp /etc/network/interfaces /etc/network/interfaces.baksudo cp /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf.bak 下面是默认的 `interfaces` 配置文件： 123456789101112131415161718192021$ cat interfaces# interfaces(5) file used by ifup(8) and ifdown(8)# Please note that this file is written to be used with dhcpcd# For static IP, consult /etc/dhcpcd.conf and &apos;man dhcpcd.conf&apos;# Include files from /etc/network/interfaces.d:source-directory /etc/network/interfaces.dauto loiface lo inet loopbackiface eth0 inet manualallow-hotplug wlan0iface wlan0 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.confallow-hotplug wlan1iface wlan1 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf 在默认的 interfaces 配置下，我们可以仅仅修改 /etc/wpa_supplicant/wpa_supplicant.conf来完成WIFI配置，比如我的 wpa_supplicant.conf文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243$ sudo cat /etc/wpa_supplicant/wpa_supplicant.confcountry=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;my wifi ssid&quot; psk=&quot;my password&quot; key_mgmt=WPA-PSK&#125;``` 我的WIFI加密方式是 `WPA-PSK/WPA2-PSK` 因此配置 `key_mgmt=WPA-PSK` 加密方式可以在路由器的无线安全设置中查看。接下来我们还需要重启我们的WIFI： ``` shellsudo ifdown wlan0sudo ifup wlan0 ``` 或者直接重启系统 `sudo reboot` 。通过上面的设置，就可以连接我们的WIFI了。当然，我们也可以不使用 `/etc/wpa_supplicant/wpa_supplicant.conf` 文件，仅仅修改 `interfaces` 来完成配置，如我的另一个配置：``` shell# interfaces(5) file used by ifup(8) and ifdown(8)# Please note that this file is written to be used with dhcpcd# For static IP, consult /etc/dhcpcd.conf and &apos;man dhcpcd.conf&apos;# Include files from /etc/network/interfaces.d:source-directory /etc/network/interfaces.dauto loiface lo inet loopbackiface eth0 inet dhcp# auto wlan0allow-hotplug wlan0iface wlan0 inet staticaddress 192.168.1.56netmask 255.255.255.0gateway 192.168.1.1wpa-ssid &lt;my ssid&gt;wpa-psk &lt;my password&gt; 更多的配置参数，可以参考[这里](TODO)。 &gt;这里配置使用了静态IP 通过GUI桌面环境进行配置 这个就非常简单了，连接显示器键盘鼠标，登录桌面环境，点击右上角的WIFI图标，选择自己的WIFI，然后输入密码即可，如下图： 获取到IP并接入到网络，接下来，我们就可以开启我们的树莓派之旅。各位玩的开心~~","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"「玩转树莓派」0x02吊炸天的远程控制","slug":"[玩转树莓派]0x02吊炸天的远程控制","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x02吊炸天的远程控制/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x02吊炸天的远程控制/","excerpt":"","text":"0x00 吊炸天的远程控制Connect to Raspberry Pi 安装好了系统，接下来我们就可以开始操作 Raspberry Pi 了。如果你不是拿来做家庭媒体中心，看视频之类，我们完全不需要给 Raspberry Pi 配置显示器，通过远程连接工具就可以完成我们所有的日常操作。由于连接显示器操作比较直观，这里仅给大家介绍无显示器的远程操作方法。 0x01 SSH先看一段介绍，来自维基百科： Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。 上面的介绍是不是太抽象～～还是我来说吧。折腾 Raspberry Pi ，ssh作为一个重要的远程连接工具（或者理解为把 Raspberry Pi 的终端拿到本地来），日常操作中是必不可少的！在没有显示器的情况下，我们可以使用ssh完成绝大多数（甚至所有的）操作。因此，这里我必须着重介绍。我们装的 Raspbian 系统默认是打开ssh的（否则在没有显示器的情况下我们是无法操作的，当然你非得说用USB转TTL也行），因此，我们不需要做任何配置就可以直接使用ssh。 安装SSHWindows系统推荐使用免费、小巧、无需安装、并且功能强大的ssh工具。 PuTTY 是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。 大家可以到他的官网下载，或者到这里下载，非常小，519KB。打开是界面如下： 使用也是非常的简单，在 Host Name(or IP address) 中填入你的域名或者IP，在 Port 中填入你的端口，默认是 22 （如果你修改了默认端口，在此改成新的端口即可），然后点击 Open 就开始连接，打开一个 terminal ，按照提示操作即可： Mac和Linux系统中默认已经安装了 ssh 工具，我们可以直接在命令行中操作即可： 123456789101112➜ ~ ssh -VOpenSSH_6.9p1, LibreSSL 2.1.8➜ ~ sshusage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q cipher | cipher-auth | mac | kex | key] [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command]➜ ~ 使用SSHssh的使用比较简单，直接在我们本地的终端中输入 ssh pi@&lt;your domain or ip&gt; 命令，按照提示输入密码即可： 1234567891011➜ ~ ssh pi@ttdevs.compi@ttdevs.com&apos;s password:The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Thu Mar 31 17:38:44 2016 from 58.11.22.33pi@raspberry:~ $ 完成ssh的登录，你就可以在本地直接操作 Raspberry Pi 了，而且体验和直接登录 Raspberry Pi 操作一样。 修改端口号如果你跟我一样比较悲催——22端口 也 被电信封了（或者很不稳定），那你就需要给ssh换（或者增加）一个端口。如何判断22端口是否被封了？最简单就是如果你在内网通过ssh可以访问Raspberry Pi，外网却访问不了，那么22端口就有可能被运营商或者你的防火墙给封了。既然端口有问题，那最简单的办法换个端口，就可以规避这个问题，下面介绍如何操作： 编辑ssh配置文件 /etc/ssh/sshd_config 修改端口 123456789sudo nano /etc/ssh/sshd_config# Package generated configuration file# See the sshd_config(5) manpage for details# What ports, IPs and protocols we listen forPort 22Port 2333... 找到Port 22，在这行下面增加一行 Port 2333。当然你也可以直接把22改成你要设置的端口号。他们的区别是：增加一行可以增加一个ssh端口号。如上面的写法，我可以使用ssh通过 22 或 2333 端口来访问Raspberry Pi。 使配置生效 重启ssh：sudo service ssh restart 最简单你也可以直接重启设备：sudo reboot or sudo init 6 使用新端口登录 使用新端口的登录方式如下： ssh -p &lt;your new port&gt; &lt;username&gt;@&lt;ip-address or domain&gt; 如： ssh -p 2333 pi@ttdevs.com 无密码登录无密码登录就是把我们从每次登录 Raspberry Pi 都需要输入密码的繁琐中解脱出来。配置完成后，我们只需要 ssh &lt;your domain or ip&gt; 即可登录我们的设备而不需要输入密码。 这个配置很简单，只需要将我们的public秘钥传到Raspberry Pi的 ~/.ssh/authorized_keys 文件中即可。执行下面的命令（假设你的本地已经生成了相关的key）： 1cat ~/.ssh/id_rsa.pub | ssh &lt;username&gt;@&lt;ip-address or domain&gt; &apos;cat &gt;&gt; .ssh/authorized_keys&apos; 其中id_rsa.pub为你的公钥。如果没有问题，当你再次尝试使用ssh登录的话就不需要密码了。如果有问题，请参考这里。 0x02 VNC虽然ssh可以完成我们的绝大多说操作。但是如果习惯了图形界面的你，一时半会很难上手这种命令行方式，会想有个桌面操作环境，那接下来我们介绍下VNC，因为他可以满足你对GUI的要求。VNC的配置，我们可以在如下 Raspberry Pi 官方文档中找到。当然，你也可以到VNC的官方网站查看。 安装VNC 安装VNC 我们可以使用这个命令来安装VNC服务： sudo apt-get install tightvncserver 设置密码 在启动服务之前，我们需要设置一个访问密码，命令为tightvncserver，操作如下： 12345678910111213141516171819202122232425pi@raspberrypi:~/.vnc $ tightvncserverperl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LC_CTYPE = &quot;zh_CN.UTF-8&quot;, LANG = &quot;en_GB.UTF-8&quot; are supported and installed on your system.perl: warning: Falling back to a fallback locale (&quot;en_GB.UTF-8&quot;).You will require a password to access your desktops.Password:Verify:Would you like to enter a view-only password (y/n)? yPassword:Warning: password truncated to the length of 8.Verify:New &apos;X&apos; desktop is raspberrypi:5Starting applications specified in /home/pi/.vnc/xstartupLog file is /home/pi/.vnc/raspberrypi:5.logpi@raspberrypi:~/.vnc $ PS：密码无回显 运行一个vnc display vncserver :1 -geometry 1920x1080 -depth 24 这样你就可以通过VNC客户端（如：VNC Viewer）连接到我们的树莓派了，客户端的配置，你可以参考这里。下面是我的效果图： VNC Viewer中我们需要指定连接哪个display，由于我们上面用的是 display 1，因此地址写：ttdevs.com:1 另外，上面的命令是在display 1位置启动，如果你考虑节省资源可以关闭display 0，执行命令：service lightdm stop 配置VNC自启动通过上面的配置我们就可以使用VNC了，但是如果我们重新启动设备，之前的配置失效，VNC就连不上了。因此最好能把启动VNC的操作添加到系统的自启动项中。具体操作如下： 切换到root账户：sudo su 进到/etc/init.d/目录：cd /etc/init.d/ 创建vncboot文件：touch vncboot 编辑vncboot文件，输入下面内容：sudo nano vncboot 12345678910111213141516171819202122232425262728293031323334353637#! /bin/sh# /etc/init.d/vncboot### BEGIN INIT INFO# Provides: vncboot# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start VNC Server at boot time# Description: Start VNC Server at boot time.### END INIT INFOUSER=piHOME=/home/piexport USER HOMEcase &quot;$1&quot; in start) echo &quot;Starting VNC Server&quot; #Insert your favoured settings for a VNC session su - $USER -c &quot;/usr/bin/vncserver :1 -geometry 1280x800 -depth 16 -pixelformat rgb565&quot; ;; stop) echo &quot;Stopping VNC Server&quot; /usr/bin/vncserver -kill :1 ;; *) echo &quot;Usage: /etc/init.d/vncboot &#123;start|stop&#125;&quot; exit 1 ;;esacexit 0 修改vncboot的权限：chmod 755 vncboot 设置VNC为默认启动：update-rc.d vncboot defaults 最后，完整脚本如下 123456789101112131415161718192021222324252627pi@raspberrypi:~ $ sudo suroot@raspberrypi:/home/pi# cd /etc/init.d/root@raspberrypi:/etc/init.d# touch vncbootroot@raspberrypi:/etc/init.d# sudo nano vncbootroot@raspberrypi:/etc/init.d# chmod 755 vncbootroot@raspberrypi:/etc/init.d# update-rc.d vncboot defaultsperl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LC_CTYPE = &quot;zh_CN.UTF-8&quot;, LANG = &quot;en_GB.UTF-8&quot; are supported and installed on your system.perl: warning: Falling back to a fallback locale (&quot;en_GB.UTF-8&quot;).root@raspberrypi:/etc/init.d# ls -altotal 308drwxr-xr-x 2 root root 4096 Mar 22 05:41 .drwxr-xr-x 109 root root 4096 Mar 21 15:01 ..-rw-r--r-- 1 root root 1745 Mar 22 05:43 .depend.boot-rw-r--r-- 1 root root 930 Mar 22 05:43 .depend.start-rw-r--r-- 1 root root 1009 Mar 22 05:43 .depend.stop-rw-r--r-- 1 root root 2427 Apr 6 2015 README...-rwxr-xr-x 1 root root 699 Mar 22 05:42 vncboot-rwxr-xr-x 1 root root 2666 Sep 25 2013 x11-commonroot@raspberrypi:/etc/init.d# reboot 密码管理VNC的密码管理比较简单，详细描述可以参考这里，下面做简单描述： 修改密码 vncpasswd 123456789pi@raspberrypi:~ $ vncpasswdUsing password file /home/pi/.vnc/passwdPassword:Verify:Would you like to enter a view-only password (y/n)? yPassword:Warning: password truncated to the length of 8.Verify:pi@raspberrypi:~ $ PS：设置新的密码，好像并不会验证你的旧密码 忘记密码 VNC的密码文件存储在：$HOME/.vnc/passwd中，如果你忘记了VNC的密码，可以直接删除这个文件，运行 tightvncserver 即可使用新的密码。 其他说明 VNC默认端口号：5901 VNC配置文件：~/.vnc VNC密码文件：/.vnc/passwd 0x03 SCP讲过上面的配置之后我们就可以通过这两种方式来远程操作我们的树莓派了。但是，有时候我们需要在本地和 Raspberry Pi 之间进行文件拷贝，这里我们可以有很多种选择，比如常见的FTP，SFTP等。但是由于FTP的配置比较麻烦，而且必须以服务的方式在系统常驻，因此给大家推荐 SCP。SCP 是secure copy的简写，用于在Linux下进行远程拷贝文件。我们比较常见的 cp 命令和 scp 类似，不过cp 只是在本机进行拷贝，不能跨服务器。考虑网络传输的安全性， scp 传输是加密的。默认情况，我们的Raspberry Pi 已经安装了SCP， 可以通过直接在终端输入 scp 来查看，如： 1234$ scpusage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 ... [[user@]host2:]file2 由于我用的是Mac系统，默认情况也已经安装了SCP命令。如果你使用的是Windows系统，我们可以到这里下载WinSCP。 本地文件拷贝到 Raspberry Pi 拷贝本地文件file.txt到Raspberry Pi的用户目录下 scp file.txt pi@ttdevs.com: 拷贝本地文件file.txt到Raspberry Pi的用户目录下的raspi文件下，路径为/home/pi/raspi/ scp file.txt pi@ttdevs.com:raspi Raspberry Pi文件拷贝到本地 scp pi@ttdevs.com:file.txt . 拷贝远程Raspberry Pi用户目录下的file.txt到本地的当前目录 多文件拷贝 scp支持多文件拷贝，我们可以一次指定多个文件或者使用通配符来进行操作 指定多个文件 scp file.txt file2.txt pi@ttdevs.com: 使用通配符 scp *.txt pi@ttdevs.com: 0x04 HTTP为什么会提到这个呢？原因很简单，在接下来的学习中大部分的编码操作都会使用python来完成。所以我们会安装python语言，而且，默认情况我们的Raspberry Pi已经安装了python 2.7版本。python2 中默认包含了SimpleHTTPServer这个库。因此我们可以直接拿来使用。说了这么多你还不知道这个东东是干嘛的。其实从名字中我们就可以看出来，他是一个http server。既然是http server，那么我们就可以用来作为下载文件服务来使用，间接完成文件的拷贝。我们可以通过如下的命令来启动一个http服务： 123~ $ python -m SimpleHTTPServer 8088Serving HTTP on 0.0.0.0 port 8088 ...... 如果你想使用80端口（请确保没有被运营商封掉），请将8088改成80，sudo python -m SimpleHTTPServer 80。启动好之后我们就可以在浏览器中通过打开 http://&lt;your ip or domain&gt;:8088 这样的方式来访问启动服务时那个位置下的所有文件。如果你想从Raspberry Pi中拷贝文件到本地，那就在 Raspberry Pi 中启动服务，如果你想把本地文件拷贝到Raspberry Pi中，在我们本地启动服务即可。 至此，我们可以真正开始Raspberry Pi 操作了～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"「玩转树莓派」0x03初始化配置","slug":"[玩转树莓派]0x03初始化配置","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x03初始化配置/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x03初始化配置/","excerpt":"","text":"0x00 系统的初始化配置Config Raspberry Pi 系统的默认配置有时候无法满足我们多样的实际情况，比如我们的时区、我们的语言、我们外接显示器的接口类型和参数等等， 这个时候就需要我们对系统的默认配置进行修改，来满足我们的具体的要求。下面给大家介绍可能需要用到的配置。 0x01 config.txtconfig.txt 这是一个重要的系统配置文件，我们可以到 Raspberry Pi 的这个 /boot/config.txt 目录下查看，也可直接在 TF 卡的根目录下找到他。部分配置可参考：树莓派的安装 。更多的配置我们会在以后用到的时候讲解。 0x02 raspi-configraspi-config 这个工具可以对系统进行各种配置，需要使用系统权限执行：sudo raspi-config。打开后我们会见到如下图的配置界面： 这个界面操作比较简单，如果你用过DOS系统，肯定不会陌生。一般情况只有下面几种按键：Esc、Tab、上、下、左、右、Space、回车。确认按回车，返回用Esc，选择用Space、上、下和Tab。 Expand Filesystem 说他重要主要是因为很多小伙伴比较好奇 为什么我的文件系统变小了，只有MB级，而你用的却是16或者32G的存储卡。如果你也有这个疑问，则可以通过执行这个选项来扩展你的文件系统使其可以使用整个存储卡。 Change User Password 字面意思，修改你 Raspbian 的 pi 用户的密码 Boot Options 选择你的启动方式，如使用Console or GUI，是否自动登录 Wait for Network at Boot 是否在启动过程中等待网络连接，默认就好 Internationalistion Options 国际化支持，修改你的位置，时区，键盘布局，Wifi等。 Change Locale： 若果你可以无障碍使用英文，建议不做改动 若想使用中文，改为：zh_CN.UTF-8 UTF-8。改动之后建议安装中文字体，否则可能会出现乱码（四个数字的方块），具体参考下面的中文乱码。 TimeZone：东八区，所以我们选择：Asiz &gt; Shanghai Keyboard Layout：这个我们可以使用默认，或者根据你实际使用键盘选择 Wifi：我们选择 CN China Enable Camera Camera，不确定是启用我们自己的USB摄像头还是官方的摄像头，选择 Enable Add to Rastrack 一台设备，此处不做改动 Overclock 超频，这个自己决定，个人感觉没必要 Advanced Options 这里的选项比较多，共11项，以后用到的时候再过来介绍 About raspi-config 这个就不说了，没事可以读读 0x03 更新软件源如果你使用默认的软件源，很多时候速度是非常慢的，所以我们考虑换成国内的镜像。树莓派的软件源列表请参考这里，sources.list 的信息可参考这里。 可能你会问怎么选择，首先天朝的网络肯定选国内的，国内的简单来说选择离自己近的，运营商相同的，当然你也可以通过专业的测速工具来决定。我选择了 Open Source Software Association of Chinese Academy of Sciences（http://mirrors.opencas.cn/raspbian/raspbian/），下面介绍修改方法： 首先备份源列表 pi@raspi:/etc/apt $ sudo cp sources.list sources.list.bak 编辑源列表 sudo nano sources.list 12345678pi@raspi:/etc/apt $ cat sources.list#deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi# Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;#deb-src http://archive.raspbian.org/raspbian/ jessie main contrib non-free rpideb http://mirrors.opencas.cn/raspbian/raspbian/ jessie main contrib non-free rpi# Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;deb-src http://mirrors.opencas.cn/raspbian/raspbian/ jessie main contrib non-free rpi 更新 sudo apt-get update 0x04 中文乱码如果你在Change Locale 中选择了 zh_CN.UTF-8就可能出现中文乱码的问题，下面介绍如何修改： 安装字体：sudo apt-get install ttf-wqy-zenhei 顺便安装输入法：sudo apt-get -y install scim-pinyin 使用自己的字体：将自己的字体放到 ~/.local/share/fonts/ or ~/.fonts 文件夹中（没有的话就创建），然后刷新字体 fc-cache -fv 或者 重启 经过上面的配置，基本上就可以使用我们的 Raspberry Pi 了。接下来再给大家介绍如果突破天朝的网络问题，然后我们就可以正式的玩转树莓派了～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"「玩转树莓派」0x04还我80端口","slug":"[玩转树莓派]0x04还我80端口","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x04还我80端口/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x04还我80端口/","excerpt":"","text":"0x00 花生壳介绍Oray for Raspberry Pi 花生壳服务百度百科中有这样一段介绍： 花生壳是动态域名解析服务客户端软件。当您安装并注册该项服务，无论您在任何地点、任何时间、使用任何线路，均可利用这一服务建立拥有固定域名和最大自主权的互联网主机。“花生壳”支持的线路包括普通电话线、isdn、adsl、有线电视网络、双绞线到户的宽带网和其它任何能够提供互联网真实ip的接入服务线路，而无论连接获得的ip属于动态还是静态。 简单来说，我们可以通过花生壳的服务把我们的IP和一个域名做映射，映射后就可以使用域名访问而不需要记IP了。IP是一个不好记的东西，像我们这样的个人用户又是没有固定IP的（固定IP的宽带服务较贵，土豪可忽略），因此花生壳可以帮我们解决这个疼点。之前的花生壳给注册用户免费提供了一个二级域名，现在注册需要花5元购买一个永久的二级域名。下面会有介绍。 0x01 安装花生壳内网版花生壳内网版 这个东西是干嘛的？ 如果你没有接触过，可能会有这个疑问，且听我慢慢道来。现在或者未来的某一天，你会知道，中国电信或者其他家的宽带会封掉一些我们常用的端口，比如最常见的80端口。可能主要是为了加强网络管理，不允许私人在家里搭建网络服务吧。顺便告诉你一个不幸的消息，如果你的ssh不能在外网访问或者访问不稳定，也有可能被封了。而我们将要安装的 花生壳内网版 就是突破这个限制的。大家也可以参考这里。 下载首先，我们需要下载树莓派版的花生壳内网版，在树莓派上，我们可以用 wget 进行下载（这里我们下载到~/Downloads/），命令如下： 1pi@raspberrypi:~/Downloads $ wget http://download.oray.com/peanuthull/embed/phddns_raspberry.tgz 下载下来的文件叫 phddns_raspberry.tgz，我们对其进行解压： 123456pi@raspberrypi:~/Downloads $ tar zxvf phddns_raspberry.tgzphddns2/phddns2/oraynewphphddns2/oraynewph.tgzphddns2/oray_servephddns2/parse 安装我们需要使用root账号来安装，否则可能出现权限问题，导致安装失败。sudo su 切换到root，使用 ./oraynewph start 执行安装。下面是安装过程： 1234pi@raspberrypi:~/Downloads $ cd phddns2pi@raspberrypi:~/Downloads/phddns2 $ sudo suroot@raspberrypi:/home/pi/Downloads/phddns2# ./oraynewph start... 配置在上面的安装日志中我们可以看到这的提示信息（你也可以使用 oraynewph status 命令来查看此信息）： 123SN:RAPIe*************Please visit http://b.oray.comOraynewph start success ! 按照提示，我们打开 http://b.oray.com 这个网站，使用上面的SN登录系统（默认密码是admin，登录后会要求你设置密码，绑定花生壳账号等，如果你没有，那需要你注册一个），登录后如下图： 我们点击内网映射，进入设置界面，点击 添加配置，如下图： 经过如上配置，我们就可以通过域名来访问我们放在家里的树莓派上的http服务了。简单的，我们可以使用如下命令起一个http服务：sudo python -m SimpleHTTPServer 80 进行测试。 0x02 花生壳服务注册花生壳首先我们需要注册一个花生壳，并花¥5购买一个永久的二级域名，这个就介绍了，类似这样： 路由器上登录花生壳接下来的操作都是基于这个前提的。先回顾下我的网络拓扑： 我使用的是TP-Link的路由器，宽带ADSL拨号是在这个路由器上，路由器有一个公网IP。TP-Link路由器是支持花生壳服务的。我们在路由器登录花生壳账号后即可通过登录帐号绑定的域名来访问这个公网IP了，TP-Link的路由器登录后的信息如下： 配置DMZ对于挂在路由器下的 Raspberry Pi 仅仅依靠上面的花生壳配置还不够的。我们还需要启用路由器的DMZ主机功能，下面是关于DMZ的介绍： 在某些特殊情况下，需要让局域网中的一台计算机完全暴露给广域网，以实现双向通信，此时可以把该计算机设置为DMZ主机。 只有启用了该功能后，对应的DMZ主机才会生效。 根据介绍，我们做下面的配置： 这样发送到我们路由器的所有请求都会被转发到我们的 Raspberry Pi了，我们的 Raspberry Pi 就成了公网中的一台主机了。 PS：DMZ主机配置并不是一个安全的选择，更安全的配置是只影射我们使用的端口，比如80，22等 好了，这基本算是最后一篇基础介绍了。下一篇开始介绍树莓派最吸引我的地方 GPIO 操作，想想都兴奋了～～","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"「玩转树莓派」0x05GPIO","slug":"[玩转树莓派]0x05GPIO","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x05GPIO/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x05GPIO/","excerpt":"","text":"GPIO：General Purpose Input/Output pins on the Raspberry Pi General purpose input/output; in this specific case the pins on the Raspberry Pi and what you can do with them. So called because you can use them for all sorts of purposes; most can be used as either inputs or outputs, depending on your program. 0x00 GPIO有些事情坚持了，就做出来了，不坚持，就放弃了，就这么简单。之前想写个树莓派的入门文章，一下子写了几篇之后，就停下来了。可能最近确是比较忙，或者，承认没有严格要求自己，好吧，拖了这么久，今天，再写一篇。 不管你信不信，树莓派最吸引我的就是它的GPIO口。即使是现在，想到GPIO还是非常的兴奋呢。为什么呢？对于通用计算机，我们能操作的基本都是USB、串口等一些接口。与这些接口相比，GPIO口有明显的不同，我们可以直接操作一个IO口的状态：是高电平还是低电平。根据这个特性，我们就可以完成首次接触单片机完成的小实验：控制我们的LED灯，制作跑马灯，模拟交通灯等等有趣的实验。如果你想通过其他设备来完成这些操作，可能需要掌握其他对初学者来说比较困难的技术。另外，大学时期有玩过 89C51，对IO口还是恋恋不舍，曾经想通过其产生PWM信号控制舵机，很遗憾没实现，现在正好可以完成这个心愿。 0x01 从一个LED说开去这是一篇很基础的文章，所以会比较通俗。首先我们通过LED的Demo来了解下什么是GPIO。先看一张原理图： 这是一个非常简单的电路：一个发光二极管、一个电阻（300Ω左右，忘记怎么算的了）、一个Rapsberry Pi。由于Rapsberry Pi GPIO口输出电压是3V3，所以我们串一个电阻来保护我们的LED。当我们通过代码控制链接电阻的那个GPIO口状态时，就可以使LED在亮和灭之间切换。 12345678910111213141516171819import RPi.GPIO as GPIOimport timeGPIO.setmode(GPIO.BCM)GPIO.setwarnings(False)led = 23GPIO.setup(led, GPIO.OUT)try: while(True): GPIO.output(led, 1) time.sleep(1) GPIO.output(led, 0) time.sleep(1)except Exception as e: print(e)finally: GPIO.cleanup() 运行上面的代码，我们就可以看到LED两秒一个循环的亮灭。哈哈，是不是特有成就感，传说中的点亮小灯泡终于实现了～～ 然并卵，这并没有什么实际的用处。下面再介绍一个屌屌的demo，通过HC-SR501人体红外传感器检测控制LED的亮灭，实际的例子的就是很多自动门，站在门下面的时候门会自动打开。 HC-SR501 它是长这个样子滴： (PS:以上图片来自两个淘宝卖家) 三个针脚：VCC、OUT、GND，另外还有一个是否连续监测的针脚，连续时是H，不连续时是L，默认是H，看你买的具体设计了。另外还有两个调节旋钮，如上图。其实这个传感器特简单，供电电压5到20V，输出0或者3V3两个状态，不用与 Raspiberry Pi 连接，也可以直接当作开关使用。另外我还接了一个自锁开关，控制整个电路的开关。如下图： 接着上源码： import RPi.GPIO as GPIO import time GPIO.setmode(GPIO.BCM) GPIO.setwarnings(False) led = 25 GPIO.setup(led, GPIO.OUT) swtich = 22 GPIO.setup(swtich, GPIO.IN, GPIO.PUD_UP) hcsr501 = 23 GPIO.setup(hcsr501, GPIO.IN, GPIO.PUD_UP) try: GPIO.output(led, 0) while(True): print(str(GPIO.input(swtich)) + '||' + str(GPIO.input(hcsr501))) if GPIO.input(swtich) == True: if GPIO.input(hcsr501) == True: GPIO.output(led, 1) else: GPIO.output(led, 0) else: GPIO.output(led, 0) time.sleep(1) except Exception as e: print(e) finally: GPIO.cleanup() 当我们把开关打开，经过人体红外传感器的时候LED（这个地方我用的是3V3的高亮LED，所以没有接电阻）就会亮。把这个东西放在房间里，晚上下班开门就可以自动开灯了。如果你有兴趣，还可以把里面的开关换成一个光线传感器，那样就更完美了～～ 运行上面的代码，我们需要安装 RPi.GPIO 库，Raspbian 默认是安装好了。简单的浏览上面的代码，我们可以发现，首先设置 GPIO mode，这里设置为BCM；然后定义GPIO的状态，GPIO口我们可以定义两种状态，GPIO.IN 和 GPIO.OUT，分别对应输入和输出；最后就是操作我们的GPIO口了。由于RPi.GPIO 库已经给我们封装复杂的操作，所以我们用起来特别简便。更多可 RPi.GPIO 信息可参考这里。 0x02 Raspberry Pi的GPIO针脚根据上面的demo程序，我们再来详细的介绍下GPIO。 GPIO.setmode() 指定针脚的编号方式，这里有两种选择： GPIO.BOARD 使用针脚的物理顺序来编号 GPIO.BCM Broadcom SoC 的编码方式 具体的可参考下面这张图，其中 Pin 列代表的是 GPIO.BOARD 方式的编码， 而 NAME 列代表的是GPIO.BCM 方式的编码。 不同版本的 Raspberry Pi 会有不同的针脚分布，除查阅相关资料外，可以执行下面命令查看：pi@raspberrypi:~ $ gpio readall GPIO.setwarnings(True or False) 当我们有多个脚本在操作同一个GPIO口时可能会出现警告，通过这个设置来选择是否忽略 GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH) 设置GPIO口的状态，参数分别为：针脚序号、输入还是输出、初始状态高电平还是低电平。 GPIO.input(channel) 获取指定GPIO口的状态 GPIO.output(channel, GPIO.HIGH) 操作GPIO口的输出状态 GPIO.cleanup() 清除当前操作的所有GPIO口的状态，恢复为输入状态。好的做法是每次使用完都清除一下。 这就是一个简单完整的使用 python 操作 GPIO的流程。虽然看到的现象，看到的代码，但是你还会问：GPIO到底是个啥样的东西，我们设置不同的状态时它的电压时怎样的？它的驱动能力如何？什么样的操作可能导致烧毁GPIO？ Raspberry Pi 2 Model B 使用了 BCM2836芯片，Raspberry Pi Model A, B, B+, Compute Module and Raspberry Pi Zero使用了BCM2835芯片，这里我们以BCM2835为例（作为一般使用者，可以不关心这个）。BCM2835有3个GPIO bank，这个3个bank都有自己的VDD，并且由3V3电压提供支持。如果我们的输入电压超过3V3，就有可能烧毁SoC上的GPIO bank。由于我也是业余的，说的再专业我也听不懂，因此简单的来说，使用外部传感器，它的输入信号电压是3V3的就没问题。当然，传感器的驱动电压可以不是3V3。比如上面使用的 HC-SR501 它的驱动电压是5V，输入信号电压是3V3，这样接在外面的 Raspberry Pi 就完全没问题，而且不需要额外电源为其供电，因为 Raspberry Pi 2 Model B 有两个5V的针脚（就是右上角的两个，2和4）。 更多的关于GPIO的上拉下拉悬浮等状态，可以参考这里的介绍。 0x03 GPIO进阶对于控制简单的设备，比如LED，使用 RPi.GPIO 已经够用了。但是当我们进一步研究之后会发现RPi.GPIO并不是那么完美，在它的官方文档上有这么两段话： Note that this module is unsuitable for real-time or timing critical applications. This is because you can not predict when Python will be busy garbage collecting. It also runs under the Linux kernel which is not suitable for real time applications - it is multitasking O/S and another process may be given priority over the CPU, causing jitter in your program. If you are after true real-time performance and predictability, buy yourself an Arduino http://www.arduino.cc !Note that the current release does not support SPI, I2C, hardware PWM or serial functionality on the RPi yet. This is planned for the near future - watch this space! One-wire functionality is also planned. 从上面我们可以了解到 RPi.GPIO 并不适合实时性要求高的应用，也不适合周期计数的应用。python本身性能就不是非常理想，比如当我们尝试用python去操作DHT11（温湿度传感器）就非常的困难，因为很难和它的时序保持同步。而且linux并不是实时操作系统，运行在linux内核之上，无法避免被其他进程抢占CPU。目前版本的 RPi.GPIO 并不支持SPI、I2C、硬件PWM、串口等。如果你希望使用这些接口，那就需要考虑换一个库或者换一种语言了。具体的是用，在以后的文章中会做介绍。 0xFF 参考 https://github.com/raspberrypi/documentation https://zh.scribd.com/doc/101830961/GPIO-Pads-Control2 https://pypi.python.org/pypi/RPi.GPIO http://dreamcolor.net/archives/rpi-gpio-module-pwm.html","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]},{"title":"Hello World","slug":"hello-world","date":"1969-12-31T16:00:00.000Z","updated":"2017-01-01T04:24:36.000Z","comments":true,"path":"1970/01/01/hello-world/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment === My Demo这是一篇记录使用方法的介绍， 共以后参考。 title1title2title3测试TOC 创建tags 方法一 123tags: - hexo - yml 方法二 1tags: [hexo, yml] 插入图片 插入代码 方法一 123public class Test()&#123; &#125; 方法二 public class Test(){ } 创建About页面123➜ blog hexo new page &quot;about&quot;INFO Created: ~/OneDrive/blog/source/about/index.md➜ blog 插入音乐123&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66\"&gt; &lt;/iframe&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ttdevs.github.io/tags/hexo/"},{"name":"yml","slug":"yml","permalink":"https://ttdevs.github.io/tags/yml/"}]},{"title":"「玩转树莓派」0x06DS18B20温度检测","slug":"[玩转树莓派]0x06DS18B20温度检测","date":"1969-12-31T16:00:00.000Z","updated":"2017-04-27T11:07:57.000Z","comments":true,"path":"1970/01/01/[玩转树莓派]0x06DS18B20温度检测/","link":"","permalink":"https://ttdevs.github.io/1970/01/01/[玩转树莓派]0x06DS18B20温度检测/","excerpt":"","text":"0x00 DS18B20温度检测Raspberry connect to DS18B20 需要一个能测量水温的温度计，淘宝买了高逼格的红外温枪，到手后发现这鬼东西不能测金属杯里的水温（好的太贵）。然后又淘宝了下，一个电子温度计都卖三位数，好吧，我穷…… 忽然想起手上有一个 DS18B20，嗯嗯，拿出来自己做一个温度计吧～～ DS18B20 这个传感器很常见，某宝上一搜一购物车，价格5到10元不等，当然也有更好的，按需购买，大概参数如下： 独特的1-Wire总线接口仅需要一个管脚来通信。 每个设备的内部ROM上都烧写了一个独一无二的64位序列号。 多路采集能力使得分布式温度采集应用更加简单。 无需外围元件。 能够采用数据线供电；供电范围为3.0V至5.5V。 温度可测量范围为：-55℃至+125℃（-67℉至+257℉）。 温度范围超过-10℃至85℃之外时具有+-0.5℃的精度。（怀疑有误） 内部温度采集精度可以由用户自定义为9-Bits至12-Bits。 DS18B20 分辨率可编程 1-Wire数字温度传感器 温度转换时间在转换精度为12-Bits时达到最大值750ms。 用户自定义非易失性的的温度报警设置。 · 定义了温度报警搜索命令和当温度超过用户自定义的设定值时。 可选择的8-Pin SO (150 mils), 8-PinμSOP，及3-Pin TO-92封装。 · 与DS1822程序兼容。 应用于温度控制系统，工业系统，民用产品。 嗯嗯，很多技术参数，作为外行人看着就晕。这里关注几个细节就好： 电压：3.0V～5.5V 温度范围：-55℃至+125℃ 测量精度：可调，0.5℃对我来说可接受，所以暂时没去细究 接下来结合我的树莓派的板子，给大家演示如何使用。 0x01 使用首先按照网上的方法，比如vvbbbbb，一步步操作，难免遇到一些坑，我的问题是怎么都不能识别这个传感器，后来找了很久，无意中解决了，结合我的实际，做简单记录，具体操作如下： 连接传感器和Raspberry Pi DS18B20 有三个针脚，分别是 VCC 红色，连 Raspberry Pi 的 VCC，测试连接 3V3 或 5V5 都可以 DATA 黄色，连 Raspberry Pi 的 GPIO4 GND 黑色，连 Raspberry Pi 的 GND 另外和需要在用一个 4.7K 的电阻连接 VCC 和 DATA （别问我为什么，我也不知道，大学模电学的那叫一个渣），如果你没有 4.7K 的电阻，听说大一点或者小一点都可以，我没试，反正我有。如果你连电阻都没有，告诉你某宝上有打包一袋出售的，常用阻值的都有，很便宜，值得你入手。好了，最终电路如图： 操作 更新系统 如果你的系统版本比较旧，建议你更新，否则跳过这一步： 12sudo apt-get updatesudo apt-get upgrade 更新速度视你的网速和源的速度，怎么切换源，可以参考我之前的文章。 1. 启用 `1-Wire` - 终端执行 `sudo raspi-config`，打开配置界面，找到 `1-Wire`（我的位于`Interfacing Option` 下，不同版本不一样，有的可能在 `Advanced Options` 下）启用它。 - 你也可以直接配置：编辑 `/boot/config.txt` ，在最后一行添加 `dtoverlay=w1-gpio` 保存即可。 1. 终端输入：`sudo nano /boot/config.txt` 2. `Ctrl+V` 滚到最下面，输入 `dtoverlay=w1-gpio` 3. `Ctrl+O` 保存，`Ctrl+X` 退出 两个方法结果一样，操作完成之后需要重启机器，命令：`sudo reboot` 2. 查看你的传感器 1234567pi@raspberrypi:~ $ cd /sys/bus/w1/devicespi@raspberrypi:/sys/bus/w1/devices $ ls28-031561d43aff w1_bus_master1pi@raspberrypi:/sys/bus/w1/devices $ cat 28-031561d43aff/w1_slave48 01 01 01 1f ff 0c 10 04 : crc=04 YES48 01 01 01 1f ff 0c 10 04 t=20500pi@raspberrypi:/sys/bus/w1/devices $ 先查看 `w1` 设备列表，然后查看里面的 `w1_slave` 文件内容，即可显示出温度信息（这个温度信息并不是我们最终的温度，需要经过一定的换算）。 `前方高能` `前方填坑` 嗯嗯，坑出现了，我的在查看传感器的时候显示如下： 1234pi@raspberrypi:~$ cd /sys/bus/w1/devices/pi@raspberrypi:/sys/bus/w1/devices $ ls00-600000000000 00-a00000000000 00-e00000000000 w1_bus_master1pi@raspberrypi:/sys/bus/w1/devices $ 网上看到的都是 `28-xxxxxxxxxxxxxx` 这样的信息，而我的却不是；这些目录下也没有 `w1_slave`文件；而且每次进这个目录 `/sys/bus/w1/devices` 这些文件夹的名字和数量都有可能会变。好吧，懵逼了。所以去找答案，果然也有一些人反应过这个问题，但大部分对我都没用，比如 VCC 从 3V3 换到 5V5 ，看看时间，又快12点了，想放弃了都。此时[佛光乍现](https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=106041)：可能是 `GPIO` 口的问题，可以换一个试试，一试果然很爽，操作如下： 编辑 `/boot/config.txt`，将刚才添加的那行修改如下 `dtoverlay=w1-gpio,gpiopin=5,pullup=on` 这里的 `5` 是对应的GPIO口，你也可以用其他的，高兴就好。保存重启即可。 3. 查看温度数据 1234pi@raspberrypi:/sys/bus/w1/devices $ cat 28-031561d43aff/w1_slave48 01 01 01 1f ff 0c 10 04 : crc=04 YES48 01 01 01 1f ff 0c 10 04 t=20500pi@raspberrypi:/sys/bus/w1/devices $ 这里的 `t=20500` 应该就是温度数据，不知道 `crc=40` 是不是校验数据，不管了，我也没时间去计算。网上肯定有现成的轮子来展示，这里推荐 [w1thermsensor](https://github.com/timofurrer/w1thermsensor)。 - 安装 `pip install w1thermsensor` - 使用(ds18b20.py) 12345from w1thermsensor import W1ThermSensorsensor = W1ThermSensor(W1ThermSensor.THERM_SENSOR_DS18B20, \"031561d43aff\")while True: temperature_in_celsius = sensor.get_temperature() print temperature_in_celsius 这里的一个常量 `031561d43aff` 就是 `28-031561d43aff` 这里的后半部分，你的可能跟我不一样，请改成你自己看到的。 执行： 123456789pi@raspberrypi:~/python $ cat ds18b20.pyfrom w1thermsensor import W1ThermSensorsensor = W1ThermSensor(W1ThermSensor.THERM_SENSOR_DS18B20, \"031561d43aff\")while True: temperature_in_celsius = sensor.get_temperature() print temperature_in_celsiuspi@raspberrypi:~/python $ python ds18b20.py21.021.0 完美～ 0xFF 参考 https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf http://www.wendangku.net/doc/529cf93fc281e53a5802fff5.html http://blog.csdn.net/vvbbbbb/article/details/52053293 https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=106041","categories":[{"name":"技术","slug":"技术","permalink":"https://ttdevs.github.io/categories/技术/"}],"tags":[{"name":"玩转树莓派","slug":"玩转树莓派","permalink":"https://ttdevs.github.io/tags/玩转树莓派/"}]}]}